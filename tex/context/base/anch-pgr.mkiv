%D \module
%D   [       file=anch-pgr, % split off core-pos
%D        version=1999.08.01,
%D          title=\CONTEXT\ Anchoring Macros,
%D       subtitle=Positioning Graphics,
%D         author=Hans Hagen,
%D           date=\currentdate,
%D      copyright={PRAGMA ADE \& \CONTEXT\ Development Team}]
%C
%C This module is part of the \CONTEXT\ macro||package and is
%C therefore copyrighted by \PRAGMA. See mreadme.pdf for
%C details.

\writestatus{loading}{ConTeXt Anchoring Macros / Grapics}

%D We can use the commandhandler here.

%D Before we come to graphics support, we have to make sure of
%D the reference point on the page. The next macro does so and
%D is hooked into the page building routine.

%D I will speed up this module when I have a proper torture
%D test file.

%D This module will be adapted to \MKIV\ and we will have a
%D more direct processing in a pre-shipout phase.

\unprotect

% in the future, the depth of tail will reflect page depth

\ifx\textheight\undefined \def\textheight{\vsize} \fi

%D The next macros so some housekeeping.

\def\pageanchor{page:0} % for the moment only one pagesize
\def\textanchor{text:\the\realpageno}
\def\headanchor{head:\the\realpageno} % virtual position
\def\tailanchor{tail:\the\realpageno} % virtual position

%D Anchors:

\def\dopresetpositionanchors % also mkii
  {\bgroup
   \!!dimena\ifdim\topskip>\strutht\topskip\else\strutht\fi
   \!!dimenb\dimexpr\MPy\textanchor+\MPh\textanchor-\!!dimena\relax
   \!!dimenc\dimexpr\MPy\textanchor+\strutdp\relax
   \!!dimend\MPx\textanchor
   \!!dimene\MPw\textanchor
   \replacepospxywhd\headanchor\realfolio\!!dimend\!!dimenb\!!dimene\!!dimena\strutdp
   \replacepospxywhd\tailanchor\realfolio\!!dimend\!!dimenc\!!dimene\strutht \strutdp
   \egroup}

\def\presetpositionanchors% compatibility hack (still needed?)
  {\ifpositioning
     \dopresetpositionanchors
   \fi}

%D The first version of this module implemented head and tail
%D anchors. Currently we stick to just one anchor and derive
%D the head and tail anchors from this one.

\def\showanchor#1%
  {\expanded{\writestatus{#1}
     {\MPp{#1}\string|\MPx{#1}\string|\MPy{#1}\string|%
      \MPw{#1}\string|\MPh{#1}\string|\MPd{#1}}}}

%D We set these anchors before and after each page.

\appendtoks \presetpositionanchors \to \beforeeverypage
\appendtoks \presetpositionanchors \to \aftereverypage

% todo: change with each page size change .. can be made more efficient
% as some values are the same .. this one can (at some point) be used
% to provide correction for imposition

\def\doregisterpageposition#1%
  {\setbox#1\hbox{\hpos\pageanchor{\box#1}}}

\def\registerpageposition#1% this one is flushed first ! ... can't we avoid this one
  {\ifpositioning\ifcase\realpageno\or
     \ifdim\printpaperheight=\paperheight
       \ifdim\printpaperwidth=\paperwidth
         % not needed,
       \else
         \doregisterpageposition{#1}%
       \fi
     \else
       \doregisterpageposition{#1}%
     \fi
   \fi\fi}

\unexpanded\def\placepositionanchors % todo : depth pagebox
  {\ifpositioning
     \setbox\scratchbox\vbox to \textheight
       {\simpletopskipcorrection
        \hbox{\strut\dopositionaction\headanchor}%
        \vfill
        \hbox{\strut\dopositionaction\tailanchor}}%
     \dp\scratchbox\zeropoint
     \wd\scratchbox\makeupwidth % not \zeropoint, else wrong text backgrounds
     \hpos\textanchor{\box\scratchbox}%
   \else
     \vskip\textheight
   \fi}

%D \macros
%D   {positionoverlay,startpositionoverlay}
%D
%D As long as we're dealing with graphics it makes much sense
%D to use the available overlay mechanism. For this purpose, we
%D define some dedicated overlay extensions.
%D
%D \startbuffer[sample]
%D \defineoverlay [sample] [\positionoverlay{sample}]
%D
%D \startpositionoverlay{sample}
%D   \setMPpositiongraphic{A-1}{connectcenter}{from=A-1,to=A-2}
%D \stoppositionoverlay
%D \stopbuffer
%D
%D \typebuffer[sample]
%D
%D \startbuffer[graphic]
%D \startMPpositiongraphic{connectcenter}
%D   path pa, pb ; pair ca, cb ;
%D   initialize_box(\MPpos{\MPvar{from}}) ; pa := pxy ; ca := cxy ;
%D   initialize_box(\MPpos{\MPvar{to}}) ; pb := pxy ; cb := cxy ;
%D   draw pa withcolor red ;
%D   draw pb withcolor red ;
%D   draw ca -- cb withcolor blue ;
%D   anchor_box(\MPanchor{\MPvar{from}}) ;
%D \stopMPpositiongraphic
%D \stopbuffer
%D
%D We can best demonstrate this in an example, say:
%D
%D \startbuffer[text]
%D \framed
%D   [backgroundachtergrond=sample,align=middle,width=7cm]
%D   {We want to connect \hpos {A-1} {this} word with its
%D    grammatical cousin \hpos {A-2} {that}.}
%D \stopbuffer
%D
%D \typebuffer[text]
%D
%D \startlinecorrection
%D %\getbuffer[graphic,sample,text]
%D \stoplinecorrection
%D
%D The graphic is defined in the following way, using some
%D macros defined in an auxiliary \METAPOST\ module that is
%D preloaded.
%D
%D \typebuffer[graphic]

\def\MPanchoridentifier{mpa} % {mp-anchor}
\def\MPoverlayposprefix{MO::}

%D The rest of the definitions concerning such overlays may
%D look complicated,

\let\currentpositionoverlay\empty

%D Position actions are automatically executed when a position
%D is set.

\let\MPanchornumber\realfolio

\def\positionoverlay#1% the test prevents too many redundant positions
  {\ifpositioning     % in (not used) text* position layers
     \vbox to \overlayheight
       {\doifpositionactionelse{#1::\MPanchoridentifier}%
          {\edef\MPanchorid{#1::\MPanchoridentifier:\MPanchornumber}%
           \edef\MPanchor##1{\MPpos{\MPanchorid}}%
           \the\everyinsertpositionaction
           \copyposition{#1::\MPanchoridentifier}{#1::\MPanchoridentifier:\MPanchornumber}%
           \hpos
             {#1::\MPanchoridentifier:\MPanchornumber}%
            % this is ok
            %{\hbox to \overlaywidth{\dopositionaction{#1::\MPanchoridentifier}\hss}}}%
            % but this one prevents cyclic runs due to
            % rounding errors
             {\setbox\scratchbox\hbox to \overlaywidth{\dopositionaction{#1::\MPanchoridentifier}\hss}%
              \ht\scratchbox\overlayheight
              \dp\scratchbox\zeropoint
              \box\scratchbox}}%
          {\hbox to \overlaywidth{\hss}}%
        \vfill}%
   \fi}

\unexpanded\def\startpositionoverlay#1%
  {\iftrialtypesetting % we don't want redundant entries in the list
     \@EA\gobbleuntil\@EA\stoppositionoverlay
   \else
     \def\currentpositionoverlay{#1}%
   \fi}

\unexpanded\def\stoppositionoverlay
  {\let\currentpositionoverlay\empty}

\def\resetpositionoverlay#1%
  {\dosetpositionaction{#1::\MPanchoridentifier::}{}}

%D Here the complication has to do with collecting actions
%D for later execution. This collection is especially handy
%D when we want to move actions to a specific layer.
%D Such series of actions are stored in a macro (the one
%D with the funny \type {++}) which is cleaned up after each
%D invocation.

\newtoks\everycleanpositionaction
\newtoks\everyinsertpositionaction

\def\cleanuppositionaction#1% not in trialtypesetting
  {\ifcsname\POSactionprefix#1++\endcsname
     \the\everycleanpositionaction
     \iflocalpositioning
       \letgvalue{\POSactionprefix#1++}\empty
     \else
       \setxvalue{\POSactionprefix#1++}{\getvalue{\POSactionprefix#1++}}%
     \fi
   \fi}

\def\handlepositionaction#1\with#2\on#3%
  {\bgroup
   \ifx\currentpositionoverlay\empty
     \edef\!!stringa{#3}% no layer, just pos itself as anchor
   \else
     \edef\!!stringa{\currentpositionoverlay::\MPanchoridentifier}%
   \fi
   \edef\!!stringc{\POSactionprefix\!!stringa++}%
   \expanded{\dosetpositionaction{\!!stringa}{\noexpand\getvalue{\!!stringc}}}%
   \global\let#1\relax
   \edef\!!stringb{\executeifdefined\!!stringc\empty}%
   \setxvalue\!!stringc{\!!stringb#1#2}%
   \egroup}

%D The indirectness enables us redefine macros for special
%D purposes, like a cleanup.

\def\handlepositionboxes#1#2#3%
  {\handlepositionaction\dohandlepositionboxes\with{#1}{#2}{#3}\on{#2}}

\def\doinsertpositionboxes#1#2#3% pos tag setups
  {\ifnum\MPp{#1}=\realpageno\relax % can be sped up
     \executeifdefined{\MPoverlayposprefix#1}\gobblethreearguments{#1}{#2}{#3}%
   \fi}

\appendtoks
    \let\dohandlepositionboxes\doinsertpositionboxes % was handle ?
\to \everyinsertpositionaction

\def\docleanpositionboxes#1#2#3% pos tag setups
  {\ifnum\MPp{#1}<\realpageno \else
     \noexpand \dohandlepositionboxes{#1}{#2}{#3}% reinsert
   \fi}

\appendtoks
    \let\dohandlepositionboxes\docleanpositionboxes
\to \everycleanpositionaction

%D A position graphic is a normal (non||reused) \METAPOST\
%D graphic, used immediately, with zero dimensions, so that a
%D sequence of them does not harm.

\newbox\positiongraphicbox

\def\startMPpositiongraphic % id setups
  {\dodoublegroupempty\dostartMPpositiongraphic}

\long\def\dostartMPpositiongraphic#1#2#3\stopMPpositiongraphic
  {\long\setgvalue{MPG:#1}% tag list mpcode
     {\useMPpositiongraphic{#1}{#2}{#3}}}

\let\stopMPpositiongraphic\relax

\def\prepareMPpositionvariables
  {\ifcsname\@@meta self\endcsname\else\setvalue{\@@meta self}{\currentposition}\fi
   \ifcsname\@@meta from\endcsname\else\setvalue{\@@meta from}{\currentposition}\fi}

\long\def\useMPpositiongraphic#1#2#3%
  {\bgroup
   \prepareMPvariables{#2}%
   \prepareMPpositionvariables
   \enableincludeMPgraphics
   \startMPcode#3\stopMPcode
   \egroup}

% Now we need a adapted action handler:

\def\dopositionaction#1% test saves hash entry in etex
  {\ifcsname\POSactionprefix#1::\endcsname
     \dodopositionaction{#1}%
   \fi}

\def\dodopositionaction#1%
  {\ifnum\MPp{#1}>\zerocount % new
     \bgroup
     \setbox\scratchbox\hbox
     \bgroup
     \traceposstring\clap\red{<#1>}%
     \the\everyinsertpositionaction
     \the\everypositionaction
     \csname\POSactionprefix#1::\endcsname
     \cleanuppositionaction{#1}%
     \egroup                % smashed is really needed else
     \smashedbox\scratchbox % we get problems with too big
     \egroup                % overlays (s-pre-0x.tex)
   \else
     % shouldn't happen too often
     \traceposstring\clap\cyan{<#1>}%
   \fi}

\def\MPpositiongraphic
  {\dodoublegroupempty\doMPpositiongraphic}

\def\doMPpositiongraphic#1#2% tag setups
  {\bgroup
   \def\@@meta{#1:}%
   \setupMPvariables[#2]%
   \prepareMPpositionvariables
   \MPshiftdrawingtrue
   \def\doMPpositiongraphic##1##2%
     {{% new, see (techniek)
       \def\@@meta{##1:}%
       \setupMPvariables[#2,##2]%
       \prepareMPpositionvariables
       % and needed
       \getvalue{MPG:##1}}}% temp hack
   \setbox\positiongraphicbox\hbox
     {\ignorespaces
      \executeifdefined{MPM:#1}{\executeifdefined{MPG:#1}\donothing}%
      \removelastspace}%
   \smashbox\positiongraphicbox
   \box\positiongraphicbox
   \egroup}

\long\def\startMPpositionmethod#1#2\stopMPpositionmethod
  {\long\setgvalue{MPM:#1}{#2}} % todo: var list here

\let\stopMPpositionmethod\relax

%D Simple one position graphics.

\def\setMPpositiongraphic
  {\dotriplegroupempty\dosetMPpositiongraphic}

\def\dosetMPpositiongraphic#1#2#3% pos tag vars
  {\ifx\currentpositionoverlay\empty
     \dosetpositionaction{#1}{\MPpositiongraphic{#2}{#3}}%
   \else % silly can be one
     \handlepositiongraphics{#1}{#2}{#3}%
   \fi}

\def\handlepositiongraphics#1#2#3% combine with boxes
  {\handlepositionaction\dohandleMPpositiongraphic\with{#1}{#2}{#3}\on{#2}}

\def\doinsertMPpositiongraphic#1#2#3% pos tag setups
  {\ifnum\MPp{#1}=\realpageno\relax % extra saveguard
     \def\currentposition{#1}\MPpositiongraphic{#2}{#3}%
   \fi}

\appendtoks
    \let\dohandleMPpositiongraphic\doinsertMPpositiongraphic
\to \everyinsertpositionaction

\def\docleanMPpositiongraphic#1#2#3% pos tag setups
  {\ifnum\MPp{#1}<\realpageno \else
     \noexpand \dohandleMPpositiongraphic{#1}{#2}{#3}%
   \fi}

\appendtoks
    \let\dohandleMPpositiongraphic\docleanMPpositiongraphic
\to \everycleanpositionaction

%D Graphics that span two positions (beware, does not cross pages).

\def\setMPpositiongraphicrange
  {\doquadruplegroupempty\dosetMPpositiongraphicrange}

\def\dosetMPpositiongraphicrange#1#2#3#4% bpos epos tag vars
  {\ifx\currentpositionoverlay\empty
     \dosetpositionaction{#1}{\MPpositiongraphic{#3}{#4}}%
   \else
     \handlepositiongraphicsrange{#1}{#2}{#3}{#4}%
   \fi}

\def\handlepositiongraphicsrange#1#2#3#4%
  {\handlepositionaction\dohandleMPpositiongraphicrange\with{#1}{#2}{#3}{#4}\on{#2}}

\def\doinsertMPpositiongraphicrange#1#2#3#4% pos pos tag setups
  {\ifnum\MPp{#1}\MPp{#2}>\zerocount
     \iflocalpositioning
       \donetrue
     \else
       \donefalse
       \ifnum\MPp{#1}=\realpageno
         \donetrue
       \else\ifnum\MPp{#2}=\realpageno
         \donetrue
       \else\ifnum\MPp{#1}<\realpageno\relax\ifnum\MPp{#2}>\realpageno
         \donetrue
       \fi\fi\fi\fi
     \fi
     \ifdone
       \def\currentposition{#1}\MPpositiongraphic{#3}{#4}%
     \fi
   \fi}

\appendtoks
    \let\dohandleMPpositiongraphicrange\doinsertMPpositiongraphicrange
\to \everyinsertpositionaction

\def\docleanMPpositiongraphicrange#1#2#3#4% pos tag setups
  {\ifnum\MPp{#2}<\realpageno \else
     \noexpand \dohandleMPpositiongraphicrange{#1}{#2}{#3}{#4}%
   \fi}

\appendtoks
    \let\dohandleMPpositiongraphicrange\docleanMPpositiongraphicrange
\to \everycleanpositionaction

% will be overloaded, and/or code below moved to core-box

\defineoverlay[\v!text-2][\positionoverlay{\v!text-2}]
\defineoverlay[\v!text-1][\positionoverlay{\v!text-1}]
\defineoverlay[\v!text+1][\positionoverlay{\v!text+1}]
\defineoverlay[\v!text+2][\positionoverlay{\v!text+2}]

%D Some of these macros are pretty clever but too complicated
%D to be nice. When things are kind of stable I'll clean up
%D this mess.

%D THIS NEEDS A CLEANUP

\setupMPvariables
  [mpos:box]
  [linecolor=blue,
   linewidth=\linewidth,
   fillcolor=lightgray,
   filloffset=\!!zeropoint]

\startMPpositiongraphic{mpos:box}{fillcolor,linecolor,linewidth}
  initialize_box(\MPpos{\MPvar{self}}) ;
  def boxfilloptions = withcolor \MPvar{fillcolor} enddef ;
  def boxlineoptions = withcolor \MPvar{linecolor} enddef ;
  boxlinewidth  := \MPvar{linewidth} ;
  boxfilloffset := \MPvar{filloffset} ;
  draw_box ;
  anchor_box(\MPanchor{\MPvar{self}}) ;
\stopMPpositiongraphic

\setupMPvariables
  [mpos:area]
  [linecolor=blue,
   linewidth=\linewidth,
   fillcolor=lightgray,
   filloffset=\!!zeropoint]

\startMPpositiongraphic{mpos:area}{fillcolor,linecolor,linewidth}
  initialize_area(\MPpos{b:\MPvar{self}},\MPpos{e:\MPvar{self}}) ;
  def boxfilloptions = withcolor \MPvar{fillcolor} enddef ;
  def boxlineoptions = withcolor \MPvar{linecolor} enddef ;
  boxlinewidth  := \MPvar{linewidth} ;
  boxfilloffset := \MPvar{filloffset} ;
  draw_area ;
  anchor_area(\MPanchor{b:\MPvar{self}}) ;
\stopMPpositiongraphic

%D This is already cleaned up.

% gridtype = 1 => baseline
% gridtype = 2 => betweenline

\setupMPvariables
  [mpos:par]
  [mp=mpos:par:shape,
   gridtype=0,
   linetype=1,
   filltype=1,
   dashtype=0, % 1 = dashed, 2 = dashed with background
  %snaptops=true, % not that nice: true/false
   gridcolor=red,
   linecolor=blue,
   fillcolor=lightgray,
   filloffset=\!!zeropoint,
   linewidth=\linewidth,
   gridwidth=\linewidth,
   gridshift=\!!zeropoint,
   lineradius=.5\bodyfontsize,
   dashtype=1]

\startuseMPgraphic{mpos:par:shape}
  \iftracepositions show_par \else draw_par \fi ;
\stopuseMPgraphic

\startuseMPgraphic{mpos:par:setup}
   boxgridtype   := \MPvar{gridtype} ;
   boxlinetype   := \MPvar{linetype} ;
   boxfilltype   := \MPvar{filltype} ;
   boxdashtype   := \MPvar{dashtype} ;
   def boxgridoptions = withcolor \MPvar{gridcolor} enddef ;
   def boxlineoptions = withcolor \MPvar{linecolor} enddef ;
   def boxfilloptions = withcolor \MPvar{fillcolor} enddef ;
   boxfilloffset := \MPvar{filloffset} ;
   boxlinewidth  := \MPvar{linewidth} ;
   boxgridwidth  := \MPvar{gridwidth} ;
   boxgridshift  := \MPvar{gridshift} ;
   boxlineradius := \MPvar{lineradius} ;
  %snap_multi_par_tops := \MPvar{snaptops} ;
\stopuseMPgraphic

\startuseMPgraphic{mpos:par:extra}
  % user stuff, like:
  % snap_multi_par_tops := false ;
\stopuseMPgraphic

\ifx\MPparcounter\undefined \newcounter\MPparcounter \fi

\def\MPself     {\MPvar{self}}
\def\MPbself    {b:\MPself}
\def\MPeself    {e:\MPself}
\def\MPwself    {w:\MPself}
\def\MPparanchor{p:\MPparcounter}

\def\MPl#1{\MPplus{#1}20}
\def\MPr#1{\MPplus{#1}30}

\startMPpositionmethod{mpos:par} %%%%%%%%%%% will become obsolete
  \edef\MPparcounter{\MPv\MPbself{1}{0}}%
  \doifpositionelse\MPwself
    {\startMPpositiongraphic{mpos:par}{fillcolor,filloffset,linecolor,gridcolor,linewidth,gridwidth,gridshift,lineradius}
       initialize_area_par(\MPpos\MPbself,
                           \MPpos\MPeself,
                           \MPpos\MPwself) ;
       \includeMPgraphic{mpos:par:setup} ;
       \includeMPgraphic{mpos:par:extra} ;
       \includeMPgraphic{\MPvar{mp}} ;
       anchor_par(\MPanchor\MPbself) ;
     \stopMPpositiongraphic}
    {\startMPpositiongraphic{mpos:par}{fillcolor,filloffset,linecolor,gridcolor,linewidth,gridwidth,gridshift,lineradius}
       initialize_par(\MPpos\MPbself,
                      \MPpos\MPeself,
                      \MPpos\textanchor,
                      \MPpos\MPparanchor,
                      \MPvv \MPparanchor{0pt,0pt,0pt,0pt,0,0pt}) ;
       \includeMPgraphic{mpos:par:setup} ;
       \includeMPgraphic{mpos:par:extra} ;
       \includeMPgraphic{\MPvar{mp}} ;
       anchor_par(\MPanchor\MPbself) ;
     \stopMPpositiongraphic}%
  \MPpositiongraphic{mpos:par}{}%
\stopMPpositionmethod

%D The next alternative works in columnsets :

%  \iftracepositions show\else draw\fi_multi_pars ;

\startuseMPgraphic{mpos:par:columnset}
  \iftracepositions show_multi_pars \else draw_multi_pars \fi ;
\stopuseMPgraphic

\startuseMPgraphic{mpos:par:sideline}{linecolor,lineoffset,linewidth}
    begingroup ; save p ; picture p ;
    for i=1 upto nofmultipars :
        p := image ( fill leftboundary multipars[i]
            shifted (-\MPvar{lineoffset},0)
            rightenlarged \MPvar{linewidth} withcolor \MPvar{linecolor} ;
        ) ;
        setbounds p to multipars[i] ;
        draw p ;
    endfor ;
    endgroup ;
\stopuseMPgraphic

\startMPpositionmethod{mpos:par:columnset}
  \edef\MPparcounter{\MPv\MPbself{1}{0}}%
  \startMPpositiongraphic{mpos:par}{fillcolor,filloffset,linecolor,gridcolor,linewidth,gridwidth,gridshift,lineradius}
    \includeMPgraphic{mpos:par:setup} ;
    \includeMPgraphic{mpos:par:extra} ;
    prepare_multi_pars(\MPpos\MPbself,\MPpos\MPeself,\MPpos\MPwself,
      \MPpos\MPparanchor,\MPvv\MPparanchor{0pt,0pt,0pt,0pt,0,0pt}) ;
    relocate_multipars(-\MPxy\MPanchorid) ; % inside layerpos
    \includeMPgraphic{\MPvar{mp}} ;
  \stopMPpositiongraphic
  \MPpositiongraphic{mpos:par}{}%
\stopMPpositionmethod

%D \starttyping
%D \setupbackground
%D   [test]
%D   [mp=mpos:par:columnset,
%D    method=mpos:par:columnset]
%D \stoptyping

%D We need to treat floats in a special way.

\startMPinitializations
  local_multi_par_area:=\iflocalpositioning true\else false\fi;
\stopMPinitializations

\def\textbackgroundoverlay#1%
  {\iflocalpositioning\v!local\else\v!text\fi#1}

\newcount\localpositionnumber

\def\MPanchornumber
  {\iflocalpositioning\the\localpositionnumber\else\the\realpageno\fi}

%D So far for the trickery.

\newcount\textbackgrounddepth

\ifdefined\nofparbackgrounds\else \newcount\nofparbackgrounds \fi

\ifx\totalnofparbackgrounds\undefined \newcounter\totalnofparbackgrounds \fi

\appendtoks
    \expanded{\savecurrentvalue\noexpand\totalnofparbackgrounds{\number\nofparbackgrounds}}%
\to \everybye

% actually we can just ask lua to give us the nofpositions (or a least n<>0)

\appendtoks
    % a position can be mid paragraph in which case we're behind
    % this will change when we move positions to lua
    \initializeparbackgrounds
\to \everystarttext

\def\initializeparbackgrounds
  {\ifcase\totalnofparbackgrounds\else
     \enableparpositions
   \fi}

\unexpanded\def\starttextbackground
  {\bgroup
   \advance\textbackgrounddepth\plusone
   \dodoubleempty\dostarttextbackground}

\let\dodostarttextbackground\relax
\let\dodostoptextbackground \relax

\def\currentparbackground{pbg:0}
\def\nextparbackground   {pbg:1}

\def\btbanchor{b:\currentparbackground}
\def\etbanchor{e:\currentparbackground}

\def\nextbtbanchor{b:\nextparbackground}
\def\nextetbanchor{e:\nextparbackground}

\def\textbackgroundparameter#1%
  {\csname\??td\currenttextbackground#1\endcsname}

\let\backgroundvariable\textbackgroundparameter % will become obsolete

% \definetextbackground[more][state=start,backgroundcolor=red] % location=paragraph
% \definetextbackground[test][state=start,backgroundcolor=green]
%
% \page \placefigure[left]{}{}
%
% \starttextbackground[test]
%   \readfile{ward}{}{}
%   \starttextbackground[more]
%     \readfile{ward}{}{}
%   \stoptextbackground
%   \readfile{ward}{}{}
% \stoptextbackground
%
% \page \placefigure[right]{}{}
%
% \starttextbackground[test]
%   \readfile{ward}{}{}
%   \starttextbackground[more]
%     \readfile{ward}{}{}
%   \stoptextbackground
%   \readfile{ward}{}{}
% \stoptextbackground

\def\dostarttextbackground[#1][#2]%
  {\checktextbackgrounds
   \def\currenttextbackground{#1}%
   \global\advance\nofparbackgrounds\plusone
   \edef\currentparbackground{pbg:\number\nofparbackgrounds}%
   \xdef\nextparbackground{pbg:\number\numexpr\nofparbackgrounds+\plusone\relax}% still xdef ?
   % todo : \synchonizepositionpage{b:\currentparbackground}{s:\currentparbackground}%
   \setuptextbackground[#1][#2]%
   \let\dodostarttextbackground\relax
   \let\dodostoptextbackground \relax
   \doif{\textbackgroundparameter\c!state}\v!start{\dopresettextbackground{#1}}%
   \dodostarttextbackground}

% todo \backgroundvariable\c!variant

\def\dopresettextbackground#1% todo: \backgroundparameter
  {\normalexpanded{\noexpand\processaction[\textbackgroundparameter\c!location]}
     [   \v!text=>\let\dodostarttextbackground\dostarttextbackgroundtxt
                  \let\dodostoptextbackground \dostoptextbackgroundtxt,
    \v!paragraph=>\let\dodostarttextbackground\dostarttextbackgroundpar
                  \let\dodostoptextbackground \dostoptextbackgroundpar,
         \v!none=>\let\dodostarttextbackground\relax
                  \let\dodostoptextbackground \relax]%
   \ifx\dodostarttextbackground\dostarttextbackgroundpar % untested
     \ifnum\textbackgrounddepth>\plusone % new
       \let\dodostarttextbackground\dostarttextbackgroundtxt
       \let\dodostoptextbackground \dostoptextbackgroundtxt
     \fi
   \fi
   \doifelse{\textbackgroundparameter\c!frame}\v!on
     {\doifelse{\textbackgroundparameter\c!corner}\v!round
        {\setvalue{\??td#1\c!frame}{2}}
        {\setvalue{\??td#1\c!frame}{1}}}
     {\setvalue{\??td#1\c!frame}{0}}%
   \doifelse{\textbackgroundparameter\c!background}\v!color
     {\setvalue{\??td#1\c!background}{1}}
     {\setvalue{\??td#1\c!background}{0}}%
  %\startpositionoverlay{\v!text\getvalue{\??td#1\c!level}}%
   \startpositionoverlay{\textbackgroundoverlay{\textbackgroundparameter\c!level}}%
     \expanded
       {\setMPpositiongraphicrange % moet veel efficienter
          {\btbanchor}% {b:\currentparbackground}%
          {\etbanchor}% {e:\currentparbackground}%
          {\textbackgroundparameter\c!method}%
          {self=\currentparbackground,
           mp=\textbackgroundparameter\c!mp,
           gridtype=\textbackgroundparameter\c!alternative,
           filltype=\textbackgroundparameter\c!background,
           linetype=\textbackgroundparameter\c!frame,
           dashtype=\textbackgroundparameter{dash}, %  to be internationalized
           gridcolor=\textbackgroundparameter\c!framecolor,
           linecolor=\textbackgroundparameter\c!framecolor,
           lineoffset=\textbackgroundparameter\c!frameoffset,
           fillcolor=\textbackgroundparameter\c!backgroundcolor,
           filloffset=\textbackgroundparameter\c!backgroundoffset,
           gridwidth=\textbackgroundparameter\c!rulethickness,
           gridshift=\textbackgroundparameter\c!voffset,
           linewidth=\textbackgroundparameter\c!rulethickness,
           lineradius=\textbackgroundparameter\c!radius}}%
   \stoppositionoverlay}

\unexpanded\def\stoptextbackground
  {\dodostoptextbackground
   \carryoverpar\egroup}

\unexpanded\def\starttextbackgroundmanual
  {\begingroup
   \dousestylehashparameter{\??td\currenttextbackground}\c!style
   \dousecolorhashparameter{\??td\currenttextbackground}\c!color
   \fpos\currentparbackground\ignorespaces}

\unexpanded\def\stoptextbackgroundmanual
  {\tpos\currentparbackground
   \endgroup}

\def\dostarttextbackgroundtxt
  {\ifvmode \dontleavehmode \fi
   \begingroup
   \dousestylehashparameter{\??td\currenttextbackground}\c!style
   \dousecolorhashparameter{\??td\currenttextbackground}\c!color
   \fpos\currentparbackground\ignorespaces}

\def\dostoptextbackgroundtxt
  {\tpos\currentparbackground
   \endgroup}

\newskip\textbackgroundskip

\def\dostarttextbackgroundpar
  {\endgraf % new
   \textbackgroundparameter\c!before
   \bgroup
\begingroup
\resetallattributes % \attribute\linenumberattribute \attributeunsetvalue
   \noindent
   \ifgridsnapping
     \doassignsomeskip\textbackgroundparameter\c!topoffset\to\textbackgroundskip
     \ifdim\textbackgroundskip>\zeropoint
       \struttedbox{\hbox{\raise\textbackgroundskip\hbox{\fpos\currentparbackground}}}%
     \else
      \fpos\currentparbackground
     \fi
   \else
     \fpos\currentparbackground
   \fi
   \endgraf % we need a vertical nobreak - 29/06/2004
\endgroup
   \nobreak \vskip-\lineheight \nobreak
   \ifgridsnapping \else
     \doassignsomeskip\textbackgroundparameter\c!topoffset\to\textbackgroundskip
     \ifdim\textbackgroundskip>\zeropoint
        \kern\textbackgroundskip\nobreak
     \fi
   \fi
   \dosetleftskipadaption{\textbackgroundparameter\c!leftoffset}%
   \advance\leftskip\leftskipadaption
   \dosetleftskipadaption{\textbackgroundparameter\c!rightoffset}%
   \advance\rightskip\leftskipadaption
   % new
   \dosetraggedcommand{\textbackgroundparameter\c!align}%
   \raggedcommand
   %
  %\begingroup
   \dousestylehashparameter{\??td\currenttextbackground}\c!style
   \dousecolorhashparameter{\??td\currenttextbackground}\c!color
   \nowhitespace
   \nobreak % new per 23/04/2006 (else potential break when whitespace)
   \seteffectivehsize
   \doinhibitblank %   \blank[\v!disable]% new
   \par}

\def\dostoptextbackgroundpar
  {\par
   \removelastskip % new
  %\endgroup
   \doassignsomeskip\textbackgroundparameter\c!bottomoffset\to\textbackgroundskip
   \ifdim\lastskip>\zeropoint
     \advance\textbackgroundskip-\lastskip
   \fi
   \ifgridsnapping \else \ifdim\textbackgroundskip>\zeropoint
     \kern\textbackgroundskip\nobreak
   \fi \fi
   \nobreak \vskip-\dimexpr\lineheight+\parskip\relax \nobreak
%    \nobreak \vskip-\lineheight \nobreak \nowhitespace % does not work
   \egroup
   \bgroup \forgeteverypar % NOT REALLY NEEDED, SAVES HASH/MEM
\resetallattributes % \attribute\linenumberattribute \attributeunsetvalue
   \nobreak \noindent \strut \hfill \kern\zeropoint
   \doassignsomeskip\textbackgroundparameter\c!bottomoffset\to\textbackgroundskip
   \ifgridsnapping % experimental, pascal (todo: topoffset in same way)
     \ifdim\textbackgroundskip>\zeropoint
       \struttedbox\plusone{\hbox{\lower\textbackgroundskip\hbox{\tpos\currentparbackground}}}%
     \else
       \tpos\currentparbackground
     \fi
   \else
     \tpos\currentparbackground
   \fi
\endgraf
   \egroup
   \endgraf % new
   \textbackgroundparameter\c!after}

\let\textparpages \!!zeropoint
\let\textparheight\!!zeropoint
\let\textparwidth \!!zeropoint

\def\calculatetextpardimensions
  {\docalculatetextpardimensions\btbanchor\etbanchor\MPparanchor}

\def\calculatenexttextpardimensions
  {\docalculatetextpardimensions\nextbtbanchor\nextetbanchor\relax}

\def\docalculatetextpardimensions#1#2#3% #1=\btbanchor #2=\etbanchor (adapted 8/6/2009)
  {\scratchcounter\numexpr\MPp#2-\MPp#1\relax
   \edef\textparpages
     {\the\scratchcounter}%
   \edef\textparheight
     {\the\dimexpr
        \ifcase\scratchcounter
          % one page
          \MPy#1-\MPy#2%
        \else
          % two or more pages
          \ifnum\scratchcounter>2
            \ifnum\scratchcounter<5
              % more pages
              \textheight*\numexpr\scratchcounter+\minusone
            \else
              % keep'm small
              5\textheight
            \fi
          \else
            \MPy#1-\MPy#2-\MPy\textanchor+\MPy\textanchor+\MPh\textanchor
          \fi
        \fi
      \relax}%
   \edef\textparwidth
     {\the\dimexpr
        \ifcase\scratchcounter
          % one page
          \MPx#2-\MPx#1%
        \else
          % two or more pages / maybe also hang
          \ifx#3\relax
            \makeupwidth % \textwidth
          \else
            \MPw\MPparanchor-\MPl\MPparanchor-\MPr\MPparanchor
          \fi
        \fi
      \relax}}

\def\mintextparheight{4\lineheight}

\def\dontsplitnexttextbackground % dangerous but useful
  {\ifdim\pagetotal>\textheight \else
     \ifdim\pagegoal=\maxdimen \else
      \calculatenexttextpardimensions
      % too tricky
      % \scratchdimen=\textparheight
      % \advance\scratchdimen\pagetotal\relax
      % \ifdim\scratchdimen>\pagegoal
      % \page
      % \fi
      \ifdim\textparheight>\zeropoint
        \ifdim\textparheight>\mintextparheight\else
          \page % option
        \fi
      \fi
    \fi
   \fi}

\unexpanded\def\definetextbackground
  {\dodoubleempty\dodefinetextbackground}

\def\dodefinetextbackground[#1][#2]% parent and ..parameter
  {\ifsecondargument % why ?
     \copyparameters[\??td#1][\??td]
       [\c!state,\c!location,\c!alternative,\c!mp,\c!method,
        \c!background,\c!backgroundcolor,\c!corner,\c!level,
        \c!backgroundoffset,\c!before,\c!after,\c!align,dash, % dash not yet internationalized
        \c!radius,\c!frame,\c!framecolor,\c!rulethickness,\c!voffset,\c!frameoffset,
        \c!leftoffset,\c!rightoffset,\c!topoffset,\c!bottomoffset]%
     \getparameters[\??td#1][#2]%
     \doifvalue{\??td#1\c!state}\v!start\checktextbackgrounds
     \setuvalue{#1}{\groupedcommand{\starttextbackground[#1]}{\stoptextbackground}}%
     \setuvalue{\e!start#1}{\starttextbackground[#1]}%
     \setuvalue{\e!stop #1}{\stoptextbackground}%
   \fi}

\unexpanded\def\setuptextbackground
  {\dodoubleargument\dosetuptextbackground}

\def\dosetuptextbackground[#1][#2]%
  {\ifsecondargument
     \doifelsenothing{#1}
       {\dodosetuptextbackground{#2}\empty}
       {\processcommalist[#1]{\dodosetuptextbackground{#2}}}%
   \else
     \dodosetuptextbackground{#1}\empty
   \fi}

\def\dodosetuptextbackground#1#2%
  {\getparameters[\??td#2][#1]%
   \def\currenttextbackground{#2}%
   \doifvalue{\??td#2\c!state}\v!start\checktextbackgrounds}

\let\currenttextbackground\empty

\def\checktextbackgrounds
  {\ifproductionrun
     \enabletextarearegistration
     \enablehiddenbackground
   \fi}

\setuptextbackground
  [\c!mp=mpos:par:columnset,      % buggy: mpos:par:shape
   \c!method=mpos:par:columnset, %
   \c!state=\v!start,
   \c!location=\v!text,
   \c!leftoffset=\!!zeropoint, % 1em,
   \c!rightoffset=\textbackgroundparameter\c!leftoffset,
   \c!topoffset=\!!zeropoint,  % \v!medium,
   \c!bottomoffset=\textbackgroundparameter\c!topoffset,
   \c!level=-1,
   \c!alternative=0,
   \c!align=,
   dash=0, % to be internationalized
   \c!background=\v!color,
   \c!backgroundcolor=lightgray,
   \c!backgroundoffset=\!!zeropoint,
   \c!corner=\v!rectangular,
   \c!radius=.5\bodyfontsize,
   \c!voffset=\!!zeropoint,
   \c!frame=\v!on,
   \c!framecolor=blue,
   \c!rulethickness=\linewidth]

%D As an example we define a grid background:

\definetextbackground
  [\v!grid]
  [\c!state=\v!stop,
   \c!location=\v!paragraph,
   \c!frame=\v!off,
   \c!framecolor=red,
   \c!background=,
   \c!alternative=1]

\ifx\basegrid\undefined \else \letvalue\v!grid=\basegrid \fi

\setupMPvariables
  [mpos:connect]
  [linecolor=red,
   linewidth=1pt]

\setupMPvariables
  [mpos:encircle]
  [fillcolor=lightgray,
   filloffset=\!!zeropoint,
   linecolor=blue,
   linewidth=1pt]

% these might become macros in mp-page

\startuseMPgraphic{mpos:common:ec}
  path pa ; pair ca ; numeric lw ;
  lw := \MPvar{linewidth} ;
  initialize_box(\MPpos{\MPvar{self}}) ;
  pa := pxy ; ca := cxy ; pa := boundingbox pa enlarged 2lw ;
  pa := llcorner pa ... lrcorner pa ... urcorner pa ... ulcorner pa ... cycle ;
  drawoptions (withpen pencircle scaled lw withcolor \MPvar{linecolor}) ;
\stopuseMPgraphic

\startMPpositiongraphic{mpos:encircle}{linecolor,fillcolor,linewidth}
  \includeMPgraphic{mpos:common:ec}
  fill pa withcolor \MPvar{fillcolor} ; draw pa ;
  anchor_box(\MPanchor{\MPvar{self}}) ;
\stopMPpositiongraphic

\startMPpositiongraphic{mpos:connect}{linecolor,linewidth}
  path pb, pc ; pair cb, cc ;
  \includeMPgraphic{mpos:common:ec}
  initialize_box(\MPpos{\MPvar{to}}) ;
  pb := pxy ; cb := cxy ; pb := boundingbox pb enlarged 2lw ;
  pb := llcorner pb...lrcorner pb...urcorner pb...ulcorner pb...cycle ;
  pc := ca {up} .. {down} cb ;
  cc := (pc intersection_point pa) ;
  if intersection_found :
    pc := pc cutbefore cc ;
    cc := (pc intersection_point pb) ;
    if intersection_found :
      pc := pc cutafter cc ;
      drawarrow pc ; drawarrow reverse pc ;
    fi ;
  fi ;
  anchor_box(\MPanchor{\MPvar{self}}) ;
\stopMPpositiongraphic

%D \macros
%D   {stackposdown, stackposup, stackposleft,stackposright}
%D
%D This is sort of obsolete as we have now stacking in the
%D margin in a different way.

\def\stackposdistance{.5em}

\newcount\currentautopos
\newcount\previousautopos

\def\POSstackprefix{stack:}

\unexpanded\def\dostackposbox#1#2%
  {\dowithnextbox
     {#2%
      \bgroup
      \previousautopos\currentautopos
      \global\advance\currentautopos\plusone
      \edef\currentposition {\POSstackprefix\number\currentautopos}%
      \edef\previousposition{\POSstackprefix\number\previousautopos}%
      \hpos\currentposition{\doifoverlappingelse\currentposition\previousposition{#1}{\flushnextbox}%
      \egroup}}%
     \hbox}

\unexpanded\def\stackposup   {\dostackposbox{\raise\lineheight\flushnextbox}}
\unexpanded\def\stackposdown {\dostackposbox{\lower\lineheight\flushnextbox}}
\unexpanded\def\stackposleft {\dostackposbox{\copy\nextbox\hskip\nextboxwd\hskip\stackposdistance}}
\unexpanded\def\stackposright{\dostackposbox{\hskip\stackposdistance\hskip\nextboxwd\flushnextbox}}

%D \macros
%D   {GFC, GTC, GSC}
%D
%D The next macros extend tables and tabulation with
%D backgrounds and position related features. Areas are
%D specified with symbolic names, and symbolic references to
%D the graphics involved. Each table has its own namespace.

\newconditional\tablehaspositions
\newcount\noftabpositions
\newtoks \posXCtoks

\def\dotablebpos{\bpos}
\def\dotableepos{\epos}

\def\tbPOSprefix
  {tbp:\number\noftabpositions:}

\def\tablepos
  {\normalexpanded{\global\posXCtoks\emptytoks\the\posXCtoks}}

\let\tabulatepos\tablepos

\def\dodododoGSC[#1:#2]%
  {\remappositionframed{#2}{\tbPOSprefix#1}%
   \dotablebpos{\tbPOSprefix#1}%
   \doglobal\appendtoks\@EA\dotableepos\@EA{\tbPOSprefix#1}\to\posXCtoks}

\def\dododoGSC[#1:#2:#3]%
  {\doglobal\appendtoks\dodododoGSC[#1:#2]\to\posXCtoks\NC}

\def\dodoGSC[#1]%
  {\def\docommand##1{\dododoGSC[##1:##1]}%
   \processcommalist[#1]\docommand}

\def\dodododoGFC[#1:#2:#3]%
  {\remappositionframed{#2}{\tbPOSprefix#1}%
   \dotablebpos{\tbPOSprefix#1}}

\def\dododoGFC[#1]%
  {\def\docommand##1{\dodododoGFC[##1:##1]}%
   \processcommalist[#1]\docommand}

\def\dodoGFC[#1]%
  {\doglobal\appendtoks\dododoGFC[#1]\to\posXCtoks\NC}

\def\dododododoGTC[#1:#2]%
  {\dotableepos{\tbPOSprefix#1}}

\def\dodododoGTC[#1]%
  {\def\docommand##1{\dododododoGTC[##1:##1]}%
   \processcommalist[#1]\docommand}

\def\dododoGTC[#1]%
  {\doglobal\appendtoks\dodododoGTC[#1]\to\posXCtoks}

\def\dodoGTC[#1]%
  {\doglobal\appendtoks\dododoGTC[#1]\to\posXCtoks\NC}

\def\dodododoXC[#1#2]%
  {\if#1>\dodoGFC  [#2:#2]\else
   \if#1+\dodoGFC  [#2:#2]\else
   \if#1<\dodoGTC  [#2:#2]\else
   \if#1-\dodoGTC  [#2:#2]\else
   \if#1=\dodoGSC  [#2:#2]\else
         \dodoGSC[#1#2:#1#2]\fi\fi\fi\fi\fi}

\def\dododoXC#1%
  {\dodododoXC[#1]}

\def\dodoXC[#1]%
  {{\let\NC\relax\processcommalist[#1]\dododoXC}}

\def\@@checktablepositionstate
  {\iftrialtypesetting
     \global\settrue\tablehaspositions
     \firstargumentfalse
   \fi}

\def\doGSC[#1]{\@@checktablepositionstate\iffirstargument\dodoGSC[#1]\else\expandafter\NC\fi}
\def\doGFC[#1]{\@@checktablepositionstate\iffirstargument\dodoGFC[#1]\else\expandafter\NC\fi}
\def\doGTC[#1]{\@@checktablepositionstate\iffirstargument\dodoGTC[#1]\else\expandafter\NC\fi}
\def\doXC [#1]{\@@checktablepositionstate\iffirstargument\dodoXC [#1]\else\expandafter\fi\NC}

\def\tbGSC{\dosingleempty\doGSC}
\def\tbGFC{\dosingleempty\doGFC}
\def\tbGTC{\dosingleempty\doGTC}
\def\tbXC {\dosingleempty\doXC }

%D The amount of code to support tables and tabulation is
%D rather minimalistic.

\let\tabulatepos\tablepos

\def\tabulatenormalpos
  {\iftrialtypesetting
     % nothing
   \else\ifconditional\tablehaspositions
     \hss\tabulatepos\hss
   \else
     % nothing
   \fi\fi}

\def\tabulateequalpos
  {\iftrialtypesetting
     \tabulateEQ
   \else\ifconditional\tablehaspositions
     \tabulateEQpos
   \else
     \tabulateEQ
   \fi\fi}

\def\tabulateEQpos
  {\setbox\scratchbox\hbox{\tabulateEQ}%
   \hbox to \wd\scratchbox{\hss\kern\zeropoint\tabulatepos\hss}%
   \hskip-\wd\scratchbox
   \box\scratchbox}

\appendtoks
    \global\advance\noftabpositions\plusone
    \global\setfalse\tablehaspositions
\to \everytabulate

% We need to handle paragraphs as well.

\let\doflushtabulateepos\relax

\def\dotabulatebpos
  {\bpos}

\def\dotabulateepos#1%
  {\ifvoid\tablebox\tabulatecolumn
     \epos{#1}%
     \glet\doflushtabulateepos\relax
   \else
     \gdef\doflushtabulateepos{\epos{#1}}%
   \fi}

\def\flushtabulatesplitbox
  {\box\tabulatebox
   \iftrialtypesetting\else\ifconditional\tablehaspositions\doflushtabulateepos\fi\fi}

\appendtoks
    \let\dotablebpos\dotabulatebpos
    \let\dotableepos\dotabulateepos
    \glet\doflushtabulateepos\relax
\to \everytabulate

%D In order to prevent potential clashes with abbreviations,
%D postpone the mapping.

\appendtoks
    \let\GSC\tbGSC
    \let\GFC\tbGFC
    \let\GTC\tbGTC
    \let\XC \tbXC
\to \everytabulate

%D \macros
%D   {definepositionframed}
%D
%D The next example show how to provide backgrounds to table
%D cells. First we define some framed backgrounds.
%D
%D \startbuffer
%D \definepositionframed[x][background=color,backgroundcolor=red]
%D \definepositionframed[y][background=color,backgroundcolor=green]
%D \definepositionframed[z][background=color,backgroundcolor=blue]
%D \stopbuffer
%D
%D \typebuffer
%D
%D % \getbuffer
%D
%D \startbuffer
%D \starttabulate[|c|c|c|]
%D \GFC[f:x] this is a small  \NC       table            \NC     in which we \NC \FR
%D \NC       will demonstrate \GFC[g:z] that this        \GTC[g] positioning \NC \MR
%D \GSC[e:y] mechanism also   \GTC[f]   works quite well \NC     in tables   \NC \LR
%D \stoptabulate
%D \stopbuffer
%D
%D The table itself defines three areas (a, b and~c) using
%D these frames.
%D
%D \typebuffer
%D % \getbuffer
%D
%D Tables (based on \TABLE) are supported by:

\def\normalTABLEsimplebar {\unskip\!ttRightGlue&\tablepos&}                       % |
\def\normalTABLEcomplexbar{\unskip\!ttRightGlue&\omit\tablepos\!ttAlternateVrule} % \|
\def\normalTABLEquote     {\unskip\!ttRightGlue&\omit\tablepos&}                  % "

\appendtoks
    \global\advance\noftabpositions\plusone
    \global\setfalse\tablehaspositions
\to \everytable

%D Since we don't want nameclashes:

\appendtoks
    \let\GSC\tbGSC
    \let\GFC\tbGFC
    \let\GTC\tbGTC
    \let\XC \tbXC
\to \everytable

%D In the previous example, we could have provided an overlay to
%D the framed definition. A more direct approach is demonstrated
%D below:
%D
%D \startbuffer
%D \def\cw#1{\color[white]{#1}}
%D
%D \startMPpositiongraphic{tableshade}
%D   initialize_area(\MPpos{\MPvar{from}},\MPpos{\MPvar{to}}) ;
%D   color c ; c := \MPvar{color} ;
%D   linear_shade(pxy,0,.4c,.9c) ;
%D   anchor_area(\MPanchor{\MPvar{from}}) ;
%D \stopMPpositiongraphic
%D
%D \setMPpositiongraphic{b:x}{tableshade}{from=b:x,to=e:x,color=red}
%D \setMPpositiongraphic{b:y}{tableshade}{from=b:y,to=e:y,color=green}
%D \setMPpositiongraphic{b:z}{tableshade}{from=b:z,to=e:z,color=blue}
%D \stopbuffer
%D
%D \typebuffer \getbuffer
%D
%D The definition of the table looks about the same as the
%D previous one:
%D
%D \startbuffer
%D \starttable[|c|c|c|]
%D \GFC[b:z] \cw{this is a small}  \NC       \cw{table}            \NC     in which we      \NC \FR
%D \NC       \cw{will demonstrate} \GFC[c:y] \cw{that this}        \GTC[c] \cw{positioning} \NC \MR
%D \GSC[a:x] \cw{mechanism also}   \GTC[b]   \cw{works quite well} \NC     in tables        \NC \LR
%D \stoptable
%D \stopbuffer
%D
%D \typebuffer
%D
%D \getbuffer

% \definepositionframed[w][background=color,backgroundcolor=yellow]
% \definepositionframed[x][background=color,backgroundcolor=red]
% \definepositionframed[y][background=color,backgroundcolor=green]
% \definepositionframed[z][background=color,backgroundcolor=blue]
%
% \starttabulate[|c|c|c|]
% \NC this is a small  \NC table            \NC in which we \NC \FR
% \NC will demonstrate \NC that this        \NC positioning \NC \MR
% \NC mechanism also   \NC works quite well \NC in tables   \NC \LR
% \stoptabulate
%
% \starttabulate[|c|c|c|]
% \GFC[f:x] this is a small      \GTC      table            \NC     in which we \NC \FR
% \NC       will demonstrate     \GFC[g:z] that this        \GTC[g] positioning \NC \MR
% \GSC[e:y] mechanism also       \GTC[f]   works quite well \NC     in tables   \NC \LR
% \stoptabulate
%
% \starttabulate[|c|c|c|]
% \GFC[f:x,d:w] this is a small  \GTC[d]   table            \NC     in which we \NC \FR
% \NC           will demonstrate \GFC[g:z] that this        \GTC[g] positioning \NC \MR
% \GSC[e:y]     mechanism also   \GTC[f]   works quite well \NC     in tables   \NC \LR
% \stoptabulate
%
% \starttabulate[|c|c|c|]
% \XC[+f:x] this is a small  \XC      table            \NC     in which we \NC \FR
% \NC      will demonstrate  \XC[+g:z] that this       \XC[-g] positioning \NC \MR
% \XC[=e:y] mechanism also   \XC[-f]  works quite well \NC     in tables   \NC \LR
% \stoptabulate
%
% \starttabulate[|c|c|c|]
% \XC[+f:x,+d:w] this is a small  \XC[-d]   table            \NC     in which we \NC \FR
% \NC            will demonstrate \XC[+g:z] that this        \XC[-g] positioning \NC \MR
% \XC[=e:y]       mechanism also  \XC[-f]   works quite well \NC     in tables   \NC \LR
% \stoptabulate

% evt                  [b:x]
%
% \definepositionframed[x][background=color,fillcolor=red]
% \definepositionframed[y][background=color,fillcolor=green]
% \definepositionframed[z][background=color,fillcolor=blue]

\def\remappositionframed#1#2% from to
  {\copyposition{b:#1}{b:#2}%
   \copyposition{e:#1}{e:#2}%
   \dosetpositionaction{b:#2}{\dopositionaction{b:#1}}}

\unexpanded\def\definepositionframed
  {\dodoubleargument\dodefinepositionframed}

\def\dodefinepositionframed[#1][#2]%
  {\dosetpositionaction{b:#1}{\dopositionframed[#1][#2]}}

\def\positionframed
  {\dodoubleempty\dopositionframed}

\def\dopositionframed[#1][#2]%
  {\bgroup
   \setbox\scratchbox\hbox
     {\dimen0=\MPx{e:#1}%
      \advance\dimen0 -\MPx{b:#1}%
      \dimen2=\MPy{b:#1}%
      \advance\dimen2 -\MPy{e:#1}%
      \advance\dimen2 \MPd{e:#1}%
      \lower\dimen2\hbox
        {\advance\dimen2 \MPh{b:#1}%
         \framed
           [\c!width=\dimen0,\c!height=\dimen2,
            \c!offset=\v!overlay,#2]{}}}%
   \smashedbox\scratchbox
   \egroup}

% \def\sethdistances#1%
%   {\hbox{\lpos{ml:#1}\hpos{mh:#1}{\strut}\rpos{mr:#1}}}
%
% \def\gethdistances#1%
%   {\scratchdimen\MPx{mh:#1}%
%    \advance\scratchdimen -\MPx{ml#1}%
%    \edef\lefthdistance{\the\scratchdimen}%
%    \scratchdimen\MPx{mr:#1}%
%    \advance\scratchdimen -\MPx{mh:#1}%
%    \edef\righthdistance{\the\scratchdimen}}

\protect \endinput

% todo 1: shift down option

% \startuseMPgraphic{mpos:par:columnset}
%   \iftracepositions show_multi_pars \else draw_multi_pars \fi ;
%   path p ; p := boundingbox currentpicture ;
%   currentpicture := currentpicture shifted (0,-StrutDepth/2) ;
%   setbounds currentpicture to p ;
% \stopuseMPgraphic

\definetextbackground[underline]    [location=text,alternative=1,background=,frame=off]
\definetextbackground[overstrike]   [location=text,alternative=2,background=,frame=off]
\definetextbackground[exlines]      [location=text,alternative=3,background=,frame=off]
\definetextbackground[strikethrough][location=text,alternative=4,background=,frame=off]

\definestartstop [underline]
  [before={\starttextbackground[underline]},
   after=\stoptextbackground]

\definestartstop
  [overstrike]
  [before={\starttextbackground[overstrike]},
   after=\stoptextbackground]

\definestartstop
  [exlines]
  [before={\starttextbackground[exlines]},
   after=\stoptextbackground]

\definestartstop
  [strikethrough]
  [before={\starttextbackground[strikethrough]},
   after=\stoptextbackground]

\definetextbackground
  [sideline]
  [mp=mpos:par:sideline,
   location=paragraph,
   framecolor=red,
   frameoffset=5mm]

\definestartstop [sideline]
  [before={\starttextbackground[sideline]},
   after=\stoptextbackground]

\starttext
    \startunderline     \input tufte \stopunderline      \blank
    \startoverstrike    \input tufte \stopoverstrike     \blank
    \startexlines       \input tufte \stopexlines        \blank
    \startstrikethrough \input tufte \stopstrikethrough  \blank
    \startsideline      \input tufte \stopsideline       \blank
\stoptext
