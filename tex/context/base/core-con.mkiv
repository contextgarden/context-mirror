%D \module
%D   [       file=core-con,
%D        version=1997.26.08,
%D          title=\CONTEXT\ Core Macros,
%D       subtitle=Conversion,
%D         author=Hans Hagen,
%D           date=\currentdate,
%D      copyright={PRAGMA ADE \& \CONTEXT\ Development Team}]
%C
%C This module is part of the \CONTEXT\ macro||package and is
%C therefore copyrighted by \PRAGMA. See mreadme.pdf for
%C details.

\writestatus{loading}{ConTeXt Core Macros / Conversion}

\registerctxluafile{core-con}{1.001}

\unprotect

\ifx\currentlanguage\undefined \let\currentlanguage\empty        \fi
\ifx\labeltext      \undefined \let\labeltext\firstofoneargument \fi

%D This module deals with all kind of conversions from numbers
%D and dates. I considered splitting this module in a support
%D one and a core one, but to keep things simple as well as
%D preserve the overview, I decided against splitting.

\let\spr\firstofoneargument % separator
\let\stp\firstofoneargument % stopper

% cleaner, some day:
%
% \def\isolateseparators % etex only, even works with list separator overloading
%   {\unexpanded\def\spr##1{{##1}}%
%    \unexpanded\def\stp##1{{##1}}}

% needed for arab :

\def\isolateseparators % even works with list separator overloading
  {\def\spr##1{{##1}}%
   \def\stp##1{{##1}}}

%D \macros
%D   {numbers}
%D
%D First we deal with the dummy conversion of numbers using the
%D \TEX\ primitive \type{\number}. The uppercase alternative is
%D only there for compatibility with the other conversion
%D macros. We could do without \type{#1} but this way we get
%D rid of unwanted braces. For the savety we also define a
%D non||sence uppercase alternative.
%D
%D \showsetup{numbers}
%D
%D \starttyping
%D \def\numbers#1{\number#1}
%D \def\Numbers#1{\number#1}
%D \stoptyping
%D
%D Due to read ahead, as in \type{[\pagenumber\space]} the space will
%D disappear, unless we use:

\def\numbers#1{\purenumber{#1}}
\def\Numbers#1{\purenumber{#1}}

%D \macros
%D   {romannumerals,Romannumerals}
%D
%D \TEX\ the program uses a rather tricky conversion from
%D numbers to their roman counterparts. This conversion could
%D of course be programmed in \TEX\ itself, but I guess Knuth
%D found the programming trick worth presenting.
%D
%D \showsetup{romannumerals}
%D \showsetup{Romannumerals}

\def\romannumerals#1{\ctxcommand{romannumerals(\number#1)}}
\def\Romannumerals#1{\ctxcommand{Romannumerals(\number#1)}}

%D Arabic  etc:

\def\abjadnumerals     #1{\ctxcommand{abjadnumerals     (\number#1)}}
\def\abjadnodotnumerals#1{\ctxcommand{abjadnodotnumerals(\number#1)}}
\def\abjadnaivenumerals#1{\ctxcommand{arabicnumerals    (\number#1)}}

\def\languagecharacters#1{\ctxcommand{alphabetic(\number#1,"\currentlanguage")}} % new
\def\languageCharacters#1{\ctxcommand{Alphabetic(\number#1,"\currentlanguage")}} % new

% we could use an auxiliary macro to save some bytes in the format
%
% \def\dolanguagecharacters#1#2{\ctxcommand{alphabetic(\number#2,"#1")}}

\def\thainumerals      #1{\ctxcommand{alphabetic(\number#1,"thai")}}
\def\devanagarinumerals#1{\ctxcommand{alphabetic(\number#1,"devanagari")}}
\def\gurmurkhinumerals #1{\ctxcommand{alphabetic(\number#1,"gurmurkhi")}}
\def\gujaratinumerals  #1{\ctxcommand{alphabetic(\number#1,"gujarati")}}
\def\tibetannumerals   #1{\ctxcommand{alphabetic(\number#1,"tibetan")}}
\def\greeknumerals     #1{\ctxcommand{alphabetic(\number#1,"greek")}}
\def\Greeknumerals     #1{\ctxcommand{Alphabetic(\number#1,"greek")}}
\def\arabicnumerals    #1{\ctxcommand{alphabetic(\number#1,"arabic")}}
\def\persiannumerals   #1{\ctxcommand{alphabetic(\number#1,"persian")}}

\let\arabicexnumerals     \persiannumerals

\def\koreannumerals    #1{\ctxcommand{alphabetic(\number#1,"korean")}}
\def\koreannumeralsp   #1{\ctxcommand{alphabetic(\number#1,"korean-parent")}}
\def\koreannumeralsc   #1{\ctxcommand{alphabetic(\number#1,"korean-circle")}}

\def\chinesenumerals   #1{\ctxcommand{chinesenumerals   (\number#1)}}
\def\chinesecapnumerals#1{\ctxcommand{chinesecapnumerals(\number#1,"cap")}}
\def\chineseallnumerals#1{\ctxcommand{chineseallnumerals(\number#1,"all")}}

%D \macros
%D   {character,Character}
%D
%D Converting a number into a character can of course only
%D be done with numbers less or equal to~26. At the cost of
%D much more macros a faster conversion is possible, using:
%D
%D \starttyping
%D \setvalue{char1}{a} \def\character#1{\getvalue{char#1}}
%D \stoptyping
%D
%D But we prefer a simpel \type{\case}.
%D
%D \showsetup{character}
%D \showsetup{Character}

\def\unknowncharacter{-} % else in lists \relax

\def\character#1{\ctxcommand{character(\number#1)}}
\def\Character#1{\ctxcommand{Character(\number#1)}}

%D \macros
%D   {characters,Characters}
%D
%D Converting large numbers is supported by the next two
%D macros. This time we just count on: $\cdots$~x, y, z, aa,
%D ab, ac~$\cdots$.
%D
%D \showsetup{characters}
%D \showsetup{Characters}

\def\characters#1{\ctxcommand{characters(\number#1)}}
\def\Characters#1{\ctxcommand{Characters(\number#1)}}

%D \macros
%D   {greeknumerals,Greeknumerals}
%D
%D Why should we only honour the romans, and not the greek?

% \let\greeknumerals\gobbleoneargument
% \let\Greeknumerals\gobbleoneargument

%D \macros
%D   {oldstylenumerals,oldstyleromannumerals}
%D
%D These conversions are dedicated to Frans Goddijn.

\unexpanded\def\oldstylenumerals#1%
  {{\os\number#1}}

\unexpanded\def\oldstyleromannumerals#1%
  {{\leftrulefalse\rightrulefalse\ss\txx\boxrulewidth.15ex
    \ruledhbox spread .15em{\hss\uppercased{\romannumerals{#1}}\hss}}}

%D \macros
%D   {protectconversion}
%D
%D The previous two commands are not robust enough to be
%D passed to \type{\write} en \type{\message}. That's why we
%D introduce:

\def\protectconversion
  {\def\doconvertcharacters##1{##1}} % was \relax
 %{\def\doconvertcharacters##1{\ifcase0##1 0\else##1\fi}} more save

%D \macros
%D   {normaltime,normalyear,normalmonth,normalday}
%D
%D The last part of this module is dedicated to converting
%D dates. Because we want to use as meaningful commands as
%D possible, and because \TEX\ already uses up some of those,
%D we save the original meanings.

\savenormalmeaning\time
\savenormalmeaning\year
\savenormalmeaning\month
\savenormalmeaning\day

%D \macros
%D   {month,MONTH}
%D
%D Converting the month number into a month name is done
%D using a case statement, abstact values and the label
%D mechanism. This way users can easily redefine a label from
%D for instance german into austrian.
%D
%D \starttyping
%D \setuplabeltext [de] [january=J\"anner]
%D \stoptyping
%D
%D Anyhow, the conversion looks like:

\def\doconvertmonthlong #1{\ctxcommand{month(#1)}}
\def\doconvertmonthshort#1{\ctxcommand{monthmnem(#1)}}

\let\doconvertmonth\doconvertmonthlong

%D We redefine the \TEX\ primitive \type{\month} as:
%D
%D \showsetup{month}
%D \showsetup{MONTH}

\def\monthlong {\doconvertmonthlong}
\def\monthshort{\doconvertmonthshort}
\def\month     {\doconvertmonth}

\def\MONTH     #1{{\WORD{\month     {#1}}}}
\def\MONTHLONG #1{{\WORD{\monthlong {#1}}}}
\def\MONTHSHORT#1{{\WORD{\monthshort{#1}}}}

%D We never explicitly needed this, but Tobias Burnus pointed
%D out that it would be handy to convert to the day of the
%D week. In doing so, we have to calculate the total number of
%D days, taking leapyears into account. For those who are
%D curious:
%D
%D \startitemize[packed]
%D \item  years that can be divided by 4 are leapyears
%D \item  exept years that can be divided by 100
%D \item  unless years can be divided by 400
%D \stopitemize
%D
%D This makes the year 1900 into a normal year and 1996 and
%D 2000 into leap years, right? Well, converting to string
%D looks familiar:

\def\doconvertday#1{\ctxcommand{day(#1)}}

%D \macros
%D   {getdayoftheweek, dayoftheweek}

\newcount\normalweekday

% \def\getdayoftheweek#1#2#3{\normalweekday\ctxcommand{weekday(\number#1,\number#2,\number#3)}}
% \def\dayoftheweek   #1#2#3{\doconvertday{\ctxcommand{weekday(\number#1,\number#2,\number#3)}}}

\def\getdayoftheweek#1#2#3{\normalweekday\ctxcommand{weekday(\number#1,\number#2,\number#3)}\relax} % number
\def\dayoftheweek   #1#2#3{\ctxcommand{weekdayname(\number#1,\number#2,\number#3)}}                 % name

%D Using this macro in
%D
%D \startbuffer
%D monday:   \dayoftheweek  {4} {5} {1992}
%D friday:   \dayoftheweek {16} {6} {1995}
%D monday:   \dayoftheweek {25} {8} {1997}
%D saturday: \dayoftheweek {30} {8} {1997}
%D tuesday:  \dayoftheweek  {2} {1} {1996}
%D tuesday:  \dayoftheweek  {7} {1} {1997}
%D tuesday:  \dayoftheweek {13} {1} {1998}
%D friday:   \dayoftheweek  {1} {1} {2000}
%D \stopbuffer
%D
%D \typebuffer
%D
%D gives
%D
%D \startvoorbeeld
%D \startlines
%D \getbuffer
%D \stoplines
%D \stopvoorbeeld
%D
%D The macro \type {\getdayoftheweek} can be used to calculate
%D the number \type {\normalweekday}.

%D \macros
%D   {weekday,WEEKDAY}
%D
%D The first one is sort of redundant. It takes the day
%D number argument.
%D
%D \showsetup{weekday}
%D \showsetup{WEEKDAY}

\def\weekday
  {\doconvertday}

\def\WEEKDAY#1%
  {{\WORD{\doconvertday{#1}}}}

%D \macros
%D   {weekoftheday}
%D
%D {\em not yet implemented:}
%D
%D \starttyping
%D \def\weekoftheday#1#2#3%
%D  {}
%D \stoptyping

%D \macros
%D   {doifleapyearelse,
%D    getdayspermonth}
%D
%D Sometimes we need to know if we're dealing with a
%D leapyear, so here is a testmacro:
%D
%D \starttyping
%D \doifleapyearelse{year}{yes}{no}
%D \stoptyping
%D
%D An example of its use can be seen in the macro
%D
%D \starttyping
%D \getdayspermonth{year}{month}
%D \stoptyping
%D
%D The number of days is available in the macro \type
%D {\numberofdays}.

\def\doifleapyearelse#1%
  {\ctxcommand{doifleapyearelse(\number#1)}}

\def\getdayspermonth#1#2%
  {\edef\numberofdays{\ctxcommand{nofdays(\number#1,\number#2)}}}

\def\dayspermonth#1#2%
  {\ctxcommand{nofdays(\number#1,\number#2)}}

% \dayoftheweek{2006}{9}{15}
% \doifleapyearelse{2000}{OK}{NOT OK}
% \doifleapyearelse{2100}{NOT OK}{OK}
% \doifleapyearelse{2004}{OK}{NOT OK}
% \doifleapyearelse{2003}{NOT OK}{OK}
% \dayspermonth{2000}{2}
% [\the\normaltime=\the\time]

%D \macros
%D   {currentdate, date}
%D
%D We use these conversion macros in the date formatting
%D macro:
%D
%D \showsetup{currentdate}
%D
%D This macro takes care of proper spacing and delivers for
%D instance:
%D
%D \startbuffer
%D \currentdate[weekday,day,month,year] % still dutch example
%D \currentdate[WEEKDAY,day,MONTH,year] % still dutch example
%D \stopbuffer
%D
%D \startvoorbeeld
%D \startlines
%D \getbuffer
%D \stoplines
%D \stopvoorbeeld
%D
%D depending of course on the keywords. Here we gave:
%D
%D \typebuffer
%D
%D If needed one can also add non||keywords, like in
%D
%D \startbuffer
%D \currentdate[dd,--,mm,--,yy]
%D \stopbuffer
%D
%D \typebuffer
%D
%D or typeset: \getbuffer.
%D
%D When no argument is passed, the current date is given as
%D specified per language (using \type{\installlanguage}).
%D
%D \showsetup{currentdate}
%D
%D \startbuffer
%D \date
%D \date[d=12,m=12,y=1998][weekday]
%D \date[d=12,m=12,y=1998]
%D \stopbuffer
%D
%D We can also typeset arbitrary dates, using the previous
%D command.
%D
%D \typebuffer
%D
%D The date is specified by one character keys. When no date
%D is given, we get the current date.
%D
%D \startlines
%D \getbuffer
%D \stoplines

% \newtoks \everycurrentdate
%
% \newsignal\datesignal
%
% \def\dobetweendates
%   {\ifdim\lastskip=\datesignal\relax\else
%      \unskip\space
%      \hskip\datesignal\relax
%    \fi}
%
% \def\referraldatepattern{j,mm,dd} % jj,mm,dd changed at januari 1-1-2000
%
% \def\dodobetweendates
%   {\let\betweendates\dobetweendates}%
%
% \def\dodocurrentdate#1%
%   {\processallactionsinset[#1]
%      [   \v!year=>\betweendates
%                   \convertnumber\v!year\normalyear,
%               yy=>\lasttwodigits\normalyear,
%                y=>\convertnumber\v!year\normalyear,
%                Y=>\number\normalyear,
%         \v!month=>\betweendates
%                   \month\normalmonth,
%               mm=>\twodigits\normalmonth,
%                m=>\month\normalmonth,
%                M=>\number\normalmonth,
%           \v!day=>\betweendates
%                   \convertnumber\v!day\normalday,
%          \v!day+=>\betweendates
%                   \convertnumber\v!day\normalday
%                   \ordinal\normalday,
%               dd=>\twodigits\normalday,
%              dd+=>\convertnumber\v!day{\twodigits\normalday}%
%                   \ordinal\normalday,
%                d=>\convertnumber\v!day\normalday,
%               d+=>\convertnumber\v!day\normalday
%                   \ordinal\normalday,
%                d=>\number\normalday,
%       \v!weekday=>\betweendates
%                   \convertnumber\v!day{\dayoftheweek\normalday\normalmonth\normalyear},
%                w=>\convertnumber\v!day{\dayoftheweek\normalday\normalmonth\normalyear},
%                W=>\dayoftheweek\normalday\normalmonth\normalyear,
%      \v!referral=>\docomplexcurrentdate\referraldatepattern,
%         \v!space=>\unskip\ \hskip\datesignal,
%               \ =>\unskip\ \hskip\datesignal,
%       \s!default=>,
%       \s!unknown=>\unskip\commalistelement
%                   \hskip\datesignal
%                   \let\betweendates\dodobetweendates]}
%
% \def\docurrentdate[#1]%
%   {\begingroup
%    \the\everycurrentdate
%    \let\betweendates\dodobetweendates
%    \doifsomething{#1}{\edef\currentdatespecification{#1}}%
%    \normalexpanded{\dodocurrentdate{\currentdatespecification}}%
%    \ifdim\lastskip=\datesignal\relax
%      \unskip
%    \fi
%    \endgroup}

%D \starttabulate[|l|l|]
%D \HL
%D \NC year     \NC (\currentdate[year])     \NC\NR
%D \NC yy       \NC (\currentdate[yy])       \NC\NR
%D \NC y        \NC (\currentdate[y])        \NC\NR
%D \NC Y        \NC (\currentdate[Y])        \NC\NR
%D \HL
%D \NC month    \NC (\currentdate[month])    \NC\NR
%D \NC mm       \NC (\currentdate[mm])       \NC\NR
%D \NC m        \NC (\currentdate[m])        \NC\NR
%D \NC M        \NC (\currentdate[M])        \NC\NR
%D \HL
%D \NC day      \NC (\currentdate[day])      \NC\NR
%D \NC dd       \NC (\currentdate[dd])       \NC\NR
%D \NC d        \NC (\currentdate[d])        \NC\NR
%D \NC D        \NC (\currentdate[D])        \NC\NR
%D \HL
%D \NC weekday  \NC (\currentdate[weekday])  \NC\NR
%D \NC w        \NC (\currentdate[w])        \NC\NR
%D \NC W        \NC (\currentdate[W])        \NC\NR
%D \HL
%D \NC referral \NC (\currentdate[referral]) \NC\NR
%D \HL
%D \NC day+     \NC (\currentdate[day+])     \NC\NR
%D \NC dd+      \NC (\currentdate[dd+])      \NC\NR
%D \NC d+       \NC (\currentdate[d+])       \NC\NR
%D \NC D+       \NC (\currentdate[D+])       \NC\NR
%D \HL
%D \stoptabulate
%D
%D \startbuffer
%D (\currentdate[D,.,M,.,Y])
%D (\currentdate[day,month,year])
%D (\currentdate[day,+,month,+,year])
%D \stopbuffer
%D
%D \typebuffer \getbuffer

\newtoks \everycurrentdate

\unexpanded\def\currentdate
  {\dosingleempty\docurrentdate}

\def\docurrentdate[#1]%
  {\begingroup
   \the\everycurrentdate
   \doifsomething{#1}{\edef\currentdatespecification{#1}}%
   \ctxcommand{currentdate(\!!bs\currentdatespecification\!!es,"\labellanguage")}%
   \endgroup}

\unexpanded\def\date
  {\dodoubleempty\dodate}

\def\dodate[#1][#2]%
  {\begingroup
   \iffirstargument
     \getparameters[\??da][d=\normalday,m=\normalmonth,y=\normalyear,#1]%
     \normalday  \@@dad\relax
     \normalmonth\@@dam\relax
     \normalyear \@@day\relax
   \fi
   \docurrentdate[#2]%
   \endgroup}

%D \macros
%D   {currenttime}
%D
%D The currenttime is actually the jobtime. You can specify
%D a pattern similar to the previous date macro using the
%D keys \type {h}, \type {m} and a separator.

\unexpanded\def\calculatecurrenttime
  {\edef\currenthour  {\ctxcommand{hour  ()}}%
   \edef\currentminute{\ctxcommand{minute()}}%
   \edef\currentsecond{\ctxcommand{second()}}}

\let\currenthour  \!!plusone
\let\currentminute\!!plusone

\def\currenttimespecification{h,:,m}

\def\complexcurrenttime[#1]%
  {\calculatecurrenttime
   \processallactionsinset[#1][h=>\currenthour,m=>\currentminute,\s!unknown=>\commalistelement]}

\def\simplecurrenttime
  {\expanded{\complexcurrenttime[\currenttimespecification]}}

\definecomplexorsimple\currenttime

%D Because we're dealing with dates, we also introduce a few
%D day loops:
%D
%D \starttyping
%D \processmonth{year}{month}{command}
%D \processyear{year}{command}{before}{after}
%D \stoptyping
%D
%D The counters \type {\normalyear}, \type {\normalmonth} and
%D \type{\normalday} can be used for for date manipulations.

\long\def\processmonth#1#2#3% year month command
  {\bgroup
   \getdayspermonth{#1}{#2}%
   \dostepwiserecurse1\numberofdays1%
     {\normalyear #1\relax
      \normalmonth#2\relax
      \normalday  \recurselevel\relax
      #3}%
   \egroup}

\def\lastmonth{12} % can be set to e.g. 1 when testing

\long\def\processyear#1#2#3#4% year command before after
  {\bgroup
   \dorecurse\lastmonth
     {\normalyear #1\relax
      \normalmonth\recurselevel\relax
      #3\processmonth\normalyear\normalmonth{#2}#4}%
   \egroup}

%D \macros
%D   {defineconversion, convertnumber}
%D
%D Conversion involves the macros that we implemented earlier
%D in this module.
%D
%D \showsetup{defineconversion}
%D \showsetup{convertnumber}
%D
%D We can feed this command with conversion macros as well as
%D a set of conversion symbols. Both need a bit different
%D treatment.
%D
%D \starttyping
%D \defineconversion [roman] [\romannumerals]
%D \defineconversion [set 1] [$\star$,$\bullet$,$\ast$]
%D \stoptyping
%D
%D You can define a language dependent conversion with:
%D
%D \starttyping
%D \defineconversion [en] [whatever] [\something]
%D \stoptyping

\unexpanded\def\defineconversion
  {\dotripleempty\dodefineconversion}

\def\dodefineconversion[#1][#2][#3]% from now on global (maybe local again some day)
  {\ifthirdargument
     \dododefineconversion{#1#2}{#1:#2}{#3}%
   \else
     \dododefineconversion{#1}{#1}{#2}%
   \fi}

\def\dododefineconversion#1#2#3%
  {\doifinstringelse{,}{\detokenize{#3}}
     {\ctxcommand{defineconversion("#2",\!!bs\detokenize{#3}\!!es)}%
      \setgvalue{\??cv#1}{\checkedconversion{#2}}}
     {\setgvalue{\??cv#1}{#3}}}

\def\checkedconversion#1#2%
  {\ctxcommand{checkedconversion("#1",#2)}}

%D If a conversion is just a font switch then we need to make sure
%D that the number is indeed end up as number in the input, so we
%D need to handle the second argument.

\def\convertnumber#1#2%
  {\csname
     \??cv=>% we want a fully expandable (no if interference)
     \ifcsname\??cv\currentlanguage#1\endcsname1\else
     \ifcsname\??cv                #1\endcsname2\else
                                               3\fi\fi
   \endcsname{#1}{\number#2}}

\setvalue{\??cv=>1}#1{\csname\??cv\currentlanguage#1\endcsname}
\setvalue{\??cv=>2}#1{\csname\??cv                #1\endcsname}
\letvalue{\??cv=>3}\checkedconversion

\def\doifconversiondefinedelse#1%
  {\ifcsname\??cv\currentlanguage#1\endcsname
     \@EA\firstoftwoarguments
   \else\ifcsname\??cv#1\endcsname
     \@EAEAEA\firstoftwoarguments
   \else
     \@EAEAEA\secondoftwoarguments
   \fi\fi}

\def\doifelseconversionnumber#1#2% slow but seldom used
  {\doifdefinedelse{\??cv#1#2}}

%D Handy.

\setvalue{\??cv:\c!n:\v!one  }{1}
\setvalue{\??cv:\c!n:\v!two  }{2}
\setvalue{\??cv:\c!n:\v!three}{3}
\setvalue{\??cv:\c!n:\v!four }{4}
\setvalue{\??cv:\c!n:\v!five }{5}

\def\wordtonumber#1#2{\ifcsname\??cv:\c!n:#1\endcsname\csname\??cv:\c!n:#1\endcsname\else#2\fi}

% \defineconversion[ctx][c,o,n,t,e,x,t]
%
% \doloop{\doifelseconversionnumber{ctx}{\recurselevel}{[\recurselevel]}{\exitloop}}

%D \macros
%D   {ordinaldaynumber, highordinalstr, ordinalstr}
%D
%D Efficient general ordinal number converters are sometimes
%D difficult to implement. Fortunately dates never exceed the
%D number~31.

\def\highordinalstr     #1{\high{\notsmallcapped{#1}}}
\def\ordinalstr         #1{\notsmallcapped{#1}}
\def\ordinaldaynumber   #1{\ctxcommand{ordinal(#1,"\currentlanguage"}}

%D As longs as symbols are linked to levels or numbers, we can
%D also use the conversion mechanism, but in for instance the
%D itemization macros, we prefer symbols because they can more
%D easier be (partially) redefined. Symbols are implemented
%D in another module.

\def\smallcappedromannumerals#1{\smallcapped{\romannumerals{#1}}}
\def\smallcappedcharacters   #1{\smallcapped{\characters   {#1}}}

\defineconversion []                     [\numbers] % the default conversion
\defineconversion [\v!empty]             [\gobbleoneargument]
\defineconversion [\v!none]              [\numbers]
\defineconversion [\s!default]           [\numbers]

\defineconversion [month]                [\doconvertmonthlong]
\defineconversion [month:mnem]           [\doconvertmonthshort]

\defineconversion [\v!character]         [\character]
\defineconversion [\v!Character]         [\Character]

\defineconversion [\v!characters]        [\characters]
\defineconversion [\v!Characters]        [\Characters]

\defineconversion [a]                    [\characters]
\defineconversion [A]                    [\Characters]
\defineconversion [AK]                   [\smallcappedcharacters]
\defineconversion [KA]                   [\smallcappedcharacters]

\defineconversion [\v!number]            [\numbers]
\defineconversion [\v!numbers]           [\numbers]
\defineconversion [\v!Numbers]           [\Numbers]
\defineconversion [\v!mediaeval]         [\mediaeval]

\defineconversion [n]                    [\numbers]
\defineconversion [N]                    [\Numbers]
\defineconversion [m]                    [\mediaeval]
\defineconversion [o]                    [\oldstylenumerals]
\defineconversion [O]                    [\oldstylenumerals]
\defineconversion [or]                   [\oldstyleromannumerals]

\defineconversion [\v!romannumerals]     [\romannumerals]
\defineconversion [\v!Romannumerals]     [\Romannumerals]

\defineconversion [i]                    [\romannumerals]
\defineconversion [I]                    [\Romannumerals]
\defineconversion [r]                    [\romannumerals]
\defineconversion [R]                    [\Romannumerals]

\defineconversion [KR]                   [\smallcappedromannumerals]
\defineconversion [RK]                   [\smallcappedromannumerals]

\defineconversion [\v!greek]             [\greeknumerals]
\defineconversion [\v!Greek]             [\Greeknumerals]

\defineconversion [g]                    [\greeknumerals]
\defineconversion [G]                    [\Greeknumerals]

\defineconversion [abjadnumerals]        [\abjadnumerals]
\defineconversion [abjadnodotnumerals]   [\adjadnodotnumerals]
\defineconversion [abjadnaivenumerals]   [\adjadnaivenumerals]

\defineconversion [thainumerals]         [\thainumerals]
\defineconversion [devanagarinumerals]   [\devanagarinumerals]
\defineconversion [gurmurkhinumerals]    [\gurmurkhinumerals]
\defineconversion [gujaratinumerals]     [\gujaratinumerals]
\defineconversion [tibetannumerals]      [\tibetannumerals]
\defineconversion [greeknumerals]        [\greeknumerals]
\defineconversion [Greeknumerals]        [\Greeknumerals]
\defineconversion [arabicnumerals]       [\arabicnumerals]
\defineconversion [persiannumerals]      [\persiannumerals]
\defineconversion [arabicexnumerals]     [\arabicexnumerals]


\defineconversion [koreannumerals]       [\koreannumerals]
\defineconversion [koreanparentnumerals] [\koreanparentnumerals]
\defineconversion [koreancirclenumerals] [\koreancirclenumerals]

\defineconversion [kr]                   [\koreannumerals]
\defineconversion [kr-p]                 [\koreanparentnumerals]
\defineconversion [kr-c]                 [\koreancirclenumerals]

\defineconversion [chinesenumerals]      [\chinesenumerals]
\defineconversion [chinesecapnumeralscn] [\chinesecapnumerals]
\defineconversion [chineseallnumeralscn] [\chineseallnumerals]

\defineconversion [cn]                   [\chinesenumerals]
\defineconversion [cn-c]                 [\chinesecapnumerals]
\defineconversion [cn-a]                 [\chineseallnumerals]

%D Symbol sets:

\ifx\symbol\undefined \def\symbol[#1]{#1} \fi % todo

\defineconversion
  [set 0]
  [{\symbol[bullet]},
   {\symbol[dash]},
   {\symbol[star]},
   {\symbol[triangle]},
   {\symbol[circle]},
   {\symbol[medcircle]},
   {\symbol[bigcircle]},
   {\symbol[square]}]

\defineconversion
  [set 1]
  [\mathematics{\star},
   \mathematics{\star\star},
   \mathematics{\star\star\star},
   \mathematics{\ddagger},
   \mathematics{\ddagger\ddagger},
   \mathematics{\ddagger\ddagger\ddagger},
   \mathematics{\ast},
   \mathematics{\ast\ast},
   \mathematics{\ast\ast\ast}]

\defineconversion
  [set 2]
  [\mathematics{*},
   \mathematics{\dag},
   \mathematics{\ddag},
   \mathematics{**},
   \mathematics{\dag\dag},
   \mathematics{\ddag\ddag},
   \mathematics{***},
   \mathematics{\dag\dag\dag},
   \mathematics{\ddag\ddag\ddag},
   \mathematics{****},
   \mathematics{\dag\dag\dag\dag},
   \mathematics{\ddag\ddag\ddag\ddag}]

\defineconversion
  [set 3]
  [\mathematics{\star},
   \mathematics{\star\star},
   \mathematics{\star\star\star},
   \mathematics{\ddagger},
   \mathematics{\ddagger\ddagger},
   \mathematics{\ddagger\ddagger\ddagger},
   \mathematics{\P},
   \mathematics{\P\P},
   \mathematics{\P\P\P},
   \mathematics{\S},
   \mathematics{\S\S},
   \mathematics{\S\S\S},
   \mathematics{\ast},
   \mathematics{\ast\ast},
   \mathematics{\ast\ast\ast}]

%D Iteration of suggestion by WS on mailinglist 2010.12.22:
%D
%D \starttyping
%D \setupfloatsplitting[conversion=continued]
%D \stoptyping

\unexpanded\def\continuednumber#1%
  {\labeltext{\ifcase#1\or\else\v!continued\fi}}

\defineconversion
  [\v!continued]
  [\continuednumber]

\protect \endinput
