%D \module
%D   [       file=core-spa,
%D        version=1997.03.31,
%D          title=\CONTEXT\ Core Macros,
%D       subtitle=Spacing,
%D         author=Hans Hagen,
%D           date=\currentdate,
%D      copyright={PRAGMA / Hans Hagen \& Ton Otten}]
%C
%C This module is part of the \CONTEXT\ macro||package and is
%C therefore copyrighted by \PRAGMA. See mreadme.pdf for
%C details.

\writestatus{loading}{ConTeXt Core Macros / Spacing}

% to be sorted out: dependencies, order of initialization / also some dutch code here
% more documentation in the mkii file

\unprotect

% some will move to core-var

\newif \ifgridsnapping
\newif \iffuzzyvskip
\let   \fuzzyvskip              \gobbleoneargument
\let   \removelastfuzzyvskip    \relax

\let   \startbaselinecorrection \relax
\let   \stopbaselinecorrection  \relax
\let   \baselinecorrection      \relax
\let   \offbaselinecorrection   \relax

\appendtoks \spacing\plusone           \to \everybodyfont
\appendtoks \presetnormallineheight    \to \everybodyfont
\appendtoks \setnormalbaselines        \to \everybodyfont % check if redundant
\appendtoks \setstrut                  \to \everybodyfont % check if redundant
\appendtoks \settopskip                \to \everybodyfont
\appendtoks \setmaxdepth               \to \everybodyfont
\appendtoks \simplesetupindenting      \to \everybodyfont
\appendtoks \simplesetupblank          \to \everybodyfont
\appendtoks \simplesetupwhitespace     \to \everybodyfont
%appendtoks \checknotes                \to \everybodyfont % not
\appendtoks \simplesetupspacing        \to \everybodyfont % nieuw
\appendtoks \setrelativeinterlinespace \to \everybodyfont

\appendtoks  \updateraggedskips        \to \everyfontswitch  % under test
\prependtoks \let\par\endgraf          \to \everypagebody % see \fillinline
\appendtoks  \simplesetupspacing       \to \everydefinedfont

% if you want to hyphenate the first word of a paragraph ... \appendtoks\hskip0pt\to\everypar

\def\stelfactorenin
  {\simplesetupwhitespace
   \simplesetupblank
   \settopskip
   \setmaxdepth}

\def\softbreak
  {\relax\ifhmode\hskip\parfillskip\break\fi}

\let\poplastnode\relax

\def\pushlastnode
  {\ifdim\lastskip=\zeropoint
     \ifnum\lastpenalty=\zerocount
       \ifnum\lastkern=\zerocount
         \let\poplastnode\relax
       \else
         \edef\poplastnode{\kern\the\lastkern\relax}\kern-\lastkern % untested
       \fi
     \else
       \edef\poplastnode{\penalty\the\lastpenalty\relax}\nobreak % untested
     \fi
   \else
     \edef\poplastnode{\vskip\the\lastskip\relax}\vskip-\lastskip % \removelastskip
   \fi}

%D The dreadful sequence \type {\bgroup} \unknown\
%D \type {\carryoverpar} \unknown\ \type {\egroup} is needed
%D when for instance sidefloats are used in combination with
%D something that starts with a group. This is because
%D otherwise the indentation as set (by the output routine)
%D inside the group are forgotten afterwards. (I must
%D not forget its existence).

\global\let\carriedoverpar\relax

\def\carryoverpar#1%
  {\normalexpanded     % \scratchtoks{#1}%
     {\noexpand#1% \the\scratchtoks
      \hangindent\the\hangindent
      \hangafter \the\hangafter
      \parskip   \the\parskip
      \leftskip  \the\leftskip
      \rightskip \the\rightskip}}

%D A quick way to determine left|/|middle|/|right states
%D (experimental).

\setvalue{\??as\v!left  }{0}
\setvalue{\??as\v!middle}{1}
\setvalue{\??as\v!right }{2}

\def\setalignmentswitch#1%
  {\chardef\alignmentswitch0\csname\??as#1\endcsname\relax}

%D There are two ways to influence the interline spacing. The
%D most general and often most consistent way is using
%D
%D \showsetup{setupinterlinespace}
%D
%D For instance
%D
%D \starttyping
%D \setupinterlinespace[line=2.8ex]
%D \stoptyping
%D
%D This setting adapts itself to the bodyfontsize, while for
%D instance saying
%D
%D \starttyping
%D \setupinterlinespace[line=12pt]
%D \stoptyping
%D
%D sets things fixed for all sizes, which is definitely not
%D what we want. Therefore one can also say:
%D
%D \starttyping
%D \definebodyfontenvironment[9pt][interlinespace=11pt]
%D \stoptyping
%D
%D One can still use \type{\setupinterlinespace} (without
%D arguments) to set the interline space according to the
%D current font, e.g. a \type{\bfa}.

\newif\iflocalinterlinespace

% font-ini

\ifx\bodyfontinterlinespecs\undefined

  \let\bodyfontinterlinespecs\empty
  \let\bodyfontinterlinespace\empty

\fi

\def\presetnormallineheight
  {\edef\normallineheight{\@@itline}%
%  done elsewhere : \spacing\!!plusone % new per 10/08/2004, else problems in otr / !! needed
   \iflocalinterlinespace \else
     \doifdefined\bodyfontinterlinespecs
       {\doifsomething\bodyfontinterlinespace
          {\edef\normallineheight{\bodyfontinterlinespace}}}%
   \fi}

\def\setupspecifiedinterlinespace[#1]%
  {\getparameters[\??it][#1]%
   \scratchdimen0\@@itheight\points
   \advance\scratchdimen 0\@@itdepth\points
   \ifdim\scratchdimen>\onepoint
     \showmessage\m!layouts{10}{\@@itheight,\@@itdepth}%
     \let\@@itheight\strutheightfactor
     \let\@@itdepth \strutdepthfactor
   \else
     \let\strutheightfactor\@@itheight
     \let\strutdepthfactor \@@itdepth
   \fi
   \let\minimumstrutheight \@@itminheight
   \let\minimumstrutdepth  \@@itmindepth
   \let\minimumlinedistance\@@itdistance
   \let\normallineheight   \@@itline % let ! ! ! ! ! ivm ex
   \doifelse\@@ittop\v!height % new, topskip does more bad than good
     {\let\topskipfactor   \@@itheight}
     {\let\topskipfactor   \@@ittop   }%
   \let\maxdepthfactor     \@@itbottom
   \let\baselinegluefactor \@@itstretch
   \setfontparameters % redundant, can be \setstrut, test first
   \updateraggedskips} % yes indeed

\let\currentrelativeinterlinespace\empty

\def\setuprelativeinterlinespace[#1]%
  {\processallactionsinset
     [#1]
     [      \v!on=>\oninterlineskip,
           \v!off=>\offinterlineskip,
         \v!reset=>\let\currentrelativeinterlinespace\empty
                   \let\setrelativeinterlinespace\relax
                   \setfontparameters,
          \v!auto=>\let\setrelativeinterlinespace\dosetrelativeinterlinespace,
       \s!unknown=>\assignvalue\commalistelement\currentrelativeinterlinespace{1.00}{1.25}{1.50}%
                   \spacing\currentrelativeinterlinespace]}

\def\dosetrelativeinterlinespace
  {\ifx\currentrelativeinterlinespace\empty\else
     \spacing\currentrelativeinterlinespace
   \fi}

\let\setrelativeinterlinespace\relax

% \appendtoks \setrelativeinterlinespace \to \everybodyfont

\def\complexsetupinterlinespace[#1]% \commalistelement ipv #1
  {\doifassignmentelse{#1}\setupspecifiedinterlinespace\setuprelativeinterlinespace[#1]}

\def\setuplocalinterlinespace[#1]%
  {\localinterlinespacetrue
   \setupinterlinespace[#1]%
   \localinterlinespacefalse}

\def\simplesetupinterlinespace
  {\localinterlinespacetrue
   \setfontparameters
   \updateraggedskips % funny one here
   \localinterlinespacefalse}

\definecomplexorsimple\setupinterlinespace

% In earlier versions \type{\bigskipamount} was
% \type{\ht\strutbox} and the stretch was plus or minus
% \type{.4\dp\strutbox}. Don't ask me why. The most recent
% implementation is based on a user supplied distance, which
% is by default \type{.75\normalskipamount} where
% \type{\normalskipamount} equals the current baseline
% distance.

% \lineskiplimit = -\maxdimen -> freezes baselineskip

% can be conditionals

\newif\ifblanknowhite       \blanknowhitefalse
\newif\ifblankindeed        \blankindeedfalse
\newif\ifblankreset         \blankresetfalse
\newif\ifblankdisable       \blankdisablefalse
\newif\ifblankflexible      \blankflexibletrue
\newif\ifblankouter
\newif\ifblankforce
\newif\ifblankgoback

\newskip\blankskip          \blankskip=\bigskipamount
\newskip\blankskipamount

\def\skipfactor    {.75}
\def\skipgluefactor{.25}

\def\normalskipamount
  {\openlineheight
     \ifgridsnapping \else \ifblankflexible
       \!!plus \skipgluefactor\openlineheight
       \!!minus\skipgluefactor\openlineheight
     \fi \fi
   \relax}

\def\linedistance    {\normalskipamount}
\def\appliedblankskip{\skipfactor\linedistance}
\def\lastblankskip   {\blankskip}
\def\currentblank    {\v!big}
\def\oldprevdepth    {\prevdepth}
\def\newprevdepth    {-1001pt}
\def\mindimen        {1sp} % was: 0.00002pt

\newif\iflocalblankfixed
\newif\iflocalblankflexible

\def\geenblanko{\removelastskip} % will become obsolete

%%%% pas op, wordt ook in core-pos gebruikt

\def\doassignsomeskip#1\to#2% ook nog \v!halfline+fuzzysnap
  {\doifelse{#1}\v!line
     {#2\openlineheight}
     {\ifgridsnapping
        \assigndimension{#1}{#2}{.25\openlineheight}{.5\openlineheight}\openlineheight
      \else
        \assigndimension{#1}{#2}\smallskipamount\medskipamount\bigskipamount
      \fi}%
   \relax}

% \relax is really needed, else we may loose stretch due to lookahead; somehow
% this bug was introduced a while ago but somehow went unnoticed; fixed 2/7/2008

\def\addblankskip#1#2#3{\global\advance\blankskip#1\ifgridsnapping#3\else#2\fi\relax}

\def\defineblankmethod[#1]#2{\setvalue{\??bo\??bo#1}{#2}}

\defineblankmethod        [\v!big] {\addblankskip+\bigskipamount      \openlineheight}
\defineblankmethod       [-\v!big] {\addblankskip-\bigskipamount      \openlineheight}
\defineblankmethod     [\v!medium] {\addblankskip+\medskipamount   {.5\openlineheight}}
\defineblankmethod    [-\v!medium] {\addblankskip-\medskipamount   {.5\openlineheight}}
\defineblankmethod      [\v!small] {\addblankskip+\smallskipamount{.25\openlineheight}}
\defineblankmethod     [-\v!small] {\addblankskip-\smallskipamount{.25\openlineheight}}
\defineblankmethod      [\v!white] {\addblankskip+\parskip            \openlineheight}
\defineblankmethod     [-\v!white] {\addblankskip-\parskip            \openlineheight}
\defineblankmethod       [\v!line] {\addblankskip+\openlineheight     \openlineheight}
\defineblankmethod      [-\v!line] {\addblankskip-\openlineheight     \openlineheight}

\defineblankmethod    [\v!formula] {\global\advance\blankskip\medskipamount}
\defineblankmethod    [\v!nowhite] {\global\blanknowhitetrue}
\defineblankmethod    [\v!disable] {\global\blankdisabletrue}
\defineblankmethod      [\v!force] {\global\blankforcetrue}
\defineblankmethod      [\v!outer] {\ifvmode\ifinner\blankoutertrue\fi\fi}
\defineblankmethod      [\v!reset] {\global\blankresettrue}
\defineblankmethod   [\v!flexible] {\global\localblankflexibletrue}
\defineblankmethod      [\v!fixed] {\global\localblankfixedtrue}
\defineblankmethod       [\v!back] {\global\blankgobacktrue} % {\geenblanko}
\defineblankmethod   [\v!halfline] {\ifgridsnapping\global\fuzzyvskiptrue\fi
                                    \global\advance\blankskip .5\lineheight}
\defineblankmethod       [\v!none] {\global\blankresettrue}
\defineblankmethod   [\v!joinedup] {\ifvmode\nointerlineskip\fi}
\defineblankmethod[\v!synchronize] {\verticalstrut\vskip-2\lineheight\verticalstrut}

% \vtop{\blank[synchronize]\blank[line]test}

\defineblankmethod    [\v!always] {\redowhitespace} % experimental

% happens often, so we speed this up:
%
% \defineblankmethod    [2*\v!line] {\addblankskip+{2\openlineheight}{2\openlineheight}}
% \defineblankmethod     [2*\v!big] {\addblankskip+{2\bigskipamount }{2\openlineheight}}
%
% no, with 2\whatever we loose the stretch and shrink! Taco's alternative:

\defineblankmethod
  [2*\v!line]
  {\addblankskip+\openlineheight\openlineheight
   \addblankskip+\openlineheight\openlineheight}

\defineblankmethod
  [2*\v!big]
  {\addblankskip+\bigskipamount\openlineheight
   \addblankskip+\bigskipamount\openlineheight}

\def\doblank#1%
  {\edefconvertedargument\ascii{#1}%
   \ifx\ascii\empty\else
     \ifcsname\??bo\??bo\ascii\endcsname % internal def
       \csname\??bo\??bo\ascii\endcsname
     \else\ifcsname\??bo\ascii\endcsname % user def / slow
       \@EA\rawprocesscommalist\@EA[\csname\??bo\ascii\endcsname]\doblank\relax
     \else
       \dorepeatwithcommand[#1]\redoblank
     \fi\fi
   \fi
   \relax}

\def\redoblank#1%
  {\edefconvertedargument\ascii{#1}%
   \ifx\ascii\empty\else
     \ifcsname\??bo\??bo\ascii\endcsname % internal def
       \csname\??bo\??bo\ascii\endcsname
     \else\ifcsname\??bo\ascii\endcsname % user def / slow
       \@EA\rawprocesscommalist\@EA[\csname\??bo\ascii\endcsname]\doblank\relax
     \else
       \global\advance\blankskip#1\relax
     \fi\fi
   \fi
   \relax}

\unexpanded\def\blank % the \relax is definitely needed due to the many \if's
  {\relax\complexorsimple\doblank}

\def\complexdoblank
  {\flushnotes
   \ifmmode
     \@EA\nocomplexdoblank
   \else
     \ifopelkaar
       \ifinpagebody
         \@EA\@EAEAEA\@EA\docomplexdoblank
       \else
         \@EA\@EAEAEA\@EA\nocomplexdoblank
       \fi
     \else
       \@EAEAEA\docomplexdoblank
     \fi
   \fi}

\def\nocomplexdoblank[#1]%
  {% evt blokkeerfalse
   \ifmmode\else\par\fi}

% Overloaded in cont-new!

\newsignal\noblanksignal

% problem: we cannot look back in the mvl so we need 3 kinds of signals

\def\noblankpsignal{1010101}

\def\inhibitgridblank % was doinhibitblank
  {\ifvmode\else\endgraf\fi
   \ifvmode
     \ifnum\lastpenalty<10000
       \kern-\noblanksignal % new
       \kern \noblanksignal
     \else
       \penalty\noblankpsignal
     \fi
   \fi}

\def\inhibittextblank % was inhibitblank
  {\endgraf
   \ifvmode
     \prevdepth\newprevdepth
   \fi}

% new macro
%
% \def\inhibitblank % need some work
%   {\endgraf
%    \ifvmode
%      \ifgridsnapping
%        \inhibitgridblank
%      \else
%        % this one spoils the grid
%        \inhibittextblank
%      \fi
%    \fi}

\def\doinhibitblank{\inhibitgridblank}
\def\inhibitblank  {\inhibittextblank}

% will become obsolete

\ifx\undefined\savedlastskip    \newskip \savedlastskip    \fi
\ifx\undefined\savedlastpenalty \newcount\savedlastpenalty \fi

% beware, prevdepth can have funny values (e.g. mvl value when in box)

\def\docomplexdoblank[#1]% pas op \relax's zijn nodig ivm volgende \if
  {\global\blankresetfalse
   \global\blankdisablefalse
   \global\blanknowhitefalse
   \global\localblankflexiblefalse
   \global\localblankfixedfalse
   \global\blankforcefalse
   \global\blankgobackfalse
   \blankouterfalse
   \global\blankskip\zeropoint
%
\edefconvertedargument\ascii{#1}% todo fast check for simple
\ifcsname\??bo\??bo\ascii\endcsname % internal def
  \csname\??bo\??bo\ascii\endcsname
\else\ifcsname\??bo\ascii\endcsname % user def / slow
  \@EA\rawprocesscommalist\@EA[\csname\??bo\ascii\endcsname]\doblank\relax
\else
  \rawprocesscommacommand[#1]\doblank
\fi\fi
%
   \relax % to be sure
   \ifdim\blankskip=\zeropoint\relax
     \iflocalblankflexible
       \doglobal\advance\blankskip \currentblank
     \else\iflocalblankfixed
       \doglobal\advance\blankskip \currentblank
     \fi\fi
   \fi
   \relax % to be sure
   \ifblankouter
     % do nothing
   \else
     \par
     \ifvmode
       \ifblankgoback
         \ifdim\lastskip>\zeropoint \vskip-\lastskip \fi
           \savedlastskip\zeropoint
         \else\ifdim\lastskip>\zeropoint
           \savedlastskip\lastskip
         \else % todo: lastnode, dan namelijk geen skip !
           \savedlastskip\zeropoint
       \fi\fi
       \ifblankforce
         % dit gaat mis in pos fonts
         % \ifdim\prevdepth>\zeropoint\else ...
         % -1000pt signals top of page or column (\ejectcolumn)
         \bgroup\forgeteverypar\verticalstrut\egroup\kern-\struttotal
         \savedlastskip\zeropoint
       \fi
       \savedlastpenalty\lastpenalty % hm, now it gets lost
       \ifblankdisable
         \global\blankindeedfalse % keep this, i.e. disable current too
         \ifgridsnapping
           \ifdim\prevdepth<\zeropoint
             % brrr
           \else
             % dirty trick: smaller blanks are ignored after a
             % larger one, so 10 lines is probably safe; we need
             % to make sure that we honor penalties; here comes the
             % trick (cross our fingers that this works well in
             % multi columns; maybe an ifinner test is needed
             %  \scratchcounter\lastpenalty
             %  \vskip-10\lineheight
             %  \ifnum\scratchcounter=\zerocount \else \penalty\lastpenalty \fi
             %  \vskip 10\lineheight
             % alas, this leads to overfull pages, so we try this:
             \inhibitgridblank
           \fi
         \else
           \ifdim\prevdepth<\zeropoint
             % brrr
           \else
             % ensure at least a proper prevdepth, this should be
             % an option
             \vskip-\prevdepth
             \vskip\strutdepth
             \prevdepth\strutdepth
           \fi
           % the old crappy piece of code
           \edef\oldprevdepth{\the\prevdepth}%
           \prevdepth\newprevdepth % == \inhibittextblank
         \fi
       \else
         \global\blankindeedtrue
       \fi
       \ifblankreset
         \global\blankindeedtrue
         \ifgridsnapping
            % let's play safe and not fool around with the depth, if
            % only because it took a lot of effort to sort out the grid
            % stuff in the first place
         \else
           \ifdim\prevdepth=\newprevdepth
             \prevdepth\oldprevdepth
           \fi
         \fi
       \fi
       \ifblankindeed
         \ifdim1\savedlastskip<1\blankskip\relax
           % else when \blank[2*groot] + \blank[3*groot] with parskip
           % equaling 1*groot, gives a groot=\parskip so adding a small
           % value makes it distinguishable; can also be done at parskip
           % setting time (better)
           \global\advance\blankskip \mindimen\relax % = skip
           % test this on 2* + 3* and parskip groot
           \ifblanknowhite
             \global\advance\blankskip -\parskip
           \else
             \ifdim\savedlastskip=\parskip
             \else  % force this due to previous comment
               \ifdim\parskip>\zeropoint\relax
                 \ifdim\blankskip<\parskip\relax
                   \global\blankskip\zeropoint
                 \else
                   \global\advance\blankskip -\parskip
                 \fi
               \fi
             \fi
           \fi
           \ifblankflexible \else
             \blankskip1\blankskip
           \fi
           \iflocalblankfixed
             \blankskip1\blankskip
           \fi
           \iflocalblankflexible
             \blankskip1\blankskip
               \!!plus \skipgluefactor\blankskip
               \!!minus\skipgluefactor\blankskip
           \fi
           \ifdim\lastkern=\noblanksignal\relax % controlled and grid
             \global\blankindeedfalse
           \else\ifnum\savedlastpenalty=\noblankpsignal\relax % controlled and grid
             \global\blankindeedfalse
           \else\ifgridsnapping\else\ifdim\prevdepth=\newprevdepth
             \global\blankindeedfalse
           \fi\fi\fi\fi
           \ifblankindeed
             \iffuzzyvskip
               \removelastfuzzyvskip
               \fuzzyvskip\blankskip\relax
             \else
               \relax\ifdim\savedlastskip=\zeropoint\else
                 \vskip-\savedlastskip
               \fi
               \vskip\blankskip\relax
             \fi
           \fi
         \else
           \iffuzzyvskip
             \removelastfuzzyvskip
             \fuzzyvskip\blankskip\relax
           \else
             % new, test this on pascal
             \ifdim\blankskip<\zeropoint
               \relax\ifdim\savedlastskip=\zeropoint\else
                 \advance\blankskip-\savedlastskip
                 \vskip-\savedlastskip
               \fi
               \ifdim\blankskip>\zeropoint
                 \vskip\blankskip
               \else
                 \vskip\zeropoint
               \fi
             \else
               % also new
               \ifdim\blankskip=\zeropoint
                 \ifblanknowhite
                   \nowhitespace
                 \fi
               \fi
             \fi
           \fi
         \fi
       \fi
     \fi
   \fi
   \global\fuzzyvskipfalse
   \presetindentation}

%D For a long time we had:
%D
%D \starttyping
%D \def\simpledoblank%
%D   {\doifelse{\currentwhitespace}{\v!geen}
%D      {\blank[\currentblank]}
%D      {\blank[\currentwhitespace]}}
%D \stoptyping
%D
%D But Berend de Boer wanted more control, so now we have:

\def\simpledoblank % ...
  {\doifelse\currentwhitespace\v!none
     {\blank[\currentblank]}
     {\blank[\s!default]}}

%D Another useful definition would be:
%D
%D \starttyping
%D \defineblank
%D   [\s!default]
%D   [\v!groot]
%D \stoptyping

\def\dosetupblank#1% amount are an plain inheritance
  {\bigskipamount#1\relax
   \ifblankflexible \else
     \bigskipamount1\bigskipamount
   \fi
   \medskipamount  \bigskipamount \divide\medskipamount  \plustwo
   \smallskipamount\bigskipamount \divide\smallskipamount\plusfour}%

\def\complexsetupblank[#1]% more \let's -> this also wil become installable
  {\ifgridsnapping
     \blankflexiblefalse
   \else
     \normalexpanded{\noexpand\processallactionsinset[#1]}
       [ \v!flexible=>\blankflexibletrue,
            \v!fixed=>\blankflexiblefalse]%
   \fi
   \normalexpanded{\noexpand\processallactionsinset[#1]}
     [ \v!flexible=>\dosetupblank\appliedblankskip,
          \v!fixed=>\dosetupblank\appliedblankskip,
           \v!line=>\edef\appliedblankskip{\linedistance}%
                    \dosetupblank\appliedblankskip,
       \v!halfline=>\scratchskip.5\linedistance
                    \edef\appliedblankskip{\the\scratchskip}%
                    \dosetupblank\appliedblankskip,
            \v!big=>\ifgridsnapping
                      \edef\appliedblankskip{\linedistance}%
                      \dosetupblank\appliedblankskip
                    \fi
                    \let\currentblank\v!big,
         \v!medium=>\let\currentblank\v!medium,
          \v!small=>\let\currentblank\v!small,
         \v!global=>\let\currentblank\v!global,
         \v!normal=>\dosetupblank\appliedblankskip,
       \v!standard=>\edef\appliedblankskip{\skipfactor\linedistance}%
                    \dosetupblank\appliedblankskip,
        \s!default=>\dosetupblank\appliedblankskip,
        \s!unknown=>\let\appliedblankskip\commalistelement
                    \dosetupblank\appliedblankskip]%
   \simplesetupwhitespace}

% \definecomplexorsimpleempty\setupblank
%
% speed gain: 60 sec -> 30 sec

\definecomplexorsimple\setupblank

\def\simplesetupblank % == snelle \setupblank[\s!default]
  {\ifgridsnapping
     \blankflexiblefalse
   \fi
   \dosetupblank\appliedblankskip
   % \let\deblanko\v!big
   \simplesetupwhitespace}

\def\restorestandardblank% \v!standard
  {\edef\appliedblankskip{\skipfactor\linedistance}%
   \dosetupblank\appliedblankskip
   }%\let\deblanko\v!big}

\def\dodefineblank[#1][#2]% why #1 commalist?
  {\def\docommand##1{\setvalue{\??bo##1}{#2}}%
   \processcommalist[#1]\docommand}

\def\defineblank
  {\dodoubleargument\dodefineblank}

% \def\savecurrentblank
%   {\edef\restorecurrentblank
%      {\bigskipamount\the\bigskipamount
%       \medskipamount\the\medskipamount
%       \smallskipamount\the\smallskipamount
%       \noexpand\def\noexpand\currentblank{\currentblank}%
%       \ifblankflexible
%         \noexpand\blankflexibletrue
%       \else
%         \noexpand\blankflexiblefalse
%       \fi}}

\def\savecurrentblank   {\edef\savedcurrentblank{\currentblank}}
\def\restorecurrentblank{\edef\currentblank{\savedcurrentblank}}

\def\savedcurrentblank{\currentblank}

%D Now.

\defineblank [\s!default] [\v!white]
\defineblank [\v!height]  [\strutheight]
\defineblank [\v!depth]   [\strutdepth]

\let\currentindentation\empty % amount/keyword
% \let\normalindentation \empty % used for reinstating normal indentation
\let\currentindenting  \empty % method

\newdimen\ctxparindent

\newif\ifindentfirstparagraph % \indentfirstparagraphtrue

\chardef\indentingtoggle\zerocount

%D After a blank or comparable situation (left side floats) we
%D need to check if the next paragraph has to be indented.

\def\presetindentation
  {\doifoutervmode{\ifindentfirstparagraph\else\noindentation\fi}}

%D This sets up the (normally) global indentation behavior as well
%D as the amounts.

\definecomplexorsimple\setupindenting

\indentfirstparagraphtrue
\parindent\ctxparindent
\chardef\indentingtoggle\zerocount

% we need a better everypar model: for each option a switch, which we
% set to false with \forgetall and can enable when needed (context 4);
% that way we can control the order of execution of options

\def\checkeverypar % currently a hack
  {\ifzeropt\parindent\else
     \doifsometokselse\everypar\donothing{\appendtoks\checkindentation\to\everypar}%
   \fi}

\def\complexsetupindenting[#1]%
  {\edef\currentindenting{#1}%
   \doifsomething\currentindenting % handy when a parameter is passed
     {% not here: \indentfirstparagraphtrue
      % not here: \parindent\ctxparindent
      % not here: \chardef\indentingtoggle\zerocount
      % we use commacommand in order to catch #1 being a command (expanded parameter)
      \processcommacommand[\currentindenting]\docomplexsetupindentingA % catch small, medium, etc
      \processcommacommand[\currentindenting]\docomplexsetupindentingB % catch rest
      \checkeverypar % only when non-empty #1
      \ifindentfirstparagraph\else\noindentation\fi % added
      \toggleindentation}}

\def\docomplexsetupindentingA#1%
  {\edefconvertedargument\!!stringa{#1}% can this be doen differently now?
   \ifcsname\??in:\!!stringa\endcsname \else
     \edef\currentindentation{#1}%
     \let\normalindentation\currentindentation
     \simplesetupindenting
   \fi}

\def\docomplexsetupindentingB#1%
  {\edefconvertedargument\!!stringa{#1}% catch #1=\somedimen
   \executeifdefined{\??in:\!!stringa}\donothing}

\def\simplesetupindenting % empty case, a it strange, needed this way?
  {\assigndimension\currentindentation\ctxparindent{1em}{1.5em}{2em}}

\def\indenting % kind of obsolete
  {\dosingleargument\complexsetupindenting}

% use \noindentation to suppress next indentation

\def\defineindentingmethod[#1]#2%
  {\setvalue{\??in:#1}{#2}}

\defineindentingmethod [\v!no]     {\parindent\zeropoint}% was: \ctxparindent\noindent}
\defineindentingmethod [\v!not]    {\parindent\zeropoint}% was: \ctxparindent\noindent}

\defineindentingmethod [\v!first]  {\indentfirstparagraphtrue}
\defineindentingmethod [\v!next]   {\indentfirstparagraphfalse}

\defineindentingmethod [\v!yes]    {\parindent\ctxparindent\relax} % no \indent !
\defineindentingmethod [\v!always] {\parindent\ctxparindent\relax} % no \indent !

\defineindentingmethod [\v!never]  {\parindent\zeropoint\relax     % no \indent !
                                    \chardef\indentingtoggle\zerocount}

\defineindentingmethod [\v!odd]    {\chardef\indentingtoggle\plusone}
\defineindentingmethod [\v!even]   {\chardef\indentingtoggle\plustwo}

\defineindentingmethod [\v!normal] {\ifx\normalindentation\empty\else
                                      \let\currentindentation\normalindentation
                                      \simplesetupindenting
                                    \fi}

\defineindentingmethod [\v!reset]  {\indentfirstparagraphtrue
                                    \parindent\zeropoint
                                    \chardef\indentingtoggle\zerocount}

\def\noindenting{\indenting[\v!no, \v!next ]}
\def\doindenting{\indenting[\v!yes,\v!first]}

%D This one sets up the local indentation behaviour (i.e. either or not
%D a next paragraph will be indented).

\def\dochecknextindentation#1% internal one
  {\checknextindentation[\csname#1\c!indentnext\endcsname]}

\setvalue{\??in->\s!empty}{}
\setvalue{\??in->\v!yes  }{\doindentation}
\setvalue{\??in->\v!no   }{\noindentation}
\setvalue{\??in->\v!auto }{\autoindentation}

\def\checknextindentation[#1]%
  {\csname\??in->\ifcsname\??in->#1\endcsname#1\else\s!empty\fi\endcsname}

%D Here come the handlers.

\newif\ifindentation \indentationtrue  % documenteren, naar buiten

\let\checkindentation\relax

\ifx\autoindentation\undefined \let\autoindentation\relax \fi % hook

\def\doindentation
  {\gdef\checkindentation{\global\indentationtrue}}

\def\noindentation % made global
  {\ifinpagebody \else
     \global\indentationfalse
     \gdef\checkindentation
       {\donoindentation
        \gdef\checkindentation{\global\indentationtrue}}%
   \fi}

\def\nonoindentation % bv bij floats
  {\ifinpagebody \else
     \global\indentationtrue
     \gdef\checkindentation{\global\indentationtrue}%
   \fi}

\def\donoindentation
  {\ifdim\parindent=\zeropoint \else
     \bgroup \setbox\scratchbox\lastbox \egroup
   \fi}

\def\indentation
  {\ifvmode \ifdim\parindent=\zeropoint \else
     % was : \hskip\parindent
     % can be: \indent
     % but we test:
     \noindent\hskip\parindent
   \fi \fi}

\def\toggleindentation
  {\ifcase\indentingtoggle
     % nothing
   \or
     \notoggleindentation
   \or
     \dotoggleindentation
   \fi}

\def\dokillindentation
  {\gdef\checkindentation{\global\indentationfalse\donoindentation}}

\def\dotoggleindentation
  {\gdef\checkindentation{\global\indentationfalse\notoggleindentation\donoindentation}}

\def\notoggleindentation
  {\gdef\checkindentation{\global\indentationtrue\dotoggleindentation}}

\appendtoks
   \pushmacro\checkindentation
   \pushmacro\ifindentation
\to \everypushsomestate

\appendtoks
   \popmacro\ifindentation
   \popmacro\checkindentation
\to \everypopsomestate

% we need to save the state if we want to adapt behaviour to empty lines
%
% \def\setlasthvmode
%   {\global\chardef\savedhvmode\ifhmode\plusone\else\ifvmode\plustwo\else\zerocount\fi\fi}
%
% \def\resetlasthvmode
%   {\global\chardef\savedhvmode\zerocount}
%
% \chardef\savedhvmode\zerocount

% This is a user requested hack (using the auto-hook).

\chardef\recheckindentationmode\zerocount

\def\dontrechecknextindentation
  {\global\chardef\recheckindentationmode\zerocount}

\def\dorechecknextindentation
  {\ifcase\recheckindentationmode
     % nothing
   \or
     \dontrechecknextindentation
     \expandafter\doautoindentation
   \fi}

\def\doautoindentation
  {\doifnextcharelse\par\donothing\noindentation}

\def\autoindentation
  {\global\chardef\recheckindentationmode\plusone}

%D An example of usage:
%D
%D \starttyping
%D \setupindenting[small,yes]
%D
%D \setupitemize [indentnext=auto]
%D \setuptyping  [indentnext=auto]
%D \setupformulas[indentnext=auto]
%D
%D \input tufte \startitemize \item itemize \stopitemize
%D \input tufte \startitemize \item itemize \stopitemize
%D \input tufte \startitemize \item itemize \stopitemize
%D
%D \page
%D
%D \input tufte
%D \starttyping
%D verbatim
%D \stoptyping
%D
%D \input tufte
%D \starttyping
%D verbatim
%D \stoptyping
%D
%D \input tufte
%D \starttyping
%D verbatim
%D \stoptyping
%D
%D \page
%D
%D \input tufte \startformula a = b \stopformula
%D \input tufte \startformula a = b \stopformula
%D \input tufte \startformula a = b \stopformula
%D \stoptyping


%D \macros
%D   {frenchspacing,nonfrenchspacing}
%D
%D Smehow \type{\frenchspacing} can lead to hyphenation between
%D dashes so we now have \type {\newfrenchspacing} (moved from
%D \type {syst-chr}).

%D Hm ... todo:

\sfcode`\)=0
\sfcode`\'=0
\sfcode`\]=0

\def\setfrenchspacing#1%
  {\sfcode`\.#1 \sfcode`\,#1\relax
   \sfcode`\?#1 \sfcode`\!#1\relax
   \sfcode`\:#1 \sfcode`\;#1\relax}

\def\frenchspacing
  {\setfrenchspacing{1000}}

\def\resetfrenchspacing
  {\sfcode`\.3000 \sfcode`\,1250
   \sfcode`\?3000 \sfcode`\!3000
   \sfcode`\:2000 \sfcode`\;1500 }

\def\frenchspacing   {\setfrenchspacing{1000}}
\def\newfrenchspacing{\setfrenchspacing{1050}}
\def\nonfrenchspacing{\resetfrenchspacing}

\def\definespacingmethod[#1]#2{\setvalue{\??sg\??sg#1}{#2}}

\definespacingmethod[\v!packed]{\newfrenchspacing}
\definespacingmethod[\v!broad ]{\nonfrenchspacing}

\def\complexsetupspacing[#1]%
  {\executeifdefined{\??sg\??sg#1}\relax
   \updateraggedskips}

\def\simplesetupspacing
  {\updateraggedskips}

\definecomplexorsimple\setupspacing

% \dorecurse{100}{\recurselevel\spacefactor 800 \space} \par
% \dorecurse{100}{\recurselevel\spacefactor1200 \space} \par
% \dorecurse{100}{\recurselevel\spacefactor 800 \normalspaceprimitive} \par
% \dorecurse{100}{\recurselevel\spacefactor1200 \normalspaceprimitive} \par

% When we don't add the % here, we effectively get \<endlinechar> and
% since we have by default \def\^^M{\ } we get into a loop.

\let\normalspaceprimitive=\ % space-comment is really needed

% hm ...

\unexpanded\def\ {\mathortext\normalspaceprimitive\space} % no \dontleavehmode\space (else no frenchspacing)

% Because I strip spaces at the end of lines (in the editor) we need a bit of
% a trick to define slash+newline, so \<space> and \<newline> are the same

\ctxlua{tex.sprint(tex.ctxcatcodes,"\string\\unexpanded\string\\def\string\\\string\n{\string\\ }")}

\unexpanded\def\nonbreakablespace{\penalty\plustenthousand\mathortext\ \space} % no space in math

\letcatcodecommand \ctxcatcodes `\~ \nonbreakablespace % overloaded later

\def\space          { }
\def\removelastspace{\ifhmode\unskip\fi}
\def\nospace        {\removelastspace\ignorespaces}

% in tables we need:
%
% \def\fixedspace   {\hskip.5em\relax}
%
% but, since not all fonts have .5em digits:

\unexpanded\def\fixedspace
  {\setbox\scratchbox\normalhbox{\mathortext{0}{0}}%
   \hskip\wd\scratchbox\relax}

\def\fixedspaces
  {\letcatcodecommand \ctxcatcodes `\~ \fixedspace}

\appendtoks\let~\space\to\simplifiedcommands

% \def\removeunwantedspaces
%   {\ifhmode % we also need to unskip 0pt skips
%      \unskip\unskip\unskip\unskip\unskip
%      \unskip\unskip\unskip\unskip\unskip
%    \fi}

\unexpanded\def\removeunwantedspaces
  {\ifhmode
     \expandafter \doremoveunwantedspace
   \fi}

\def\doremoveunwantedspace
  {\ifnum\lastnodetype=\@@gluenode
     \unskip \expandafter\doremoveunwantedspace
   \fi}

% \startbuffer
% \startlines \tt \fixedspaces
%  0~1~~2~~~3~~~~4~~~~~5
%  0~~~~~~~~~~~~~~~~~~~5
% $0~1~~2~~~3~~~~4~~~~~5$
% $0~~~~~~~~~~~~~~~~~~~5$
% \stoplines
%
% \starttabulate[|~|]
% \NC  0~1~~2~~~3~~~~4~~~~~5  \NC \NR \NC  0~~~~~~~~~~~~~~~~~~~5  \NC \NR
% \NC $0~1~~2~~~3~~~~4~~~~~5$ \NC \NR \NC $0~~~~~~~~~~~~~~~~~~~5$ \NC \NR
% \stoptabulate
%
% \starttable[||]
% \NC  0~1~~2~~~3~~~~4~~~~~5  \NC \AR \NC  0~~~~~~~~~~~~~~~~~~~5  \NC \AR
% \NC $0~1~~2~~~3~~~~4~~~~~5$ \NC \AR \NC $0~~~~~~~~~~~~~~~~~~~5$ \NC \AR
% \stoptable
% \stopbuffer
%
% \setupbodyfont[cmr] \getbuffer
% \setupbodyfont[lbr] \getbuffer

\def\packed
  {\nointerlineskip}

\def\godown[#1]%
  {\relax
   \ifhmode\endgraf\fi
   \ifvmode\nointerlineskip\vskip#1\relax\fi}

%D A couple of plain macros:

\ifx\thinspace\undefined

    \def\thinspace   {\kern .16667em }
    \def\negthinspace{\kern-.16667em }
    \def\enspace     {\kern     .5em }

    \def\thinspace   {\kern .16667\emwidth}
    \def\negthinspace{\kern-.16667\emwidth}
    \def\enspace     {\kern     .5\emwidth}

\fi

\ifx\quad\undefined

    \def\enskip{\hskip.5em\relax}
    \def\quad  {\hskip 1em\relax}
    \def\qquad {\hskip 2em\relax}

    \def\enskip{\hskip.5\emwidth}
    \def\quad  {\hskip  \emwidth}
    \def\qquad {\hskip 2\emwidth}

\fi

\let\emspace\quad

\ifx\smallskip\undefined

  \def\smallskip{\vskip\smallskipamount}
  \def\medskip  {\vskip\medskipamount}
  \def\bigskip  {\vskip\bigskipamount}

\fi

\ifx\allowbreak\undefined

  \def\break     {\penalty\ifhmode-\plustenthousand\else\ejectpenalty\fi}
  \def\nobreak   {\penalty \plustenthousand}
  \def\allowbreak{\penalty \zeropoint}
  \def\filbreak  {\par\vfil\penalty-200\vfilneg}
  \def\goodbreak {\par\penalty-500 }

\fi

%D Made slightly more readable:

\ifx\vglue\undefined

  \def\vglue  {\afterassignment\dovglue\scratchskip=}
  \def\hglue  {\afterassignment\dohglue\scratchskip=}
  \def\topglue{\nointerlineskip\vglue-\topskip\vglue}

  \def\dovglue
    {\par
     \scratchdimen\prevdepth
     \hrule\!!height\zeropoint
     \nobreak\vskip\scratchskip
     \prevdepth\scratchdimen}

  \def\dohglue
    {\dontleavehmode % \leavevmode
     \scratchcounter\spacefactor
     \vrule\!!width\zeropoint
     \nobreak\hskip\scratchskip
     \spacefactor\scratchcounter}

\fi

\ifx\eject\undefined

  \def\eject{\par\break}

\fi

\ifx\supereject\undefined

  \def\supereject{\par\penalty\superpenalty}

\fi

\ifx\dosupereject\undefined

  \def\dosupereject
    {\ifnum\insertpenalties>\zerocount % something is being held over
       \line{}
       \kern-\topskip
       \nobreak
       \vfill\supereject
     \fi}

\fi

%D We adapt plain's \type {\removelastskip} a bit:

\ifx\removelastskip\undefined

  \def\removelastskip
    {\ifvmode \ifdim\lastskip=\zeropoint \else
       \vskip-\lastskip
     \fi \fi}

\fi

\ifx\smallbreak\undefined

\def\smallbreak
  {\par
   \ifdim\lastskip<\smallskipamount
     \removelastskip
     \penalty-50
     \smallskip
   \fi}

\def\medbreak
  {\par
   \ifdim\lastskip<\medskipamount
     \removelastskip
     \penalty-100
     \medskip
   \fi}

\def\bigbreak
  {\par
   \ifdim\lastskip<\bigskipamount
     \removelastskip
     \penalty-200
     \bigskip
   \fi}

\fi

\newskip\ctxparskip \ctxparskip\zeropoint

\newconditional \flexiblewhitespace \settrue\flexiblewhitespace

\def\blankokleinmaat   {\smallskipamount}
\def\blankomiddelmaat  {\medskipamount}
\def\blankogrootmaat   {\bigskipamount}
\def\currentwhitespace {\zeropoint}

\definecomplexorsimple\setupwhitespace

\def\simplesetupwhitespace
  {\doifnot\currentwhitespace\v!none\dosetupwhitespace}

\def\complexsetupwhitespace[#1]%
  {\edef\nextcurrentwhitespace{#1}%
   \ifx\nextcurrentwhitespace\empty
     \simplesetupwhitespace
   \else
     \let\currentwhitespace\nextcurrentwhitespace
     \dosetupwhitespace
   \fi}

\def\dosetupwhitespace % quick test for no list
  {\ifcsname\??ws\??ws\currentwhitespace\endcsname
     \csname\??ws\??ws\currentwhitespace\endcsname
   \else
     \expandafter\processcommalist\expandafter[\currentwhitespace]\dowhitespacemethod % can be raw
   \fi\relax
   \ifgridsnapping
     \setfalse\flexiblewhitespace
     \ifdim\ctxparskip>\zeropoint
       \ctxparskip
       \ifcase\baselinegridmode
         \baselineskip % normal ! ! ! ! !!
       \or
         \ifdim\scratchdimen=\baselineskip % maybe range
           \baselineskip % normal ! ! ! ! !!
         \else
           \numexpr\ctxparskip/\dimexpr.5\lineheight\relax\relax\dimexpr.5\lineheight\relax
         \fi
       \else
         \baselineskip % normal ! ! ! ! !!
       \fi
     \fi
   \else
     \ifconditional\flexiblewhitespace \else \ctxparskip1\ctxparskip \fi
   \fi
   \parskip\ctxparskip}

\chardef\baselinegridmode=0 % option in layout / 1=permit_half_lines

\def\dodosetupwhitespace
  {\ifgridsnapping
     \setfalse\flexiblewhitespace
     \ctxparskip1\ctxparskip
     \ifdim\ctxparskip>\zeropoint
       \ifcase\baselinegridmode
         \ctxparskip\baselineskip % normal ! ! ! ! !!
       \or
         \ifdim\scratchdimen=\baselineskip % maybe range
           \ctxparskip\baselineskip % normal ! ! ! ! !!
         \else
           \ctxparskip\numexpr\ctxparskip/\dimexpr.5\lineheight\relax\relax\dimexpr.5\lineheight\relax
         \fi
       \else
         \ctxparskip\baselineskip % normal ! ! ! ! !!
       \fi
     \fi
   \else
     \ifconditional\flexiblewhitespace \else \ctxparskip1\ctxparskip \fi
   \fi
   \parskip\ctxparskip}

\definesystemvariable {ws} % whitespace

\def\definewhitespacemethod[#1]#2{\setvalue{\??ws\??ws#1}{#2}}

\definewhitespacemethod [\v!fix]      {}
\definewhitespacemethod [\v!fixed]    {\setfalse\flexiblewhitespace}
\definewhitespacemethod [\v!flexible] {\settrue\flexiblewhitespace}
\definewhitespacemethod [\v!line]     {\ctxparskip  \baselineskip}
\definewhitespacemethod [\v!halfline] {\ctxparskip.5\baselineskip}
\definewhitespacemethod [\v!none]     {\ctxparskip  \zeropoint}
\definewhitespacemethod [\v!big]      {\ctxparskip  \bigskipamount}
\definewhitespacemethod [\v!medium]   {\ctxparskip  \medskipamount}
\definewhitespacemethod [\v!small]    {\ctxparskip  \smallskipamount}

\definewhitespacemethod [\s!default]  {\simplesetupwhitespace} % {\stelwitruimteopnieuwin}

% \def\dowhitespacemethod#1%
%   {\executeifdefined{\??ws\??ws#1}{\ctxparskip#1}\relax}

\def\dowhitespacemethod#1%
  {\ifcsname\??ws\??ws#1\endcsname\csname\??ws\??ws#1\endcsname\else\ctxparskip#1\fi\relax}

\def\nowhitespace
  {\ifdim\parskip>\zeropoint\relax
     \ifdim\lastskip=-\parskip
     \else
       \vskip-\parskip
     \fi
   \fi}

\def\nowhitespaceunlessskip
  {\ifdim\lastskip>\zeropoint \else
     \nowhitespace
   \fi}

\def\redowhitespace
  {\ifdim\lastskip>-\parskip \else
     \vskip\parskip
   \fi}

% \def\savecurrentwhitespace
%   {\edef\restorecurrentwhitespace
%      {\ctxparskip\the\ctxparskip
%       \parskip\the\parskip
%       \noexpand\def\noexpand\currentwhitespace{\currentwhitespace}%
%       \ifconditional\flexiblewhitespace
%         \noexpand\settrue\flexiblewhitespace
%       \else
%         \noexpand\setfalse\flexiblewhitespace
%       \fi}}

\def\savecurrentwhitespace   {\edef\savedcurrentwhitespace{\currentwhitespace}}
\def\restorecurrentwhitespace{\edef\currentwhitespace{\savedcurrentwhitespace}}

\def\savedcurrentwhitespace{\currentwhitespace}

% deze variant is nodig binnen \startopelkaar
% steeds testen:
%
% \hoofdstuk{..}
% \plaatslijst[..]
% \hoofdstuk{..}
% \input tufte
%
% met/zonder witruimte

\def\whitespace
  {\par
   \ifdim\parskip>\zeropoint\relax
    %\ifdim\lastskip>\parskip \else
     % \removelastskip interferes with blanko blokkeer en klein
       \vskip\parskip
    %\fi
   \fi}

\def\nonoblanko[#1]%
  {\par}

\def\noblanko
  {\dosingleempty\nonoblanko}

% I'm not sure if the restore is still needed. Anyway, when we do
% restore, we get a parskip someplace in the output that will push
% the content off page (\vbox to pageheight{skip smashed-box}) so
% we have now disabled this hack. If it is introduced again it needs
% to be more controlled. Test case:
%
% \setupwhitespace[big]
% \starttext
%     \startcolumns[n=2]\dorecurse{200}{test\crlf}\stopcolumns
% \stoptext
%
% \def\saveouterspacing
%   {\savecurrentblank
%    \savecurrentwhitespace
%    \def\restoreouterspacing
%      {\restorecurrentblank
%       \restorecurrentwhitespace}}
%
% \let\restoreouterspacing\relax
% \let\saveouterspacing   \relax % mult-ini: i will look into it when needed
%
% let's test this (restore before we restore the global bodyfont):

\def\saveouterspacing
  {\savecurrentblank
   \savecurrentwhitespace}

\def\restoreouterspacing
  {\restorecurrentblank
   \restorecurrentwhitespace}

% De onderstaande macro handelt ook de situatie dat er geen
% tekst tussen \start ... \stop is geplaatst. Daartoe wordt de
% laatste skip over de lege tekst heen gehaald. Dit komt goed
% van pas bij het plaatsen van (mogelijk lege) lijsten.

\newif\ifopelkaar

\newsignal \noparskipsignal % \def\noparskipsignal {0.00001pt}
\def\lastdoneparskip {0pt}

\def\startpacked
  {\dosingleempty\dostartpacked}

\def\dostartpacked[#1]% nesting afvangen
  {\par
   \ifvmode
     \edef\lastdoneparskip  {\the\lastskip}%
     \edef\lastdoneprevdepth{\the\prevdepth}% zeer recent toegevoegd
     \ifdim\prevdepth=-\thousandpoint % toegevoegd omdat binnen
     \else                            % een vbox een extra skip
       \whitespace                     % ongewenst is; dit kan
       \baselinecorrection %% zie in \placeregister[n=1]
       \vskip\noparskipsignal   % waarschijnlijk ook in
     \fi                        % blanko blokkeer
     \bgroup
     \doifelse{#1}\v!blank
       \opelkaarfalse
       \opelkaartrue
     \blank[\v!disable]       % dit is nog niet ok, gaat fout
     \setupwhitespace[\v!none]  % bovenin vtop (dwz, baseline)
  \fi}

\def\stoppacked
  {\par
   \ifvmode
     \egroup
     \ifdim\lastskip=\noparskipsignal\relax
       \removelastskip
       \nowhitespace
       \vskip-\lastdoneparskip
       \vskip+\lastdoneparskip
       \prevdepth-\lastdoneprevdepth % zeer recent toegevoegd
     \fi
  \fi}

\def\startunpacked
  {\blank
   \leavevmode
   \bgroup}

\def\stopunpacked
  {\egroup
   \blank}

% De onderstaande macro's moeten nog eens nader worden uitgewerkt.
% Ze spelen een rol bij de spatiering rond omkaderde teksten
% en/of boxen zonder diepte.

\def\toonregelcorrectie{\showbaselinecorrection}
\def\regelcorrectie    {\baselinecorrection}

% \prevdepth crosses pageboundaries!
%
% todo: a version that works ok inside a box

\let\doaroundlinecorrection\relax

\def\startlinecorrection
  {\dodoubleempty\dostartlinecorrection}

\def\dostartlinecorrection[#1][#2]% #2 gobbles spaces
  {\bgroup
   \processaction
     [#1]
     [  \v!blank=>\let\doaroundlinecorrection\blank,
      \s!default=>\let\doaroundlinecorrection\relax,
      \s!unknown=>{\def\doaroundlinecorrection{\blank[#1]}}]%
   \doaroundlinecorrection
   \startbaselinecorrection
   \offbaselinecorrection
   \ignorespaces}

\def\stoplinecorrection
  {\stopbaselinecorrection
   \doaroundlinecorrection
   \egroup}

\def\correctwhitespace
  {\dowithnextbox
     {\startbaselinecorrection
      \flushnextbox
      \stopbaselinecorrection}%
   \vbox}

\def\verticalstrut  {\normalvbox{\hsize\zeropoint\forgetall\strut}}
\def\horizontalstrut{\normalhbox                          {\strut}}

% Hieronder volgen enkele instellingen en macro's ten behoeve
% van de interlinie en \strut. De waarden 2.8, 0.07, 0.72 en
% 0.28 zijn ooit eens ontleend aan INRS-TEX en moeten wellicht
% nog eens instelbaar worden.
%
%   \lineheight        : de hoogte van een regel
%   \spacing{getal}    : instellen interlinie
%   \normalbaselines   : instellen regelafstend
%
%   \setstrut          : instellen \strut
%   \setnostrut        : resetten \strut, \endstrut, \begstrut
%
%   \setteststrut      : instellen zichtbare struts
%   \resetteststrut    : instellen onzichtbare struts
%
%   \setfontparameters : instellen na fontset
%
% De hoogte van een regel (\lineheight) is gelijk aan de
% som van de hoogte (\ht) en diepte (\dp) van \strutbox.
%
%   \strut            : denkbeeldig blokje met hoogte en diepte
%
% Een \hbox kan als deze aan het begin van een regel staat
% een breedte \hsize krijgen. Dit is soms te voorkomen met het
% commando \leavevmode. Binnen een \vbox geeft dit echter
% niet altijd het gewenste resultaat, vandaar het commando
%
%   \leaveoutervmode

% Pas op: niet zomaar \topskip en \baselineskip aanpassen
% en zeker niet \widowpenalty. Dit kan ernstige gevolgen
% hebben voor kolommen.
%
% Enige glue kan op zich geen kwaad, echter als blanko=vast,
% dan moet ook de rek 0 zijn. Binnen kolommen is rek ook
% niet bepaald mooi. Een hele kleine waarde (0.025) voldoet,
% omdat een positieve glue eindeloos rekbaar is.

\newdimen\strutdimen
\newdimen\lineheight
\newdimen\openlineheight
\newdimen\openstrutheight
\newdimen\openstrutdepth
\newdimen\topskipgap
\newdimen\struttotal

\def\strutheightfactor      {.72}
\def\strutdepthfactor       {.28}

\def\baselinefactor         {2.8}
\def\baselinegluefactor     {0}

\def\minimumstrutheight     {0pt}
\def\minimumstrutdepth      {0pt}

\def\normallineheight       {\baselinefactor ex}
\def\minimumlinedistance    {\lineskip}

\def\strutheight            {0pt}
\def\strutdepth             {0pt}
\def\strutwidth             {0pt}

\let\spacingfactor          \plusone

\def\topskipfactor          {1.0}
\def\maxdepthfactor         {0.5}

\def\systemtopskipfactor    {\topskipfactor}
\def\systemmaxdepthfactor   {\maxdepthfactor}

% De onderstaande definitie wordt in de font-module overruled

\ifdefined\globalbodyfontsize\else
  \newdimen\globalbodyfontsize
  \globalbodyfontsize=12pt
\fi

\ifx\normalizedbodyfontsize\undefined
  \def\normalizedbodyfontsize{12pt}
\fi

% door een \dimen. Dit is geen probleem omdat (1) de default
% korpsgrootte 12pt is en (2) de fonts nog niet geladen zijn
% en de instellingen bij het laden nogmaals plaatsvinden.

\def\topskipcorrection
  {\simpletopskipcorrection
   \vskip-\struttotal
   \verticalstrut}

\def\simpletopskipcorrection
  {\ifdim\topskip>\openstrutheight
     % == \vskip\topskipgap
     \vskip\topskip
     \vskip-\openstrutheight
   \fi}

\def\settopskip % the extra test is needed for the lbr family
  {\topskip\systemtopskipfactor\globalbodyfontsize
   \ifgridsnapping \else
     \ifr@ggedbottom\!!plus5\globalbodyfontsize\fi
   \fi
   \relax % the skip
   \topskipgap\topskip
   \advance\topskipgap -\openstrutheight\relax
\ifdim\minimumstrutheight>\zeropoint
   \ifdim\topskip<\minimumstrutheight
     \topskip\minimumstrutheight\relax
   \fi
\else
   \ifdim\topskip<\strutheightfactor\openlineheight
     \topskip\strutheightfactor\openlineheight\relax
   \fi
\fi}

\def\setmaxdepth
  {\maxdepth\systemmaxdepthfactor\globalbodyfontsize}

\def\normalbaselines
  {\baselineskip \normalbaselineskip
   \lineskip     \normallineskip
   \lineskiplimit\normallineskiplimit}

\def\setnormalbaselines
  {\ifdim\normallineheight>\zeropoint
     \lineheight\normallineheight
   \fi
   \openlineheight\spacingfactor\lineheight
   \openstrutheight \ifdim\minimumstrutheight>\zeropoint
     \minimumstrutheight % new
   \else
     \strutheightfactor\openlineheight
   \fi
   \openstrutdepth \ifdim\minimumstrutdepth>\zeropoint
     \minimumstrutdepth % new
   \else
     \strutdepthfactor \openlineheight
   \fi
   \ifdim\dimexpr\minimumstrutdepth+\minimumstrutheight\relax>\zeropoint
     \openlineheight\dimexpr\openstrutheight+\openstrutdepth\relax % new
   \fi
   \normalbaselineskip\openlineheight
     \ifgridsnapping\else
       \!!plus \baselinegluefactor\openlineheight
       \!!minus\baselinegluefactor\openlineheight
     \fi
   \normallineskip\minimumlinedistance\relax % \onepoint\relax
   \normallineskiplimit\zeropoint\relax
   \normalbaselines
   \dosetupgridsnapping}

\def\spacing#1%
  {\ifgridsnapping
    %\ifdim#1\points=\onepoint\else\showmessage\m!layouts{11}{\withoutpt\the\dimexpr#1\points\relax}\fi
     \let\spacingfactor\plusone
   \else
     \edef\spacingfactor{#1}%
   \fi
   \edef\systemtopskipfactor {\withoutpt\the\dimexpr#1\dimexpr\topskipfactor \points}%
   \edef\systemmaxdepthfactor{\withoutpt\the\dimexpr#1\dimexpr\maxdepthfactor\points}%
   \setnormalbaselines
   \setstrut}

%D Sometimes one needs to freeze the interlinespacing
%D
%D \starttyping
%D \rm \saveinterlinespace .... {\ss \restoreinterlinespace .... \endgraf}
%D \stoptyping

\let\restoreinterlinespace\relax

\def\saveinterlinespace
  {\edef\restoreinterlinespace
     {\lineheight         \the\lineheight
      \openstrutheight    \the\openstrutheight
      \openstrutdepth     \the\openstrutdepth
      \openlineheight     \the\openlineheight
      \normalbaselineskip \the\normalbaselineskip
      \normallineskip     \the\normallineskip
      \normallineskiplimit\the\normallineskiplimit
      \noexpand\def\noexpand\normallineheight{\the\dimexpr\normallineheight}%
      \noexpand\normalbaselines}}

% plain definition:
%
% \def\strut{\relax\ifmmode\copy\strutbox\else\unhcopy\strutbox\fi}
%
% could be:
%
% \def\strut{\relax\ifmmode\copy\else\unhcopy\fi\strutbox}

\ifx\strutbox\undefined

  \newbox\strutbox

  \setbox\strutbox\normalhbox{\vrule height8.5pt depth3.5pt width\zeropoint}

  \def\strut{\relax\ifmmode\copy\else\unhcopy\fi\strutbox}

\fi

\let\normalstrut\strut

% The double \hbox construction enables us to \backtrack
% boxes.

\let\strutht\undefined \newdimen\strutht
\let\strutdp\undefined \newdimen\strutdp

\unexpanded\def\setstrut
  {\ifgridsnapping
     \setstrutgridyes
   \else
     \setstrutgridnop
   \fi}

\unexpanded\def\setstrutgridyes
  {\strutht\spacingfactor\dimexpr
     \ifdim\minimumstrutheight>\zeropoint
       \minimumstrutheight
     \else
       \strutheightfactor\dimexpr\normallineheight
     \fi
   \strutdp\dimexpr
     \ifdim\minimumstrutdepth>\zeropoint
       \minimumstrutdepth
     \else
       \normallineheight-\strutht
     \fi
   \dosetstrut}

\unexpanded\def\setstrutgridnop
  {\strutht\spacingfactor\dimexpr
     \ifdim\minimumstrutheight>\zeropoint
       \minimumstrutheight
     \else
       \strutheightfactor\dimexpr\normallineheight
     \fi
   \strutdp\spacingfactor\dimexpr
       \ifdim\minimumstrutdepth>\zeropoint
         \minimumstrutdepth
       \else
         \strutdepthfactor\dimexpr\normallineheight
       \fi
   \dosetstrut}

\unexpanded\def\setcharstrut#1%
  {\setbox\strutbox\normalhbox{#1}%
   \strutht\ht\strutbox
   \strutdp\dp\strutbox
   \dosetstrut}

\unexpanded\def\setfontstrut
  {\setcharstrut{(gplQT}}

\unexpanded\def\setcapstrut% could be M, but Q has descender
  {\setcharstrut{Q}}

%D Handy for math (used in mathml):

\def\charhtstrut
  {\begingroup
   \setcharstrut{GJY}%
   \vrule\!!width\zeropoint\!!depth\zeropoint\!!height\strutht
   \endgroup}

\def\chardpstrut
  {\begingroup
   \setcharstrut{gjy}%
   \vrule\!!width\zeropoint\!!depth\strutdp\!!height\zeropoint
   \endgroup}

% because of all the callbacks in mkiv, we avoid unnecessary boxes ...
% maybe use an attribute so that we can tag boxes that don't need a
% treatment; tests with using an attribute so far have shown that
% it's slower because testing the attribute takes time too

\def\dosetstrut
  {\let\strut\normalstrut
   \edef\strutheight{\the\strutht}%
   \edef\strutdepth {\the\strutdp}%
   \ifdim\strutwidth=\zeropoint
      \dosetstruthide
   \else
      \dosetstrutvide
   \fi
   \struttotal\dimexpr\strutht+\strutdp\relax}

\def\dosetstruthide
  {\setbox\strutbox\normalhbox
     {\vrule
        \!!width \zeropoint
        \!!height\strutht
        \!!depth \strutdp}}

\def\dosetstrutvide
  {\setbox\strutbox\normalhbox
     {\normalhbox to \zeropoint
        {% \hss % new, will be option
         \vrule
           \!!width \strutwidth
           \!!height\strutht
           \!!depth \strutdp
         \hss}}}

%D The dimen \type {\struttotal} holds the exact size of the
%D strut; occasionally a one scaled point difference can show
%D up with the lineheight.

% experiment

\newbox\emptystrutbox \setbox\emptystrutbox\hbox{}

\def\dosetstruthide
  {\setbox\strutbox\copy\emptystrutbox
   \ht\strutbox\strutht
   \dp\strutbox\strutdp}

\def\strut{\relax\dontleavehmode\copy\strutbox} % still callbacks for \hbox{\strut}


\let\normalstrut\strut

%D Sometimes a capstrut comes in handy
%D
%D \starttabulate[|Tl|l|l|]
%D \NC yes          \NC normal strut               \NC {\showstruts\setupstrut[yes]\strut}  \NC \NR
%D \NC no           \NC no strut                   \NC {\showstruts\setupstrut[no]\strut}  \NC \NR
%D \NC kap          \NC a capital strut (i.e. Q)   \NC {\showstruts\setupstrut[cap]\strut} \NC \NR
%D \NC A B \unknown \NC a character strut (e.g. A) \NC {\showstruts\setupstrut[A]\strut}   \NC \NR
%D \NC              \NC a normal strut             \NC {\showstruts\setupstrut\strut}      \NC \NR
%D \stoptabulate

\def\setupstrut
  {\dosingleempty\dosetupstrut}

\def\dosetupstrut[#1]% yet undocumented, todo: fontstrut
  {\processaction
     [#1]
     [    \v!yes=>\setstrut,
         \v!auto=>\setautostrut,
           \v!no=>\setnostrut,
          \v!cap=>\setcapstrut,
          \v!fit=>\setfontstrut,
         \v!line=>\setstrut,
      \s!default=>\setstrut,
      \s!unknown=>\setcharstrut\commalistelement]}

\def\setteststrut
  {\def\strutwidth{.8pt}%
   \setstrut}

\def\autostrutfactor{1.1}

\def\setautostrut
  {\begingroup
   \setbox\scratchbox\copy\strutbox
   \setstrut
   \ifdim\strutht>\autostrutfactor\ht\scratchbox
     \endgroup \setstrut
   \else\ifdim\strutdp>\autostrutfactor\dp\scratchbox
     \endgroup \setstrut
   \else
     \endgroup
   \fi\fi}

% when enabled, sigstruts will remove themselves if nothing
% goes inbetween

\newsignal\strutsignal \setfalse\sigstruts

\def\begstrut
  {\relax\ifcase\strutht\else
     \ifconditional\sigstruts
       \noindent\horizontalstrut
       \normalpenalty\plustenthousand
       \normalhskip-\strutsignal
       \normalhskip\strutsignal
     \else
       \strut
       \normalpenalty\plustenthousand
       \normalhskip\zeropoint
     \fi
     \expandafter \ignorespaces
   \fi}

\def\endstrut
  {\relax\ifhmode\ifcase\strutht\else
     \ifconditional\sigstruts
       \ifdim\lastskip=\strutsignal
         \unskip\unskip\unpenalty\setbox\scratchbox\lastbox
       \else
         \normalpenalty\plustenthousand
         \normalhskip\zeropoint
         \strut
       \fi
     \else
       \removeunwantedspaces
       \normalpenalty\plustenthousand
       \normalhskip\zeropoint
       \strut
     \fi
   \fi\fi}

\newbox\nostrutbox \setbox\nostrutbox\normalhbox{} % {\normalhbox{}}

\def\setnostrut
  {\setbox\strutbox\copy\nostrutbox
   \let\strut\empty
   \let\endstrut\empty
   \let\begstrut\empty
   \let\crlfplaceholder\empty}

% unsave:
%
% \def\pseudostrut
%   {\bgroup
%    \setnostrut
%    \normalstrut
%    \egroup}
%
% try:
%
% \startchemie
%   \chemie[ONE,Z0,SB15,MOV1,SB15,Z0][C,C]
% \stopchemie
%
% so:

\def\pseudostrut
  {\noindent} % better: \dontleavehmode

\let\pseudobegstrut\pseudostrut

\let\pseudoendstrut\removeunwantedspaces

\def\resetteststrut
  {\let\strutwidth\zeropoint
   \setstrut}

\ifx\setfontparameters\undefined
  % problems ! ! ! !
  \def\setfontparameters{\the\everybodyfont}
\fi

%D Handy:

\def\baselinedistance{\the\lineheight}

%D We need \type{\normaloffinterlineskip} because the new
%D definition contains an assignment, and |<|don't ask me
%D why|>| this assignment gives troubles in for instance the
%D visual debugger.

%D The plain ones:

\def\offinterlineskip
  {\baselineskip-\thousandpoint
   \lineskip\zeropoint
   \lineskiplimit\maxdimen}

\def\nointerlineskip
  {\prevdepth-\thousandpoint}

\let\normaloffinterlineskip=\offinterlineskip % knuth's original

%D My own one:

\def\dopushinterlineskip
  {\edef\oninterlineskip
     {\baselineskip\the\baselineskip
      \lineskip\the\lineskip
      \lineskiplimit\the\lineskiplimit
      \let\noexpand\offinterlineskip\noexpand\normaloffinterlineskip}}

\def\nopushinterlineskip
  {\let\oninterlineskip\setnormalbaselines}

\def\offinterlineskip
  {\ifdim\baselineskip>\zeropoint
     \dopushinterlineskip
   \else
     \nopushinterlineskip
   \fi
   \normaloffinterlineskip}

\let\oninterlineskip=\relax

\def\leaveoutervmode
  {\ifvmode\ifinner\else
     \leavevmode
   \fi\fi}

% We stellen enkele penalties anders in dan Plain TEX:

% oud
%
% \widowpenalty=\defaultwidowpenalty\relax
% \clubpenalty =\defaultclubpenalty \relax

\def\resetpenalties#1%
  {\ifx#1\undefined\else
     #1\minusone
   \fi}

\def\setpenalties#1#2#3%
  {\ifx#1\undefined\else % space before #3 prevents lookahead problems, needed when #3=text
     #1\numexpr#2+\plusone\relax\space\doexpandedrecurse{\the\numexpr#2\relax}{ #3}\zerocount\relax
   \fi}

\def\doexpandedrecurse#1#2%
  {\ifnum#1>\zerocount#2\@EA\doexpandedrecurse\@EA{\the\numexpr#1-1\relax}{#2}\fi}

%D \macros
%D   {keeplinestogether}
%D
%D Dirty hack, needed in margin content that can run of a page.

% just before margintexts ... will eventually be done differently in mkiv using
% attributes

\newcount\nofkeeplinestogether
\let\restoreinterlinepenalty\relax

\def\dorestoreinterlinepenalty
  {\global\let\restoreinterlinepenalty\relax
   \global\resetpenalties\interlinepenalties
   \global\nofkeeplinestogether\zerocount}

\def\keeplinestogether#1%
  {\ifnum#1>\nofkeeplinestogether
     \global\nofkeeplinestogether#1%
     \global\setpenalties\interlinepenalties\nofkeeplinestogether\plustenthousand
     \global\let\restoreinterlinepenalty\dorestoreinterlinepenalty
   \fi}

\newif\ifgridsnapping % to be sure

\def\defaultwidowpenalty         {2000} % was: 1000
\def\defaultclubpenalty          {2000} % was:  800
\def\defaultdisplaywidowpenalty    {50}
\def\defaultbrokenpenalty         {100}

\def\defaultgridwidowpenalty        {0}
\def\defaultgridclubpenalty         {0}
\def\defaultgriddisplaywidowpenalty {0}
\def\defaultgridbrokenpenalty       {0}

\def\nopenalties
  {\widowpenalty        \zerocount
   \clubpenalty         \zerocount
   \brokenpenalty       \zerocount
   \doublehyphendemerits\zerocount
   \finalhyphendemerits \zerocount
   \adjdemerits         \zerocount}

\def\setdefaultpenalties
  {\directsetup{\systemsetupsprefix\s!default}}

\startsetups [\systemsetupsprefix\s!reset]
  \resetpenalties\widowpenalties
  \resetpenalties\clubpenalties
  \resetpenalties\interlinepenalties
\stopsetups

% we use \directsetup because it's faster and we know there is no csl

\startsetups [\systemsetupsprefix\s!default]

  \directsetup{\systemsetupsprefix\s!reset}

  \widowpenalty       \defaultwidowpenalty
  \clubpenalty        \defaultclubpenalty
  \displaywidowpenalty\defaultdisplaywidowpenalty
  \brokenpenalty      \defaultbrokenpenalty

\stopsetups

\startsetups [\v!grid] [\systemsetupsprefix\s!default]

  \directsetup{\systemsetupsprefix\s!reset}

  \widowpenalty       \defaultgridwidowpenalty
  \clubpenalty        \defaultgridclubpenalty
  \displaywidowpenalty\defaultgriddisplaywidowpenalty
  \brokenpenalty      \defaultgridbrokenpenalty

\stopsetups

% as an illustration:

\startsetups [\systemsetupsprefix\v!strict]

   \directsetup{\systemsetupsprefix\s!reset}

   \setpenalties\widowpenalties2\maxdimen
   \setpenalties\clubpenalties 2\maxdimen
                \brokenpenalty  \maxdimen

\stopsetups

\setdefaultpenalties % will happen later in \setuplayout

% Suggested by GB (not the name -):

\def\rapfillskip{.5\hsize plus .092\hsize minus .5\hsize} % D.A.'s value

% Bovendien definieren we enkele extra \fill's:

\def\hfilll{\hskip\zeropoint\!!plus1filll\relax}
\def\vfilll{\vskip\zeropoint\!!plus1filll\relax}

% De onderstaande hulpmacro's moeten nog eens instelbaar worden
% gemaakt.

\def\tfskipsize{1em\relax}
\def\tfkernsize{1ex\relax}

\def\tfskip{\dotfskip\tfskipsize}
\def\tfkern{\dotfkern\tfkernsize}

\def\dotfskip#1{{\tf\hskip#1}}
\def\dotfkern#1{{\tf\kern #1}}

% needs a proper \definenarrower or installnarrower

\newskip\ctxleftskip
\newskip\ctxrightskip
\newskip\ctxmidskip

\def\dosinglenarrower#1%
  {\processaction
     [#1]
     [     \v!left=>\global\advance\ctxleftskip  \@@slleft,
         \v!middle=>\global\advance\ctxmidskip   \@@slmiddle,
          \v!right=>\global\advance\ctxrightskip \@@slright,
          \v!reset=>\global\ctxleftskip \zeropoint
                    \global\ctxmidskip  \zeropoint
                    \global\ctxrightskip\zeropoint,
          \v!none=>,
        \s!unknown=>\global\advance\ctxmidskip   \commalistelement]}

\def\donarrower[#1]% hm, can be dorepeat directly
  {\dorepeatwithcommand[#1]\dosinglenarrower}

\def\complexstartnarrower[#1]%
  {\@@slbefore % was hard coded \par
   \bgroup
   \global\ctxleftskip \zeropoint
   \global\ctxrightskip\zeropoint
   \global\ctxmidskip  \zeropoint
   \processcommalistwithparameters[#1]\donarrower
   \advance\leftskip  \ctxleftskip
   \advance\rightskip \ctxrightskip
   \advance\leftskip  \ctxmidskip
   \advance\rightskip \ctxmidskip
   \seteffectivehsize}

% todo: definenarrower

\def\simplestartnarrower
  {\startnarrower[\v!middle]}

\definecomplexorsimple\startnarrower

\def\stopnarrower
  {\@@slafter % was hard coded \par / needed, else skips forgotten
   \egroup}

\def\setupnarrower
  {\dodoubleargument\getparameters[\??sl]}

\newdimen\@@effectivehsize     \def\effectivehsize    {\hsize}
\newdimen\@@effectiveleftskip  \def\effectiveleftskip {\leftskip}
\newdimen\@@effectiverightskip \def\effectiverightskip{\rightskip}

\def\seteffectivehsize
  {\setlocalhsize
   \@@effectivehsize      \localhsize
   \@@effectiveleftskip   \leftskip
   \@@effectiverightskip  \rightskip
   \let\effectivehsize    \@@effectivehsize
   \let\effectiveleftskip \@@effectiveleftskip
   \let\effectiverightskip\@@effectiverightskip}

% We will not use bodydir and pagedir so we disable them. That way we get
% normal hyperlink support.

\let\@@bodydir\normalbodydir
\let\@@pagedir\normalpagedir

\unexpanded\def\bodydir{\afterassignment\do@@bodydir\@@bodydir} \let\normalbodydir\bodydir
\unexpanded\def\pagedir{\afterassignment\do@@pagedir\@@pagedir} \let\normalpagedir\pagedir

\def\do@@bodydir{\@@bodydir TLT\relax}
\def\do@@pagedir{\@@pagedir TLT\relax}

% This will become a more advanced layout controller soon:

\unexpanded\def\lefttoright{\textdir TLT\pardir TLT\relax}
\unexpanded\def\righttoleft{\textdir TRT\pardir TRT\relax}

\def\dodefinehbox[#1][#2]%
  {\setvalue{hbox#1}##1%
     {\hbox to #2{\begstrut##1\endstrut\hss}}}

\def\definehbox
  {\dodoubleargument\dodefinehbox}

\def\iobox#1#2#3#% here #3# is not really needed
  {\vbox\bgroup  % we want to return a vbox like the others
     \hbox\bgroup% we need to pack the signal with the box
       \signalrightpage
       \dowithnextboxcontent
         {\let\\=\endgraf\forgetall\doifrightpageelse#1#2}
         {\box\nextbox\egroup\egroup}
       \vbox#3}

\def\obox{\iobox\raggedleft \raggedright} % outerbox
\def\ibox{\iobox\raggedright\raggedleft}  % innerbox

\def\dosetraggedvbox#1%
  {\let\raggedbox\vbox
   \processfirstactioninset
     [#1]
     [   \v!left=>\let\raggedbox\lbox,
        \v!right=>\let\raggedbox\rbox,
       \v!middle=>\let\raggedbox\cbox,
        \v!inner=>\let\raggedbox\ibox,
        \v!outer=>\let\raggedbox\obox,
    \v!flushleft=>\let\raggedbox\rbox,
   \v!flushright=>\let\raggedbox\lbox,
       \v!center=>\let\raggedbox\cbox,
           \v!no=>\def\raggedbox{\vbox\bgroup\raggedright\let\next=}]}

\def\dosetraggedhbox#1%
  {\let\raggedbox\hbox
   \processaction % slow
     [#1]
     [   \v!left=>\def\raggedbox{\doalignedline\v!left  },
        \v!right=>\def\raggedbox{\doalignedline\v!right },
       \v!middle=>\def\raggedbox{\doalignedline\v!middle},
        \v!inner=>\def\raggedbox{\doalignedline\v!inner },
        \v!outer=>\def\raggedbox{\doalignedline\v!outer },
    \v!flushleft=>\def\raggedbox{\doalignedline\v!right },
   \v!flushright=>\def\raggedbox{\doalignedline\v!left  },
       \v!center=>\def\raggedbox{\doalignedline\v!middle}]}

\def\dosetraggedcommand#1%
  {\normalexpanded{\noexpand\dodosetraggedcommand{#1}}}

\newtoks\everyraggedcommand

\def\raggedcommand{\the\everyraggedcommand}

\def\dodosetraggedcommand#1% beware: #1=empty is ignored, keep that!
  {\everyraggedcommand     \emptytoks
   \let\raggedtopcommand   \empty
   \let\raggedbottomcommand\empty
   \chardef\raggedoneliner\zerocount
   \doifsomething{#1}
     {\doifinsetelse\v!broad{#1}\!!doneatrue\!!doneafalse
      \doifinsetelse\v!wide {#1}\!!donebtrue\!!donebfalse
      \!!donectrue
      \rawprocesscommalist[#1]\dododosetraggedcommand}}

\def\dododosetraggedcommand#1%
  {\executeifdefined{\@@ragged@@command\string#1}\relax}

\def\@@ragged@@command{@@raggedcommand}

\setvalue{\@@ragged@@command\v!hanging      }{\appendtoks\enableprotruding    \to\everyraggedcommand}
\setvalue{\@@ragged@@command\v!nothanging   }{\appendtoks\disableprotruding   \to\everyraggedcommand}
\setvalue{\@@ragged@@command\v!hz           }{\appendtoks\enableadjusting     \to\everyraggedcommand}
\setvalue{\@@ragged@@command\v!nohz         }{\appendtoks\disableadjusting    \to\everyraggedcommand}
\setvalue{\@@ragged@@command\v!spacing      }{\appendtoks\enablespacehandling
                                                         \enablekernhandling  \to\everyraggedcommand}
\setvalue{\@@ragged@@command\v!nospacing    }{\appendtoks\disablespacehandling
                                                         \disablekernhandling \to\everyraggedcommand}
\setvalue{\@@ragged@@command\v!hyphenated   }{\appendtoks\dohyphens           \to\everyraggedcommand}
\setvalue{\@@ragged@@command\v!nothyphenated}{\appendtoks\nohyphens           \to\everyraggedcommand}

\setvalue{\@@ragged@@command\v!tolerant    }{\appendtoks\tolerance3000\relax  \to\everyraggedcommand}
\setvalue{\@@ragged@@command\v!verytolerant}{\appendtoks\tolerance4500\relax  \to\everyraggedcommand}
\setvalue{\@@ragged@@command\v!stretch     }{\appendtoks\emergencystretch\bodyfontsize\to\everyraggedcommand}

\setvalue{\@@ragged@@command\v!left}%
  {\if!!donea \appendtoks\veryraggedleft\to\everyraggedcommand
   \else      \appendtoks\raggedleft    \to\everyraggedcommand
   \fi
   \!!donecfalse}

\setvalue{\@@ragged@@command\v!right}%
  {\if!!donea \appendtoks\veryraggedright\to\everyraggedcommand
   \else      \appendtoks\raggedright    \to\everyraggedcommand
   \fi
   \!!donecfalse}

\setvalue{\@@ragged@@command\v!middle}%
  {\if!!donec
     \if!!doneb      \appendtoks\raggedwidecenter\to\everyraggedcommand
     \else\if!!donea \appendtoks\veryraggedcenter\to\everyraggedcommand
     \else           \appendtoks\raggedcenter    \to\everyraggedcommand
     \fi\fi
     \!!donecfalse
   \else
     \let\raggedbottomcommand\vfilll % bonus, pretty strong
     \let\raggedtopcommand   \vfilll % used with \framed for
   \fi}                              % instance in tables

\setvalue{\@@ragged@@command\v!flushleft }{\getvalue{\@@ragged@@command\v!right }}
\setvalue{\@@ragged@@command\v!flushright}{\getvalue{\@@ragged@@command\v!left  }}
\setvalue{\@@ragged@@command\v!center    }{\getvalue{\@@ragged@@command\v!middle}}

\setvalue{\@@ragged@@command\v!high}%
  {\let\raggedbottomcommand\vfilll}  % and since we lack a

\setvalue{\@@ragged@@command\v!low}%
  {\let\raggedtopcommand\vfilll}     % proper keyword, but

\setvalue{\@@ragged@@command\v!lohi}%
  {\let\raggedbottomcommand\vfilll   % we do support the
   \let\raggedtopcommand\vfilll}     % ugly laho (lohi)

\setvalue{\@@ragged@@command\v!no}%
  {\appendtoks\raggedright\to\everyraggedcommand}

\setvalue{\@@ragged@@command\v!yes}%
  {\appendtoks\notragged\to\everyraggedcommand}

\setvalue{\@@ragged@@command\v!normal}%
  {\appendtoks\notragged\to\everyraggedcommand}

\setvalue{\@@ragged@@command\v!inner}% not yet perfect
  {\signalrightpage % may interfere
   \doifrightpageelse
     {\getvalue{\@@ragged@@command\v!right}}
     {\getvalue{\@@ragged@@command\v!left}}}

\setvalue{\@@ragged@@command\v!outer}% not yet perfect
  {\signalrightpage % may interfere
   \doifrightpageelse
     {\getvalue{\@@ragged@@command\v!left}}
     {\getvalue{\@@ragged@@command\v!right}}}

\setvalue{\@@ragged@@command\v!lesshyphenation}%
  {\appendtoks\lesshyphens\to\everyraggedcommand}
\setvalue{\@@ragged@@command\v!morehyphenation}%
  {\appendtoks\morehyphens\to\everyraggedcommand}

\setvalue{\@@ragged@@command\v!lefttoright}{\appendtoks\lefttoright\to\everyraggedcommand}
\setvalue{\@@ragged@@command\v!righttoleft}{\appendtoks\righttoleft\to\everyraggedcommand}
\setvalue{\@@ragged@@command           l2r}{\appendtoks\lefttoright\to\everyraggedcommand}
\setvalue{\@@ragged@@command           r2l}{\appendtoks\righttoleft\to\everyraggedcommand}

% compare:
%
% \framed[width=4cm,align=no]     {\hfil xxx}
% \framed[width=4cm,align=disable]{\hfil xxx}

\setvalue{\@@ragged@@command\v!disable}% for one liners
  {\appendtoks\raggedright\parfillskip\zeropoint\to\everyraggedcommand}

\chardef\raggedoneliner\zerocount

\setvalue{\@@ragged@@command\v!line}%
  {\chardef\raggedoneliner\plusone}

% Nog doen:
%
%  \goodbreak -> \allowbreak en \dosomebreak{..} in koppen
%
% bij koppen zowieso: \blanko[reset]

% Nog in commando verwerken:
%
% \voorkeur  la \blanko
%
% Om ongewenste witruimte te voorkomen kan met \dosomebreak{\break}
% een \penalty voor witruimte worden geplaatst.

\def\removelastskip % a redefinition of plain
  {\ifvmode\ifdim\lastskip=\zeropoint\else\vskip-\lastskip\fi\fi}

\def\doifoutervmode#1%
  {\ifvmode\ifinner\else#1\fi\fi}

\ifx\dosomebreak\undefined % defined in mkiv

    \def\dosomebreak#1%
      {\doifoutervmode
         {\scratchskip\lastskip
          \removelastskip
          %\leavevmode\type{#1}%
          #1\relax
          \ifdim\scratchskip=\zeropoint % else interference with footnotes
          \else
            \vskip\scratchskip
          \fi}}

\fi

\def\forgeteverypar
  {\everypar{\the\neverypar}}

\def\forgetparindent
  {\forgeteverypar
   \indentfirstparagraphtrue % recently added
   \let\currentindentation\v!none
   \ctxparindent\zeropoint
   \parindent\zeropoint\relax}

\def\forgetparskip
  {\let\currentwhitespace\v!none
   \ctxparskip\zeropoint
   \parskip\zeropoint\relax}

\def\forgetbothskips
  {\tolerance1500
   \leftskip\zeropoint
   \rightskip\zeropoint\relax}

\def\forgetspacing
  {\emergencystretch\zeropoint}

\newif\ifforgotten % rather good signal for inner

\appendtoks \forgottentrue      \to \everyforgetall
\appendtoks \forgetragged       \to \everyforgetall
\appendtoks \forgetparskip      \to \everyforgetall
\appendtoks \forgetparindent    \to \everyforgetall
\appendtoks \forgetbothskips    \to \everyforgetall
\appendtoks \forgetspacing      \to \everyforgetall % i.v.m. funny spacing in pagebody
\appendtoks \spacing\plusone    \to \everyforgetall % new per 10/08/2004, else problems in otr / !! needed
\appendtoks \everypar\emptytoks \to \everyforgetall % indeed!

\def\localvbox#1#%
  {\vbox#1\bgroup
     \forgetparskip
     \setlocalhsize
     \hsize\localhsize
     \forgetparindent
     \forgetbothskips
     \forgeteverypar
     \let\next=}

\let\dostopattributes\relax % in case these commands end up in an edef

% \unexpanded\def\dostartattributes#1#2#3%
%   {\begingroup  % geen \bgroup, anders in mathmode lege \hbox
%    \ifcsname#1#3\endcsname
%      \let\dostopattributes\@@dostopattributes
%      \startcolor[\csname#1#3\endcsname]%
%    \else
%      \let\dostopattributes\@@nostopattributes
%    \fi
%    \ifcsname#1#2\endcsname
%      \expandafter\doconvertfont
%    \else
%      \expandafter\gobbleoneargument
%    \fi{\csname#1#2\endcsname}}

\newconditional \parbasedattributes

\def\finishparbasedattributes
  {\ifconditional\parbasedattributes
     \setfalse\parbasedattributes
     \par
   \fi}

\def\dostopparbasedattributes
  {\settrue\parbasedattributes
   \dostopattributes}

\unexpanded\def\@@dostopattributes
  {\stopcolor
   \finishparbasedattributes
   \endgroup}

\unexpanded\def\@@nostopattributes
  {\finishparbasedattributes
   \endgroup}

\unexpanded\def\doattributes#1#2#3#4%
  {\dostartattributes{#1}{#2}{#3}{#4}\dostopattributes}

% An even faster \ETEX\ version:

\unexpanded\def\dostartattributes#1#2#3%
  {\begingroup  % geen \bgroup, anders in mathmode lege \hbox
   \ifincolor
     \ifcsname#1#3\endcsname
       \let\dostopattributes\@@dostopattributes
       \faststartcolor[\csname#1#3\endcsname]%
     \else
       \let\dostopattributes\@@nostopattributes
     \fi
   \else
     \let\dostopattributes\@@nostopattributes
   \fi
   \ifcsname#1#2\endcsname
   % \@EAEAEA\doconvertfont\@EA\@EA\csname#1#2\endcsname
     \@EA\doconvertfont\csname#1#2\@EA\endcsname
   \fi}

\unexpanded\def\@@dostopattributes
  {\faststopcolor
   \finishparbasedattributes
   \endgroup}

\unexpanded\def\@@nostopattributes
  {\finishparbasedattributes
   \endgroup}

%D Bonus macro, see core-sec.tex

\unexpanded\def\dosetfontattribute#1#2%
  {\ifcsname#1#2\endcsname
     \@EA\doconvertfont\csname#1#2\@EA\endcsname
   \fi\empty}

%D Since this happens a lot, and sometimes large arguments
%D are passed in \type {#4}, we just copy some code:

\unexpanded\def\doattributes#1#2#3#4%
  {\begingroup  % geen \bgroup, anders in mathmode lege \hbox
   \ifincolor
     \ifcsname#1#3\endcsname
       \let\dostopattributes\@@dostopattributes
       \faststartcolor[\csname#1#3\endcsname]%
     \else
       \let\dostopattributes\endgroup
     \fi
     \else
       \let\dostopattributes\endgroup
     \fi
     \ifcsname#1#2\endcsname
     % \@EAEAEA\doconvertfont\@EA\@EA\csname#1#2\endcsname
       \@EA\doconvertfont\csname#1#2\@EA\endcsname
     \fi
     {#4}%
     \dostopattributes}

% Kan vaker worden toegepast en moet bovendien sneller!

\newskip\leftskipadaption
\newskip\rightskipadaption

\def\doadaptleftskip#1%
  {\dosetleftskipadaption{#1}%
   \advance\leftskip \leftskipadaption}

\def\doadaptrightskip#1%
  {\dosetrightskipadaption{#1}%
   \advance\rightskip \rightskipadaption}

\setvalue{@lsa@\v!standard}{\ifdim\ctxparindent=\zeropoint\@@slleft\else\ctxparindent\fi}
\setvalue{@lsa@\v!yes     }{\ifdim\ctxparindent=\zeropoint\@@slleft\else\ctxparindent\fi}
\letvalue{@lsa@\v!no      }\zeropoint
\letvalue{@lsa@\empty     }\zeropoint
\setvalue{@rsa@\v!standard}{\@@slright}
\setvalue{@rsa@\v!yes     }{\@@slright}
\letvalue{@rsa@\v!no      }\zeropoint
\letvalue{@rsa@\empty     }\zeropoint

\def\dosetleftskipadaption#1%
  {\edefconvertedargument\ascii{@lsa@#1}%
   \leftskipadaption
     \ifcsname\ascii\endcsname
       \csname\ascii\endcsname
     \else
       #1%
     \fi
   \relax}

\def\dosetrightskipadaption#1%
  {\edefconvertedargument\ascii{@rsa@#1}%
   \rightskipadaption
     \ifcsname\ascii\endcsname
       \csname\ascii\endcsname
     \else
       #1%
     \fi
   \relax}

\newcount \noftrackedpagestates
\newif    \ifpagestatemismatch
\newcount \realpagestateno
\chardef  \frozenpagestate      \zerocount

\def\dotrackpagestate#1#2%
  {\ifdoublesided \ifinpagebody \else
     \doforcedtrackpagestate{#1}{#2}%
   \fi \fi}

\def\doforcedtrackpagestate#1#2%
  {\ifcase\frozenpagestate
     \global\advance\noftrackedpagestates\plusone
     \global\advance#2\plusone
     \lazysavetaggedtwopassdata{#1}{\number\noftrackedpagestates}{\number#2}{\noexpand\realfolio}%
     %\llap{\infofont\number\noftrackedpagestates/\number#2}% tracing
   \fi}

\def\doifrightpagestateelse#1#2%
  {\ifcase\frozenpagestate
     \pagestatemismatchfalse
     \realpagestateno\realfolio
     \ifinpagebody
       \ifdoublesided
         \ifodd\realpageno\relax
           \twopassdatafoundtrue \else \twopassdatafoundfalse
         \fi
       \else
         \twopassdatafoundtrue
       \fi
     \else\ifdoublesided
       \findtwopassdata{#1}{\number#2}%
       \iftwopassdatafound
         \realpagestateno\twopassdata\relax
         \ifnum\twopassdata=\realpageno \else
           \pagestatemismatchtrue
         \fi
         \ifodd\twopassdata\relax
           \twopassdatafoundtrue \else \twopassdatafoundfalse
         \fi
       \else
         \ifodd\realpageno\relax
           \twopassdatafoundtrue \else \twopassdatafoundfalse
         \fi
       \fi
     \else
       \twopassdatafoundtrue
     \fi\fi
   \else
     \ifodd\realpagestateno\relax
       \twopassdatafoundtrue \else \twopassdatafoundfalse
     \fi
   \fi
   \iftwopassdatafound
     \@EA\firstoftwoarguments
   \else
     \@EA\secondoftwoarguments
   \fi}

\def\doifforcedrightpagestateelse#1#2%
  {\ifcase\frozenpagestate
     \pagestatemismatchfalse
     \realpagestateno\realfolio
     \findtwopassdata{#1}{\number#2}%
     \iftwopassdatafound
       \realpagestateno\twopassdata\relax
       \ifnum\twopassdata=\realpageno \else
         \pagestatemismatchtrue
       \fi
       \ifodd\twopassdata\relax
         \twopassdatafoundtrue \else \twopassdatafoundfalse
       \fi
     \else
       \ifodd\realpageno\relax
         \twopassdatafoundtrue \else \twopassdatafoundfalse
       \fi
     \fi
   \else
     \ifodd\realpagestateno\relax
       \twopassdatafoundtrue \else \twopassdatafoundfalse
     \fi
   \fi
   \iftwopassdatafound
     \@EA\firstoftwoarguments
   \else
     \@EA\secondoftwoarguments
   \fi}

\def\freezepagestate {\chardef\frozenpagestate\plusone  }
\def\defrostpagestate{\chardef\frozenpagestate\zerocount}

% we can make more of these on top, but how to deal with mixed frozen states

\definetwopasslist\s!paragraph \newcount \nofraggedparagraphs

\def\signalrightpage  {\dotrackpagestate      \s!paragraph\nofraggedparagraphs}
\def\doifrightpageelse{\doifrightpagestateelse\s!paragraph\nofraggedparagraphs}

\newcount\pagesignallevel

\def\startsignalrightpage % one may do a \postsignalrightplace
  {\advance\pagesignallevel\plusone
   \presignalrightpage
   \let\signalrightpage\relax
   \let\presignalrightpage\relax
   \let\startsignalrightpage\relax
   \doifrightpageelse\donothing\donothing
   \freezepagestate}

\def\stopsignalrightpage
  {\ifcase\pagesignallevel\or\postsignalrightpage\fi
   \advance\pagesignallevel\minusone}

\def\setraggedparagraphmode
  {\signalrightpage\doifrightpageelse} % move it there

\ifx\swapmargins\undefined \let\swapmargins\undefined \fi % todo

\def\doifswappedrightpageelse#1#2% alleen in box construction !
  {\doifrightpageelse
     {#1}
     {\scratchcounter\realpageno
      \realpageno\realpagestateno\relax
      \swapmargins
      \realpageno\scratchcounter
      #2}}

\newbox\signaledrightpage % this way we can avoid interference, i.e. postpone placement

\def\presignalrightpage {\global\setbox\signaledrightpage\hbox{\signalrightpage}}
\def\postsignalrightpage{\ifvoid\signaledrightpage\else\box\signaledrightpage\fi}

% The next feature is is used in:
%
% \definenumber[test][way=bypage]
%
% \def\Test
%   {\incrementnumber[test]\rawnumber[test]/%
%    \incrementnumber[test]\rawnumber[test]/%
%    \incrementnumber[test]\rawnumber[test]\space
%    \checkpagechange{oeps}\changedpage{oeps}\space
%    \ifpagechanged TRUE\else FALSE\fi}
%
% \Test\page \Test\par \Test\page \Test\par \Test\page \Test\page
%
% (adapted from cont-new.tex:)

\newif\ifpagechanged \let\lastchangedpage\empty

\def\docheckpagestatechange#1#2#3%
  {\pagechangedfalse
   \doforcedtrackpagestate{#2}{#3}%
   \findtwopassdata{#2}{\number#3}%
   \iftwopassdatafound
     \ifnum\twopassdata>0\getvalue{#2:p:#1}\relax
       \pagechangedtrue
     \fi
   \fi
   \ifpagechanged
     \letgvalue{#2:p:#1}\twopassdata
     \globallet\lastchangedpage\twopassdata
   \else
     \globallet\lastchangedpage\realfolio
   \fi}

\def\changedpagestate#1#2%
  {\executeifdefined{#2:p:#1}{0}}

\def\checkpagechange#1{\docheckpagestatechange{#1}\s!paragraph\nofraggedparagraphs}
\def\changedpage    #1{\changedpagestate{#1}\s!paragraph}

% saved struts

\ifx\savedstrutbox\undefined \newbox\savedstrutbox \fi

\def\savestrut {\setbox\savedstrutbox\copy\strutbox}
\def\savedstrut{\copy  \savedstrutbox}

\chardef\bottomraggedness=0 % 0=ragged 1=normal/align 2=baseline

\def\bottomalignlimit{3\lineheight}

\newif\ifn@rmalbottom
\newif\ifr@ggedbottom
\newif\ifb@selinebottom

\def\normalbottom
  {% \topskip 10pt
   \r@ggedbottomfalse}

\def\raggedbottom
  {\chardef\bottomraggedness\zerocount
   \n@rmalbottomfalse
   \r@ggedbottomtrue
   \b@selinebottomfalse
   \settopskip}

\def\alignbottom
  {\chardef\bottomraggedness\plusone
   \n@rmalbottomtrue
   \r@ggedbottomfalse
   \b@selinebottomfalse
   \settopskip}

\def\baselinebottom
  {\chardef\bottomraggedness\plustwo
   \n@rmalbottomfalse
   \r@ggedbottomfalse
   \b@selinebottomtrue
   \settopskip}

\let\normalbottom=\alignbottom % downward compatible

% new code, not in use yet

% for future chinese typo-module:
%
% % \let\raggedleft\veryraggedleft
% % \let\raggedleft\veryraggedright
%
% \startbuffer
% %
% %
% %
% %
% \stopbuffer
%
% \framedtext
%     [align={broad,flushright},width=90mm]
%     {\getbuffer}
%
% \framedtext
%     [align={broad,flushleft},width=90mm]
%     {\getbuffer}
%
% \framedtext
%     [align=middle,width=90mm]
%     {\getbuffer}
%
% using just flushleft is not okay here due to the fact that
% leftskip has less stretch than the inter character spacing

\registerctxluafile{core-spa}{1.001}

\definesystemattribute[kern-chars]
\definesystemattribute[skip-category]  \chardef\skipcategoryattribute  \dogetattributeid{skip-category}
\definesystemattribute[skip-penalty]   \chardef\skippenaltyattribute   \dogetattributeid{skip-penalty}
\definesystemattribute[skip-order]     \chardef\skiporderattribute     \dogetattributeid{skip-order}
\definesystemattribute[snap-category]
\definesystemattribute[display-math]

% \start \dosetstretch{.25em} \setuptolerance[tolerant,stretch] \input tufte \endgraf \stop
% \start \dosetstretch{.5em} effe flink doorfietsen \stop

\def\dosetupgridsnapping % calls too often, only needed in gridsnapping
  {\ctxlua{nodes.setsnapvalue(1,\number\openstrutheight,\number\openstrutdepth)}}

\def\doenablegridsnapping
  {\dosetattribute{snap-category}{1}%
   \topskip\strutht
   \offinterlineskip}

\def\dodisablegridsnapping
  {\doresetattribute{snap-category}%
   % reset topskip
   \oninterlineskip}

% experimental code, not yet interfaced:

% category:
% 0 == discard                             discard
% 1 == only if larger                      largest
% 2 == force even if smaller               force
% 3 == only take penalty component         penalty
% 4 == add to existing skip                add
% 5 == disable (ignore following)          disable
% 6 == kill whitespace                     nowhite
% 7 == discard previous                    back
%
% penalty: larger wins
% order: larger wins
% category:2,order:5,penalty:10000,skip:value|kw
%
% always -- obsolete
% none   -- obsolete
% outer  -- obsolete
% reset  -- obsolete
% \defineblankmethod  [\v!joinedup] {\ifvmode\nointerlineskip\fi}

% todo, in grid mode: vspacing.fixed = false

\newtoks\everybeforeblankhandling
\newtoks\everyafterblankhandling

\appendtoks
    \blankskip\zeropoint
    \attribute\skipcategoryattribute\plusone
    \attribute\skippenaltyattribute \attributeunsetvalue
    \attribute\skiporderattribute   \attributeunsetvalue
    \ifblankflexible
        \setfalse\blankisfixed
    \else
        \settrue\blankisfixed
    \fi
\to \everybeforeblankhandling

\appendtoks
    \ifconditional\blankisfixed
        \blankskip1\blankskip
    \else
        \blankskip1\blankskip\!!plus\skipgluefactor\blankskip\!!minus\skipgluefactor\blankskip
    \fi
\to \everyafterblankhandling

\def\setblankcategory#1{\attribute\skipcategoryattribute#1\relax}
\def\setblankorder   #1{\attribute\skiporderattribute   #1\relax}
\def\setblankpenalty #1{\attribute\skippenaltyattribute #1\relax}
\def\addblankskip#1#2#3{\advance\blankskip#1\dimexpr\ifgridsnapping#3\else#2\fi\relax\relax}
\def\fixedblankskip    {\settrue \blankisfixed} % \blankskip1\blankskip}
\def\flexibleblankskip {\setfalse\blankisfixed} % \blankskip1\blankskip\!!plus\skipgluefactor\blankskip\!!minus\skipgluefactor\blankskip}

\def\startblankhandling
  {\begingroup
   \the\everybeforeblankhandling}

\def\stopblankhandling
  {\the\everyafterblankhandling
   \vskip\blankskip
   \endgroup}

\def\flushblankhandling
  {\the\everyafterblankhandling
   \vskip\blankskip
   \the\everybeforeblankhandling}

% % % %

\def\definevspacingamount
  {\dotripleempty\dodefinevspacingamount}

\def\dodefinevspacingamount[#1][#2][#3]%
  {\ctxlua{vspacing.setskip("#1",\!!bs\detokenize{#2}\!!es,\!!bs\detokenize{#3}\!!es)}}

\def\definevspacing
  {\dodoubleempty\dodefinevspacing}

\def\dodefinevspacing[#1][#2]%
  {\ctxlua{vspacing.setmap("#1","#2")}}

\unexpanded\def\vspacing
  {\dosingleempty\dovspacing}

\def\dovspacing[#1]%
  {\ctxlua{vspacing.analyse("\iffirstargument#1\else default\fi")}}

% category:4 is default

\definevspacingamount[\v!big]     [\bigskipamount]     [\openlineheight]
\definevspacingamount[\v!medium]  [\medskipamount]     [0.50\openlineheight]
\definevspacingamount[\v!small]   [\smallskipamount]   [0.25\openlineheight]
\definevspacingamount[\v!line]    [\openlineheight]    [\openlineheight]
\definevspacingamount[\v!halfline][0.50\openlineheight][0.50\openlineheight]
\definevspacingamount[\v!formula] [\medskipamount]     [0.50\openlineheight]
\definevspacingamount[\v!white]   [\parskip]           [\openlineheight]

\definevspacing[\s!default] [\v!big]
\definevspacing[\v!samepage][penalty:10000]
\definevspacing[\v!max]     [category:1]
\definevspacing[\v!force]   [category:2]
\definevspacing[\v!disable] [category:5]
\definevspacing[\v!nowhite] [category:6]
\definevspacing[\v!back]    [category:7]
\definevspacing[\v!always]  [category:0]
\definevspacing[\v!weak]    [order:0]
\definevspacing[\v!strong]  [order:100]

\defineblankmethod[\v!samepage]{\writestatus\m!systems{ignoring blank method '\v!samepage'}}
\defineblankmethod[\v!max]     {\writestatus\m!systems{ignoring blank method '\v!max'}}
\defineblankmethod[\v!weak]    {\writestatus\m!systems{ignoring blank method '\v!weak'}}
\defineblankmethod[\v!strong]  {\writestatus\m!systems{ignoring blank method '\v!strong'}}

% \definevspacing[whatever][4*big]
% \vspacing[2*big,-medium,-3*small,whatever,halfline,order:10,category:4,strong,samepage]
% \vspacing[2*big,category:disable]
% \vspacing[2*big,disable]
% \vspacing[2*big,back]

% some temporary hacks

\setfalse\vspacingenabled

% ! ! ! ! ! later, now each newline does a \par and call to the callback

\newtoks\everyenablevspacing
\newtoks\everydisablevspacing

\def\enablevspacing {\the\everyenablevspacing}
\def\disablevspacing{\the\everydisablevspacing}

\appendtoks
    \writestatus\m!systems{! ! enabling vspacing ! !}%
    \settrue\vspacingenabled
    \ctxlua{vspacing.enable()}%
\to \everyenablevspacing

\appendtoks
    \writestatus\m!systems{! ! disabling vspacing ! !}%
    \setfalse\vspacingenabled
    \ctxlua{vspacing.disable()}%
\to \everydisablevspacing

\let\originalblank   \blank       % we use \original for non-primitives
\let\originalvspacing\vspacing

\let\setupvspacing\setupblank % for the moment

% so, the new one will be
%
% \chardef\bottomraggedness=0 % 0=ragged 1=normal/align 2=baseline
%
% \def\bottomalignlimit{3\lineheight} % will be settable
%
% \def\raggedbottom  {\chardef\bottomraggedness=0 \settopskip}
% \def\alignbottom   {\chardef\bottomraggedness=1 \settopskip}
% \def\baselinebottom{\chardef\bottomraggedness=2 \settopskip}
%
% \let\normalbottom  =\alignbottom

% \hyphenpenalty  = ( 2.5 * \hsize ) / \raggedness
% \tolerance     >= 1500 % was 200
% \raggedness     = 2 .. 6\bodyfontsize

\chardef\raggedstatus=0 % normal left center right

\def\leftraggedness   {2\bodyfontsize}
\def\rightraggedness  {2\bodyfontsize}
\def\middleraggedness {6\bodyfontsize}

\def\middleraggedness {.5\hsize} % was: 6\bodyfontsize, fails on: \placefigure{x $x=x$ x}{}

% oeps, hsize can be 0pt in which case we get a strange division

\def\middleraggedness {\ifdim\hsize=\zeropoint6\bodyfontsize\else.5\hsize\fi} % was: 6\bodyfontsize, fails on: \placefigure{x $x=x$ x}{}

%D More hyphenation control, will be combined with align
%D setup.

\def\nohyphens
  {\ifx\dohyphens\relax
     \edef\dohyphens
       {\hyphenpenalty\the\hyphenpenalty
        \exhyphenpenalty\the\exhyphenpenalty\relax}%
   \fi
   \hyphenpenalty\plustenthousand
   \exhyphenpenalty\plustenthousand}

\let\dohyphens\relax

%D To prevent unwanted side effects, we also have to check
%D for hyphens here:

\newskip\@@raggedskipa
\newskip\@@raggedskipb

\def\setraggedness#1%
  {\ifnum\tolerance<1500\relax    % small values have
     \tolerance1500\relax         % unwanted side effects
   \fi
   \ifx\dohyphens\relax
     % this code will be reconsidered / kind of fuzzy (and old)
     \@@raggedskipa 2.5\hsize
     \@@raggedskipb  #1\relax
     \divide\@@raggedskipa \@@raggedskipb
     \hyphenpenalty\@@raggedskipa
   \fi}

\let\updateraggedskips\relax

\def\setraggedskips#1#2#3#4#5#6#7% never change this name
  {\def\updateraggedskips{\dosetraggedskips{#1}{#2}{#3}{#4}{#5}{#6}{#7}}%
   \updateraggedskips}

\def\dosetraggedskips#1#2#3#4#5#6#7%
  {\chardef    \raggedstatus#1\relax
   \leftskip   1\leftskip \!!plus#2\relax % zie: Tex By Topic 8.1.3
   \rightskip  1\rightskip\!!plus#3\relax % zie: Tex By Topic 8.1.3
   \spaceskip  #4\relax
   \xspaceskip #5\relax
   \parfillskip\zeropoint\!!plus#6\relax
   \parindent  #7\relax}

% \def\notragged%
%   {\setraggedskips{0}{0em}{0em}{0em}{0em}{1fil}{\parindent}}

% older (context) names:

\let\spaceamount  \interwordspace
\let\emspaceamount\emwidth

% tracing:

\def\doshowpardata#1%
  {\ifx#1\relax\else
     \hbox{\string#1: \the#1}\endgraf
     \expandafter\doshowpardata
   \fi}

\def\showpardata
  {\edef\thepardata
     {\hbox{font: \fontname\font}\endgraf
      \doshowpardata
        \interwordspace \interwordstretch \interwordshrink \emwidth \exheight \extraspace
        \hsize     \vsize
        \leftskip  \rightskip
        \spaceskip \xspaceskip
        \parindent \parfillskip
        \hyphenpenalty \exhyphenpenalty
        \displaywidowpenalty \widowpenalty \clubpenalty \brokenpenalty
        \doublehyphendemerits \finalhyphendemerits \adjdemerits
      \relax}%
   \begingroup
   \dontshowcomposition
   \inleftmargin{\vsmash
     {\switchtobodyfont[7pt,tt]%
      \framed[\c!align=\v!right]{\thepardata}}}%
   \endgroup}

\def\startshowpardata
  {\begingroup
   \showcomposition
   \showstruts\tracepositionstrue \tracingparagraphs\maxdimen
   \appendtoksonce\showpardata\let\showpardata\relax\to\everypar}

\def\stopshowpardata
  {\endgraf
   \endgroup}

% \defineXMLenvironment[showpardata] \startshowpardata \stopshowpardata
% \defineXMLsingular   [showpardata] \showpardata

% defaults

\def\raggedfillamount    {1fil}
\def\raggedhalffillamount{.5fil}
\def\raggedspaceamount   {\interwordspace} % {.3333em}
\def\raggedxspaceamount  {.5em}

\def\notragged
  {\chardef\raggedstatus\zerocount
   \leftskip  1\leftskip
   \rightskip 1\rightskip
   \spaceskip  \zeropoint
   \xspaceskip \zeropoint
   \parfillskip\zeropoint\!!plus\raggedfillamount\relax
   \let\updateraggedskips\relax} % new

\let\forgetragged\notragged

\def\raggedleft
  {\setraggedness\leftraggedness
   \setraggedskips1\leftraggedness\zeropoint\raggedspaceamount
     \raggedxspaceamount\zeropoint\zeropoint}

\def\raggedcenter
  {\setraggedness\middleraggedness
   \setraggedskips2\middleraggedness\middleraggedness\raggedspaceamount
     \raggedxspaceamount\zeropoint\zeropoint}

%D We used to have:
%D
%D \starttyping
%D \def\raggedright
%D   {\setraggedness\rightraggedness
%D    \setraggedskips{3}{0em}{\rightraggedness}{.3333em}{.5em}{0em}{\parindent}}
%D \stoptyping
%D
%D However, the next alternative, suggested by Taco, is better.

\def\raggedright
  {\setraggedness\rightraggedness
   \setraggedskips3\zeropoint\rightraggedness\raggedspaceamount
     \raggedxspaceamount\raggedfillamount\parindent}

\def\veryraggedleft
  {\setraggedskips1\raggedfillamount\zeropoint\raggedspaceamount
     \raggedxspaceamount\zeropoint\zeropoint}

%D When we want the last line to have a natural width:
%D
%D \starttyping
%D \def\veryraggedleft%
%D   {\setraggedskips{1}{1fil}{0em}{.3333em}{.5em}{0em}{-1fil}}
%D \stoptyping
%D
%D but this one is not accepted by the macros.

\def\veryraggedcenter
  {\setraggedskips2\raggedfillamount\raggedfillamount\raggedspaceamount
     \raggedxspaceamount\zeropoint\zeropoint}

\def\veryraggedright
  {\setraggedskips3\zeropoint\raggedfillamount\raggedspaceamount
     \raggedxspaceamount\zeropoint\parindent}

\def\ttraggedright
  {\tttf
   \setraggedskips3\zeropoint\rightraggedness
     \zeropoint\zeropoint\zeropoint\parindent} % \ctxparindent

%D A bonus one:

\def\raggedwidecenter
  {\setraggedness\middleraggedness
   \setraggedskips2\raggedhalffillamount\raggedhalffillamount
     \raggedspaceamount\raggedxspaceamount\zeropoint\zeropoint}

\newif\if@@asragged \@@asraggedtrue % old method

% todo
%
% \setuplayout[grid=yes,lines=44] \showgrid
% \starttext
% test \vfill test \endgraf \strut \endgraf \vskip-\lineheight \removedepth \pagina test
% \stoptext

% \setupalign[reset,new,right,old]

\def\@@align@@rl{\if!!donea\veryraggedleft  \else\raggedleft  \fi}
\def\@@align@@rr{\if!!donea\veryraggedright \else\raggedright \fi}
\def\@@align@@rc{\if!!donea\veryraggedcenter\else\raggedcenter\fi}

\setvalue{@@ngila@@\v!broad    }{\!!doneatrue}
\setvalue{@@ngila@@\v!wide     }{\!!donebtrue}

\def\installalign#1#2{\setvalue{@@align@@#1}{#2}} % can be used for overloads

\installalign \v!new           {\@@asraggedfalse}
\installalign \v!old           {\@@asraggedtrue}
\installalign \empty           {}

\installalign \v!line          {\baselinebottom}
\installalign \v!bottom        {\raggedbottom}
\installalign \v!height        {\normalbottom}
\installalign \v!width         {\notragged}
\installalign \v!normal        {\notragged}
\installalign \v!yes           {\notragged}
\installalign \v!no            {\raggedright}
\installalign \v!inner         {\if@@asragged \setraggedparagraphmode\@@align@@rl\@@align@@rr \else
                                              \setraggedparagraphmode\@@align@@rr\@@align@@rl \fi}
\installalign \v!outer         {\if@@asragged \setraggedparagraphmode\@@align@@rr\@@align@@rl \else
                                \setraggedparagraphmode\@@align@@rl\@@align@@rr \fi}
\installalign \v!left          {\if@@asragged\@@align@@rl\else\@@align@@rr\fi}
\installalign \v!right         {\if@@asragged\@@align@@rr\else\@@align@@rl\fi}
\installalign \v!middle        {\if!!doneb\raggedwidecenter\else\@@align@@rc\fi}
\installalign \v!flushleft     {\if!!donea\veryraggedright \else\raggedright\fi}
\installalign \v!flushright    {\if!!donea\veryraggedleft  \else\raggedleft \fi}
\installalign \v!flushouter    {\setraggedparagraphmode\raggedleft\raggedright}
\installalign \v!flushinner    {\setraggedparagraphmode\raggedright\raggedleft}
\installalign \v!center        {\if!!doneb\raggedwidecenter\else\@@align@@rc\fi}
\installalign \v!hanging       {\enableprotruding}
\installalign \v!nothanging    {\disableprotruding}
\installalign \v!hz            {\enableadjusting}
\installalign \v!nohz          {\disableadjusting}
\installalign \v!spacing       {\enablespacehandling \enablekernhandling}
\installalign \v!nospacing     {\disablespacehandling\disablekernhandling}
\installalign \v!hyphenated    {\dohyphens}
\installalign \v!nothyphenated {\nohyphens}
\installalign \v!new           {\@@asraggedfalse} % so new will give you consistency
\installalign \v!reset         {\notragged\normalbottom}

\installalign \v!tolerant      {\tolerance3000   \relax}
\installalign \v!verytolerant  {\tolerance4500   \relax}
\installalign \v!stretch       {\emergencystretch\bodyfontsize}

\installalign \v!grid          {\doenablegridsnapping } % only mkiv
\installalign \v!nogrid        {\dodisablegridsnapping} % only mkiv

\installalign \v!righttoleft   {\lefttoright}
\installalign \v!lefttoright   {\righttoleft}
\installalign {l2r}            {\lefttoright}
\installalign {r2l}            {\righttoleft}

\newcount\hyphenminoffset

\ifx\sethyphenationvariables\undefined \let\sethyphenationvariables\relax \fi

\def\lesshyphens
  {\advance\hyphenminoffset\plusone
   \sethyphenationvariables}

\def\morehyphens
  {\ifcase\hyphenminoffset \else
     \advance\hyphenminoffset\minusone
   \fi
   \sethyphenationvariables}

\installalign \v!lesshyphenation {\lesshyphens}
\installalign \v!morehyphenation {\morehyphens}

\def\dodosetupalign#1{\csname @@align@@#1\endcsname}
\def\dodosetupngila#1{\csname @@ngila@@#1\endcsname}

\def\setupalign
  {\dosingleargument\dosetupalign}

\def\dosetupalign[#1]% can be made faster by checking for defined #1
  {\!!doneafalse
   \!!donebfalse
   \processcommacommand[#1]\dodosetupngila
   \processcommacommand[#1]\dodosetupalign}

% \setupalign[flushleft]  \input ward \par % lijnlinks
% \setupalign[right]      \input ward \par

% \setupalign[flushright] \input ward \par % lijnrechts
% \setupalign[left]       \input ward \par

% \setupalign[middle]     \input ward \par % centreer
% \setupalign[center]     \input ward \par

\def\startalignment
  {\bgroup
   \setupalign}

\def\stopalignment
  {\par
   \egroup}

\chardef\alignstrutmode=1

% see later for the real definition, which in the simple case is:

\newtoks \everyleftofalignedline
\newtoks \everyrightofalignedline

\def\shiftalignedline#1#2#3#4% left, right, inner, outer
  {\rightorleftpageaction
     {\everyleftofalignedline {\hskip\dimexpr#1+#3\relax}%
      \everyrightofalignedline{\hskip\dimexpr#2+#4\relax}}
     {\everyleftofalignedline {\hskip\dimexpr#1+#4\relax}%
      \everyrightofalignedline{\hskip\dimexpr#2+#3\relax}}}

\def\doalignline#1#2% \\ == newline
  {\noindentation  % was \noindent
   \dontleavehmode % added in marrakesch at TUG 2006\begingroup
   \begingroup
   \setlocalhsize % new
   \def\\{\egroup\par\doalignline{#1}{#2}\bgroup}%
   \dowithnextbox
     {\hbox to \localhsize
        {\ifcase\alignstrutmode\or\strut\fi
         \the\everyleftofalignedline
         #1\unhbox\nextbox#2\relax
         \the\everyrightofalignedline}%
      \endgroup}
     \hbox}

% plain commands

\ifx\undefined\line       \def\line        {\hbox to\hsize}    \fi
\ifx\undefined\leftline   \def\leftline  #1{\line{#1\hss}}     \fi
\ifx\undefined\rightline  \def\rightline #1{\line{\hss#1}}     \fi
\ifx\undefined\centerline \def\centerline#1{\line{\hss#1\hss}} \fi

% directe commando's

\def\leftaligned {\doalignline \relax \hss  }
\def\midaligned  {\doalignline \hss   \hss  }
\def\rightaligned{\doalignline \hss   \relax}

\let\centeraligned\midaligned

\def\regelbegrensd#1{\limitatetext{#1}{\hsize}{\unknown}} % to be translated

% indirecte commando's

\letvalue{\s!do\v!line\v!left      }\leftaligned
\letvalue{\s!do\v!line\v!right     }\rightaligned
\letvalue{\s!do\v!line\v!middle    }\midaligned
\letvalue{\s!do\v!line\v!flushleft }\rightaligned
\letvalue{\s!do\v!line\v!flushright}\leftaligned
\letvalue{\s!do\v!line\v!center    }\midaligned

\def\doalignedline#1{\csname\s!do\v!line#1\endcsname}

%D Experimental:

\def\doxalignline#1#2#3#4#5#6%
  {\noindentation  % was \noindent
   \dontleavehmode % added in marrakesch at TUG 2006\begingroup
   \begingroup
   \setlocalhsize
   \def\\{\egroup\par\doxalignline#1#2#3#4#5#6\bgroup}% inefficient
   \dowithnextbox
     {%\noindent moved up
      \hbox to \localhsize
        {#1\hskip\ifdone#2\else#3\fi#4%
         \hbox to \localhsize
           {\the\everyleftofalignedline
            \ifcase\alignstrutmode\or\strut\fi
            \ifdone#5\unhbox\nextbox#6\else#6\unhbox\nextbox#5\fi
            \the\everyrightofalignedline}%
         \hss}%
        \endgroup}
     \hbox}

\def\doxcheckline
  {\signalrightpage\doifrightpageelse\donetrue\donefalse}

\setvalue{\s!do\v!line\v!inner      }{\doxalignline\doxcheckline++\zeropoint       \relax\hss  }
\setvalue{\s!do\v!line\v!outer      }{\doxalignline\doxcheckline++\zeropoint       \hss  \relax}
\setvalue{\s!do\v!line\v!innermargin}{\doxalignline\doxcheckline-+\innermargintotal\relax\hss  }
\setvalue{\s!do\v!line\v!outermargin}{\doxalignline\doxcheckline+-\outermargintotal\hss  \relax}
\setvalue{\s!do\v!line\v!inneredge  }{\doxalignline\doxcheckline-+\inneredgetotal  \relax\hss  }
\setvalue{\s!do\v!line\v!outeredge  }{\doxalignline\doxcheckline+-\outeredgetotal  \hss  \relax}
\setvalue{\s!do\v!line\v!backspace  }{\doxalignline\doxcheckline-+\backspace       \relax\hss  }
\setvalue{\s!do\v!line\v!cutspace   }{\doxalignline\doxcheckline+-\cutspace        \hss  \relax}

\setvalue{\s!do\v!line\v!leftmargin }{\doxalignline\donefalse   --\leftmargintotal \hss  \relax}
\setvalue{\s!do\v!line\v!rightmargin}{\doxalignline\donefalse   ++\rightmargintotal\relax\hss  }
\setvalue{\s!do\v!line\v!leftedge   }{\doxalignline\donefalse   --\leftedgetotal   \hss  \relax}
\setvalue{\s!do\v!line\v!rightedge  }{\doxalignline\donefalse   ++\rightedgetotal  \relax\hss  }

% ! ! ! beware, redefining \doalignline gives the wrong results ! ! !
%
% \def\doalignline{\doxalignline\donefalse++\zeropoint}

%D Better:

\def\doalignedline#1{\csname\s!do\v!line#1\endcsname}

\def\alignedline#1#2% setting default
  {\csname\s!do\v!line\ifcsname\s!do\v!line#1\endcsname#1\else#2\fi\endcsname}

%D ...

\def\dosetuptolerance[#1]%
  {\doifinsetelse\v!vertical{#1}%
     {\normalexpanded{\noexpand\processallactionsinset[#1]}
        [  \v!verystrict=>\def\bottomtolerance{},
               \v!strict=>\def\bottomtolerance{.050},
             \v!tolerant=>\def\bottomtolerance{.075},
         \v!verytolerant=>\def\bottomtolerance{.100}]}%
     {\normalexpanded{\noexpand\processallactionsinset[#1]}
        [     \v!stretch=>\emergencystretch\bodyfontsize,
                \v!space=>\spaceskip.5em\!!plus.25em\!!minus.25em\relax,
           \v!verystrict=>\tolerance 200,
               \v!strict=>\tolerance1500,
             \v!tolerant=>\tolerance3000,
         \v!verytolerant=>\tolerance4500]}}

\def\setuptolerance
  {\dosingleargument\dosetuptolerance}

% \def\woordrechts
%   {\groupedcommand{\hfill\hbox}{\parfillskip\zeropoint}}

% beware: \wordright{whatever\kern-\rightskip} should work!
% so, no funny boxing here

\def\dowordright[#1]%
  {% don't change
   \groupedcommand
     {\removeunwantedspaces
      \hfill
      \allowbreak % changed back from \hskip\zeropoint
      \strut
      \hfill
      \quad % decent spacing
      \hbox}
     {\doifelse{#1}\v!right{\kern-\rightskip}{\doifsomething{#1}{\kern-#1}}%
      \parfillskip\zeropoint
     %\finalhyphendemerits\zerocount % yes or no
      \par}}

\def\wordright
  {\dosingleempty\dowordright}

% \dorecurse{5}{something } \wordright{--someone} \endgraf
% \dorecurse{6}{something } \wordright{--someone} \endgraf
% \dorecurse{7}{something } \wordright{--someone} \endgraf
%
% \dorecurse{5}{something } \wordright{--someone else entirely} \endgraf
% \dorecurse{6}{something } \wordright{--someone else entirely} \endgraf
% \dorecurse{7}{something } \wordright{--someone else entirely} \endgraf
%
% \wordright[\rightskip]{whatever}

% \simplealignedbox{2cm}{right}{x}

\setvalue{\s!simple\c!align\v!right      }#1#2{\hbox to #1{#2\hss}}
\setvalue{\s!simple\c!align\v!left       }#1#2{\hbox to #1{\hss#2}}
\setvalue{\s!simple\c!align\v!flushright }#1#2{\hbox to #1{\hss#2}}
\setvalue{\s!simple\c!align\v!flushleft  }#1#2{\hbox to #1{#2\hss}}
\setvalue{\s!simple\c!align\v!middle     }#1#2{\hbox to #1{\hss#2\hss}}

\def\simplealignedbox#1{\executeifdefined{\s!simple\c!align#1}{\getvalue{\s!simple\c!align\v!right}}}

%D \macros
%D   {pushindentation,popindentation}
%D
%D The pushing and popping is done by:

\newbox\indentationboxA
\newbox\indentationboxB

\def\pushindentation
  {\bgroup
   \ifhmode
     \unskip
     \setbox\indentationboxA\lastbox       % get \strut if present
     \unskip
     \setbox\indentationboxB\lastbox       % get \indent generated box
     \unskip
   \else
     \hskip\zeropoint                      % switch to horizontal mode
     \unskip
     \setbox\indentationboxA\lastbox       % get \indent generated box
     \setbox\indentationboxB\emptybox
   \fi}

\def\popindentation
  {\box\indentationboxB\box\indentationboxA % put back the boxes
   \egroup}

%D The only complication lays in \type{\strut}. In \PLAIN\
%D \TEX\ a \type{\strut} is defined as:
%D
%D \starttyping
%D \def\strut%
%D   {\relax\ifmmode\copy\strutbox\else\unhcopy\strutbox\fi}
%D \stoptyping
%D
%D But what is a \type{\strut}? Normally it's a rule of width
%D zero, but when made visual, it's a rule and a negative skip.
%D The mechanism for putting things in the margins described
%D here cannot handle this situation very well. One
%D characteristic of \type{\strut} is that the \type{\unhcopy}
%D results in entering horizontal mode, which in return leads
%D to some indentation.
%D
%D To serve our purpose a bit better, the macro \type{\strut}
%D can be redefined as:
%D
%D \starttyping
%D \def\strut
%D   {\relax\ifmmode\else\hskip0pt\fi\copy\strutbox}
%D \stoptyping
%D
%D Or more compatible:
%D
%D \starttyping
%D \def\strut
%D   {\relax\ifmmode
%D      \copy\strutbox
%D    \else
%D      \bgroup\setbox\strutbox=\normalhbox{\box\strutbox}\unhcopy\strutbox\egroup
%D    \fi}
%D \stoptyping
%D
%D In \CONTEXT\ however we save some processing time by putting
%D an extra \type{\hbox} around the \type{\strutbox}.

% moved from page-lin.tex to here (due to visualization added
% in august 2003)
%
% \unexpanded \def\crlf
%   {\ifhmode\unskip\else\strut\fi\ifcase\raggedstatus\hfil\fi\break}

\unexpanded \def\crlf
  {\ifhmode
     \unskip
     \prewordbreak\crlfplaceholder
     \ifcase\raggedstatus\hfil\or\or\or\hfil\fi
     \break
   \else
     \crlfplaceholder
     \endgraf
   \fi}

\def\crlfplaceholder
  {\strut}

\def\settestcrlf
  {\def\crlfplaceholder
     {\hbox to \zeropoint
        {\strut{\infofont\kern.25em}\lohi{\infofont CR}{\infofont LF}\hss}}}

%D \starttyping
%D % \setuplayout[gridgrid=yes] \showgrid
%D
%D \startbuffer
%D test 1\crlf
%D test 2\crlf
%D
%D \crlf test 3
%D
%D test 4\crlf
%D test 5
%D
%D \crlf
%D \crlf
%D \crlf
%D test 6
%D \stopbuffer
%D
%D \hbox
%D   {\hsize5em
%D    \ruledvtop{\getbuffer}\enspace
%D    \ruledvtop{\showstruts\getbuffer}\enspace
%D    \hsize15em \setuptyping[before=,after=]%
%D    \ruledvtop{\typebuffer}}
%D \stoptyping

\def\justonespace
  {\removelastspace\space} % \removeunwantedspaces\space

\def\ignorecrlf
  {\let\crlf\justonespace\let\\\crlf}

\def\showstruts
  {\setteststrut
   \settestcrlf}

\def\definehspace
  {\dotripleempty\dodefinehspace}

\def\dodefinehspace[#1][#2][#3]% #1 = optional namespace
  {\ifthirdargument
     \setvalue{\??hs#1:#2}{#3}%
   \else
     \setvalue{\??hs:#1}{#2}%
   \fi}

\unexpanded\def\hspace
  {\dodoubleempty\dohspace}

\def\dohspace[#1][#2]%
  {\ifsecondargument
     \dodohspace[#1][#2]%
   \else\iffirstargument
     \hspace[][#1]%
   \else
     \hspace[][\s!default]%
   \fi\fi}

\def\dodohspace[#1][#2]%
  {\ifhmode
     \removeunwantedspaces
     \hskip\hspaceamount{#1}{#2}%
     \expandafter\ignorespaces
    \fi}

\def\hspaceamount#1#2%
  {\executeifdefined{\??hs#1:#2}{\executeifdefined{\??hs:#2}\zeropoint}}

\definehspace [\v!small]   [.25\emspaceamount]
\definehspace [\v!medium]  [.5\emspaceamount]
\definehspace [\v!big]     [1\emspaceamount]
\definehspace [\v!normal]  [1\spaceamount]
\definehspace [\v!default] [\spaceamount]

%D Taken from Taco's math module (cq. \AMS\ macros), but
%D adapted to \type {\hspace}:

\unexpanded\def\textormathspace         #1#2#3{\ifmmode\mskip#1#2\else\kern #1\hspaceamount\empty{#3}\fi\relax}
\unexpanded\def\breakabletextormathspace#1#2#3{\ifmmode\mskip#1#2\else\hskip#1\hspaceamount\empty{#3}\fi\relax}

\newmuskip\hairmuskip \hairmuskip=.15mu

\unexpanded\def\hairspace    {\textormathspace+\hairmuskip{.5}}
\unexpanded\def\thinspace    {\textormathspace+\thinmuskip 1}
\unexpanded\def\medspace     {\textormathspace+\medmuskip  2}
\unexpanded\def\thickspace   {\textormathspace+\thickmuskip3}
\unexpanded\def\neghairspace {\textormathspace-\thinmuskip{.5}}
\unexpanded\def\negthinspace {\textormathspace-\thinmuskip 1}
\unexpanded\def\negmedspace  {\textormathspace-\medmuskip  2}
\unexpanded\def\negthickspace{\textormathspace-\thickmuskip3}

% needed for unicode:

\unexpanded\def\breakablethinspace      {\breakabletextormathspace+\thinmuskip 1}

\unexpanded\def\twoperemspace           {\hskip\dimexpr\emwidth/2\relax} % == \enspace
\unexpanded\def\threeperemspace         {\hskip\dimexpr\emwidth/3\relax}
\unexpanded\def\fourperemspace          {\hskip\dimexpr\emwidth/4\relax}
\unexpanded\def\fiveperemspace          {\hskip\dimexpr\emwidth/5\relax} % goodie
\unexpanded\def\sixperemspace           {\hskip\dimexpr\emwidth/6\relax}
\unexpanded\def\figurespace             {\begingroup\setbox\scratchbox\hbox{0}\hskip\wd\scratchbox\endgroup} % there is a command for this
\unexpanded\def\punctuationspace        {\begingroup\setbox\scratchbox\hbox{.}\hskip\wd\scratchbox\endgroup}
\unexpanded\def\ideographicspace        {\hskip\dimexpr\emwidth/1\relax}
\unexpanded\def\ideographichalffillspace{\hskip\dimexpr\emwidth/2\relax}
%unexpanded\def\nobreakspace            {\penalty\plustenthousand\space}
\unexpanded\def\nobreakspace            {\penalty\plustenthousand\kern\interwordspace}
\unexpanded\def\narrownobreakspace      {\penalty\plustenthousand\thinspace}
%unexpanded\def\zerowidthnobreakspace   {\penalty\plustenthousand\hskip\zeropoint}
\unexpanded\def\zerowidthnobreakspace   {\penalty\plustenthousand\kern\zeropoint}
\unexpanded\def\zerowidthspace          {\hskip\zeropoint}

\definehspace[.5][.1250\emspaceamount] % could also be [.1250\spaceamount]
\definehspace[1] [.1667\emspaceamount]
\definehspace[2] [.2222\emspaceamount]
\definehspace[3] [.2777\emspaceamount]

\let \, \thinspace
\let \: \medspace
\let \; \thickspace
\let \! \negthinspace

% this will become an alternative bunch of \blank settings
%
% \startlines
% \scratchskip=.23pt plus 10pt minus 4pt \relax \number\scratchskip \space \the\scratchskip
% \setsimplifiedskip\scratchskip1 \number\scratchskip \space \the\scratchskip
% \setsimplifiedskip\scratchskip2 \number\scratchskip \space \the\scratchskip
% \getsimplifiedskip\scratchskip\scratchcounter \number\scratchcounter
% \stoplines
%
% \hrule width10cm \endgraf
%   \discardedskip{10pt}
%   \retainedskip  {4pt}
%   \discardedskip {5pt}
% \hrule width10cm \endgraf
%   \blockedskip{0pt}
%   \discardedskip{10pt}
%   \retainedskip  {4pt}
%   \discardedskip {5pt}
% \hrule width10cm \endgraf
%   \frozenskip    {4cm}
% \hrule width10cm \endgraf
%   \vskip10pt
% \hrule width10cm \endgraf

\newskip\simplifiedskip
\newskip\simplifiedcounter

\chardef\@@discardedskip1
\chardef\@@retainedskip 2
\chardef\@@forcedskip   3
\chardef\@@blockedskip  4
\chardef\@@frozenskip   5 % after heads, no break

\def\setsimplifiedskip#1#2%
  {#1\dimexpr(10\dimexpr(#1/10)) plus \gluestretch#1 minus \glueshrink#1\relax
   \advance#1\numexpr(#2)sp\relax}

\def\getsimplifiedskip#1#2%
  {\simplifiedskip#1\relax
   \ifzeropt\simplifiedskip % \ifdim\simplifiedskip=\zeropoint
     #2\zerocount
   \else
     \simplifiedcounter\dimexpr10\dimexpr#1/10\relax\relax
     \advance\simplifiedskip-\simplifiedcounter
     #2\number\simplifiedskip\relax
   \fi}

\def\conditionalskip#1#2%
  {\scratchskip#1\relax
   \setsimplifiedskip\scratchskip#2\relax
   \vskip\scratchskip\relax}

\def\defrostskip
  {\scratchskip\lastskip\penalty50000\normalvskip-\scratchskip\penalty50000\relax}

\def\frozenskip#1%
  {\endgraf
   \ifvmode
     \getsimplifiedskip\lastskip\scratchcounter
     \ifdim\lastskip>#1\else
       \defrostskip
       \conditionalskip{#1}\@@frozenskip
     \fi
   \fi}

\def\discardedskip#1%
  {\endgraf
   \ifvmode
     \getsimplifiedskip\lastskip\scratchcounter
     \ifcase\scratchcounter
       \conditionalskip{#1}\@@discardedskip
     \or % discard
       \ifdim\lastskip>#1\else
         \normalvskip-\lastskip
         \conditionalskip{#1}\@@discardedskip
       \fi
     \or % retain
       \ifdim\lastskip>#1\else
         \normalvskip-\lastskip
         \conditionalskip{#1}\@@discardedskip
       \fi
     \or % forced
       \conditionalskip{#1}\@@discardedskip
     \or % ignored
     \or % frozen
       \ifdim\lastskip>#1\else
         \defrostskip
         \conditionalskip{#1}\@@frozenskip
       \fi
     \else\ifdim#1=\zeropoint\else
       \vskip#1\relax
     \fi\fi
   \fi}

\def\retainedskip#1%
  {\endgraf
   \ifvmode
     \getsimplifiedskip\lastskip\scratchcounter
     \ifcase\scratchcounter
       \conditionalskip{#1}\@@retainedskip
     \or % discard
       \normalvskip-\lastskip
       \conditionalskip{#1}\@@retainedskip
     \or % retain
       \ifdim\lastskip>#1\else
         \normalvskip-\lastskip
         \conditionalskip{#1}\@@retainedskip
       \fi
     \or % forced
       \conditionalskip{#1}\@@retainedskip
     \or % ignored
     \or % frozen
       \ifdim\lastskip>#1\else
         \defrostskip
         \conditionalskip{#1}\@@frozenskip
       \fi
     \else\ifdim#1=\zeropoint\else
       \vskip#1\relax
     \fi\fi
  \fi}

\def\forcedskip#1%
  {\endgraf
   \ifvmode
     \conditionalskip{#1}\@@forcedskip
   \fi}

\def\blockedskip#1%
  {\endgraf
   \ifvmode
     \getsimplifiedskip\lastskip\scratchcounter
     \ifcase\scratchcounter
       \conditionalskip{#1}\@@blockedskip
     \or % discard
       \conditionalskip{#1}\@@blockedskip
     \or % retain
       \conditionalskip{#1}\@@blockedskip
     \or % forced
       \conditionalskip{#1}\@@blockedskip
     \or % ignored
     \or % frozen
       \ifdim\lastskip>#1\else
         \defrostskip
         \conditionalskip{#1}\@@frozenskip
       \fi
     \else\ifdim#1=\zeropoint\else
       \vskip#1\relax
     \fi\fi
   \fi}

% beware, changing this will break some code (like pos/backgrounds)

\newtoks\everyfirstparagraphintro
\newtoks\everynextparagraphintro
\newtoks\@@everyparagraphtoks

\chardef\everyparagraphintro\zerocount

\def\setupparagraphintro
  {\dodoubleempty\dosetupparagraphintro}

\def\dosetupparagraphintro[#1][#2]%
  {\processallactionsinset
     [#1]
     [   \v!reset=>\global\chardef\everyparagraphintro\zerocount
                   \global\everyfirstparagraphintro\emptytoks
                   \global\everynextparagraphintro \emptytoks,
         \v!first=>\global\chardef\everyparagraphintro\plusone
                   \doglobal\appendtoks#2\to\everyfirstparagraphintro,
          \v!next=>\ifcase\everyparagraphintro\global\chardef\everyparagraphintro\plusone\fi
                   \doglobal\appendtoks#2\to\everynextparagraphintro,
          \v!each=>\ifcase\everyparagraphintro\global\chardef\everyparagraphintro\plustwo\fi
                   \doglobal\appendtoks#2\to\everyfirstparagraphintro
                   \doglobal\appendtoks#2\to\everynextparagraphintro]}

%D We can say:
%D
%D \starttyping
%D \setupparagraphintro[first][\index{Knuth}]
%D \stoptyping
%D
%D Maybe more convenient is:
%D
%D \starttyping
%D \flushatparagraph{\index{Zapf}}
%D \stoptyping

\def\flushatparagraph#1%
  {\global\chardef\everyparagraphintro\plusone
   \global\appendtoks{#1}\to\everyfirstparagraphintro
   \global\let\insertparagraphintro\doinsertparagraphintro}

\def\doinsertparagraphintro % can be merged with the next
  {\ifcase\everyparagraphintro\else\@EA\dodoinsertparagraphintro\fi}

\def\dodoinsertparagraphintro
  {\begingroup
   \everypar\emptytoks
   \ifcase\everyparagraphintro\relax
     % no data
     \@@everyparagraphtoks\emptytoks
   \or
     % first data
     \global\chardef\everyparagraphintro\plustwo
     \@@everyparagraphtoks\everyfirstparagraphintro
     \global\everyfirstparagraphintro\emptytoks
   \or
     % next data
     \@@everyparagraphtoks\everynextparagraphintro
   \fi
   \the\@@everyparagraphtoks
   \global\let\insertparagraphintro\relax
   \endgroup}

\let\insertparagraphintro\relax

%D \starttyping
%D \setupparagraphintro[first][\hbox to 3.5em{\tt FIRST \hss}]
%D \setupparagraphintro[first][\hbox to 3.5em{\tt TSRIF \hss}]
%D \setupparagraphintro[next] [\hbox to 3.5em{\tt NEXT  \hss}]
%D \setupparagraphintro[next] [\hbox to 3.5em{\tt TXEN  \hss}]
%D \setupparagraphintro[each] [\hbox to 3.0em{\tt EACH  \hss}]
%D \setupparagraphintro[each] [\hbox to 3.0em{\tt HCEA  \hss}]
%D
%D some paragraph \par
%D some paragraph \par
%D some paragraph \par
%D
%D \definelabel[parnumber]
%D
%D \setupparagraphintro[reset,each][\inleft{\slxx\parnumber}]
%D
%D some paragraph \par
%D some paragraph \par
%D some paragraph \par
%D \stoptyping

%D \macros
%D   {flushatnextpar}
%D
%D This macro collects data that will be flushed at the next paragraph.
%D By using this macro you can avoid interfering nodes (writes, etc).

\newbox\postponednodedata
\let\flushpostponednodedata\relax

\def\flushatnextpar
  {\bgroup
   \global\let\flushpostponednodedata\doflushpostponednodedata
   \dowithnextbox{\global\setbox\postponednodedata\hbox{\box\postponednodedata\box\nextbox}\egroup}\hbox}

\def\doflushpostponednodedata
  {\ifvoid\postponednodedata\else
     \hbox{\smashedbox\postponednodedata}%
   \fi
   \global\let\flushpostponednodedata\relax}

% Very nasty but needed for margin stuff inside colored
% paragraphs.

\let\normalvadjust\vadjust

% \def\graphicvadjust % bad, those low level color calls here
%   {\dowithnextboxcontent
%      {\forgetall}
%      {\normalvadjust
%         {\unvbox\nextbox
%          % corrects for one line paragraphs
%          \nointerlineskip
%          \kern-\struttotal
%          \nointerlineskip
%          \verticalstrut}}%
%      \vbox}

\def\graphicvadjust % nasty bidi handling
  {\dowithnextboxcontent
     {\forgetall}
     {\vadjust{\vbox attr \graphicvadjustattribute \plusone
        {\unvbox\nextbox
         % corrects for one line paragraphs
         \nointerlineskip
         \kern-\struttotal
         \nointerlineskip
         \verticalstrut}}}%
     \vbox}

%D This works only in a properly strutted line, and is meant
%D for deeply burried operations, like in heads.

\def\fakedvadjust
  {\dowithnextbox
     {\setbox\nextbox\hbox{\llap{\lower\strutdepth\box\nextbox}}%
      \smashedbox\nextbox}%
   \vtop}

\def\flexiblespaceamount#1#2#3%
         {#1\interwordspace
   \!!plus#2\interwordstretch
  \!!minus#3\interwordshrink}

\def\fixedspaceamount#1%
  {#1\interwordspace}

%D This is a dangerous feature because it makes the \TEX\ source
%D less portable, i.e. any parser now needs to apply exactly the
%D same algorithm when it wants to interpret the source. We
%D strongly recommend not to mention this feature in manuals! It's
%D provided for users who are hooked to such a mechanism.
%D
%D \starttyping
%D \setupsorting[logo][next=\autoinsertnextspace] \logo[TEX]{\TeX}
%D
%D bla bla \TEX bla bla \TEX (bla) bla (\TEX)
%D \stoptyping

\def\autoinsertnextspace{\futurelet\nexttoken\doautoinsertnextspace}

\def\doautoinsertnextspace % slightly extended version of a user supplied macro
  {\ifx\nexttoken \bgroup\else \ifx\nexttoken\begingroup\else
   \ifx\nexttoken \egroup\else \ifx\nexttoken  \endgroup\else
   \ifx\nexttoken      \/\else \ifx\nexttoken           /\else \ifx\nexttoken      ~\else
   \ifx\nexttoken      \ \else \ifx\nexttoken \blankspace\else \ifx\nexttoken \space\else
   \ifx\nexttoken       .\else \ifx\nexttoken           ,\else
   \ifx\nexttoken       !\else \ifx\nexttoken           ?\else
   \ifx\nexttoken       :\else \ifx\nexttoken           ;\else
   \ifx\nexttoken       '\else \ifx\nexttoken           "\else
   \ifx\nexttoken       )\else \ifx\nexttoken           -\else \ifx\nexttoken      |\else
   \ifx\nexttoken      \%\else \ifx\nexttoken          \&\else
     \space
   \fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi}

% moved from page-lin

\def\installspacehandler#1#2% needs to set \obeyedspace
  {\setvalue{\??sr#1}{#2}}

\installspacehandler \v!on
  {\obeyspaces
   \def\obeyedspace{\mathortext\normalspace{\dontleavehmode{\tt\controlspace}}}%
   \let\ =\obeyedspace}

\installspacehandler \v!yes
  {\obeyspaces
   \def\obeyedspace{\mathortext\normalspace{\dontleavehmode    \normalspace  }}%
   \let\ =\obeyedspace}

\installspacehandler \v!off
  {\normalspaces
   \let\obeyedspace\normalspace
   \let\ =\normalspace}

\installspacehandler \v!fixed
  {\obeyspaces
   \def\obeyedspace{\mathortext\normalspace{\dontleavehmode\fixedspace}}%
   \let\ =\obeyedspace}

\def\activatespacehandler#1%
  {\executeifdefined{\??sr#1}{\activatespacehandler\v!off}}

% moved from page-lin

%D When spacing is active we need to handle commands in
%D a special way:
%D
%D \starttyping
%D \setuplines[space=on]
%D
%D \startlines
%D Let's talk about this{\ttsl\gobbleoneargument or}that.
%D \stoplines
%D
%D \startlines
%D Let's talk about this{\getvalue{ttsl}or}that.
%D \stoplines
%D \stoptyping
%D
%D One can indent in several ways:
%D
%D \starttyping
%D \setupindenting[medium] \setuplines[indenting=odd] % no yes odd even
%D
%D \startlines
%D first
%D second
%D third
%D fourth
%D \stoplines
%D \stoptyping

\def\setuplines
  {\dodoubleargument\getparameters[\??rg]}

\def\startlines
  {\@@rgbefore
   \pushmacro\checkindentation
   \whitespace
  %\page[\v!preference]} gaat mis na koppen, nieuw: later \nobreak
   \begingroup
   \setupindenting[\@@rgindenting]%
   \typesettinglinestrue
   \setupwhitespace[\v!none]%
   \obeylines
   \ignorespaces
   \gdef\afterfirstobeyedline % tzt two pass, net als opsomming
     {\gdef\afterfirstobeyedline
        {\nobreak
         \doifnot\@@rgoption\v!packed{\global\let\afterfirstobeyedline\relax}}}%
   \def\obeyedline
     {\par
      \futurelet\next\dobetweenthelines}%
   \activatespacehandler\@@rgspace
   \GotoPar}

\def\stoplines
  {\endgroup
   \popmacro\checkindentation
   \@@rgafter}

\def\dobetweenthelines
  {\doifmeaningelse\next\obeyedline
    {\@@rginbetween}
    {\afterfirstobeyedline}}

\setuplines
  [\c!option=,
   \c!before=\blank,
   \c!after=\blank,
   \c!inbetween=\blank,
   \c!indenting=\v!no,
   \c!space=\v!default]

\def\emptylines
  {\dosingleempty\doemptylines}

\def\doemptylines[#1]%
  {\endgraf\dorecurse{\iffirstargument#1\else3\fi}\crlf}

\setupwhitespace
  [\v!none]

% still old-fashioned

\indenting
  [\v!never]

\setupindenting
  [\v!none]

\setupblank
  [\v!standard,
   \v!big]

\defineblank[\v!default]  [\currentblank]
\defineblank[\v!before]   [\v!default]
\defineblank[\v!inbetween][\v!default]
\defineblank[\v!after]    [\v!before]

\setupinterlinespace
  [\c!minheight=0pt, % only special purpose
   \c!mindepth=0pt, % only special purpose
   \c!height=.72,
   \c!depth=.28,
   \c!top=1.0,
   \c!bottom=0.4,
   \c!distance=1pt,
   \c!line=2.8ex,
   \c!stretch=0]

\setupnarrower
  [\c!before=\endgraf,
   \c!after=\endgraf,
   \c!left=1.5em,
   \c!right=1.5em,
   \c!middle=1.5em]

\setuptolerance
  [\v!horizontal,\v!verystrict]

\setuptolerance
  [\v!vertical,\v!strict]

\setupalign
  [\v!bottom,
   \v!width]

\setupspacing
  [\v!packed]

\protect \endinput

\dorecurse{2}{
    $2^{2^{2^{2}}}$ $2_{2_{2_{2}}}^{2^{2^{2^{2^{2^{2^{2^{2^{2}}}}}}}}}$
    \input tufte \inframed {tufte}
    \par
}

\dorecurse{100} {

    \kern \recurselevel pt

    \vbox {
        \endgraf \strut first \endgraf
        {\dosetattribute{skip-category}{1}\vskip10pt}
        {\dosetattribute{skip-category}{1}\vskip40pt}
        {\dosetattribute{skip-category}{1}\vskip20pt}
        {\dosetattribute{skip-category}{2}\vskip10pt}
        \endgraf \strut second \endgraf
    }

    \endgraf \strut first \endgraf
    {\dosetattribute{skip-category}{1}\vskip10pt}
    {\dosetattribute{skip-category}{1}\vskip40pt}
    {\dosetattribute{skip-category}{1}\vskip20pt}
    {\dosetattribute{skip-category}{1}\vskip40pt}
    \endgraf \strut second \endgraf

    {\dosetattribute{skip-category}{0}\vskip10pt} % remove
    {\dosetattribute{skip-category}{1}\vskip10pt} % take largest
    {\dosetattribute{skip-category}{1}\vskip40pt}
    {\dosetattribute{skip-category}{1}\vskip40pt}
    {\dosetattribute{skip-category}{1}\vskip40pt}
    {\dosetattribute{skip-category}{1}\vskip40pt}
    {\dosetattribute{skip-category}{1}\vskip40pt}
    {\dosetattribute{skip-category}{1}\dosetattribute{skip-order}{10}\vskip20pt}
    {\dosetattribute{skip-category}{4}\dosetattribute{skip-order}{10}\vskip20pt}
    {\dosetattribute{skip-category}{1}\vskip60pt}
    {\dosetattribute{skip-category}{1}\vskip20pt}
    {\dosetattribute{skip-category}{0}\vskip10pt}

    third (no break after this)

    {\dosetattribute{skip-category}{1}\dosetattribute{skip-penalty}{100000}\vskip10pt}
    {\dosetattribute{skip-category}{1}\dosetattribute{skip-penalty}{100000}\vskip20pt}
    {\dosetattribute{skip-category}{1}\vskip10pt}
    {\dosetattribute{skip-category}{1}\vskip20pt}

    fourth
    \vskip10pt
    fifth
}
