%D \module
%D   [       file=core-spa,
%D        version=1997.03.31,
%D          title=\CONTEXT\ Core Macros,
%D       subtitle=Spacing,
%D         author=Hans Hagen,
%D           date=\currentdate,
%D      copyright={PRAGMA / Hans Hagen \& Ton Otten}]
%C
%C This module is part of the \CONTEXT\ macro||package and is
%C therefore copyrighted by \PRAGMA. See mreadme.pdf for
%C details.

\writestatus{loading}{Context Spacing Macros}

\unprotect

\newevery \everybodyfont    \Everybodyfont   % just to be sure
\newevery \everyfontswitch  \EveryFontSwitch % just to be sure
\newevery \everydefinedfont \relax           % just to be sure

\appendtoks \presetnormallineheight \to \everybodyfont
\appendtoks \setnormalbaselines     \to \everybodyfont
\appendtoks \setstrut               \to \everybodyfont
\appendtoks \settopskip             \to \everybodyfont
\appendtoks \setmaxdepth            \to \everybodyfont
\appendtoks \spacing               1\to \everybodyfont
\appendtoks \simplesetupindenting   \to \everybodyfont
\appendtoks \simplesetupblank       \to \everybodyfont
\appendtoks \simplesetupwhitespace  \to \everybodyfont
%appendtoks \checknotes             \to \everybodyfont % not
\appendtoks \simplesetupspacing     \to \everybodyfont % nieuw
\appendtoks \setdisplayskips        \to \everybodyfont % nieuw

\appendtoks \updateraggedskips \to \everyfontswitch  % under test

\prependtoks \let\par\endgraf \to \everypagebody % see \fillinline

\appendtoks \simplesetupspacing \to \everydefinedfont

\def\stelfactorenin
  {\simplesetupwhitespace
   \simplesetupblank
   \settopskip
   \setmaxdepth}

\def\softbreak
  {\relax\ifhmode\hskip\parfillskip\break\fi}

%D The dreadful sequence \type {\bgroup} \unknown\
%D \type {\carryoverpar} \unknown\ \type {\egroup} is needed
%D when for instance sidefloats are used in combination with
%D something that starts with a group. This is because
%D otherwise the indentation as set (by the output routine)
%D inside the group are forgotten afterwards. (I must
%D not forget its existence).

\global\let\carriedoverpar\relax

\def\carryoverpar#1%
  {\expanded
     {\noexpand#1%
      \hangindent\the\hangindent
      \hangafter \the\hangafter
      \parskip   \the\parskip
      \leftskip  \the\leftskip
      \rightskip \the\rightskip}}

%D A quick way to determine left|/|middle|/|right states
%D (experimental).

\setvalue{\??as\v!links }{0}
\setvalue{\??as\v!midden}{1}
\setvalue{\??as\v!rechts}{2}

\def\setalignmentswitch#1%
  {\chardef\alignmentswitch0\csname\??as#1\endcsname\relax}

%D There are two ways to influence the interline spacing. The
%D most general and often most consistent way is using
%D
%D \showsetup{\y!setupinterlinespace}
%D
%D For instance
%D
%D \starttypen
%D \setupinterlinespace[line=2.8ex]
%D \stoptypen
%D
%D This setting adapts itself to the bodyfontsize, while for
%D instance saying
%D
%D \starttypen
%D \setupinterlinespace[line=12pt]
%D \stoptypen
%D
%D sets things fixed for all sizes, which is definitely not
%D what we want. Therefore one can also say:
%D
%D \starttypen
%D \definebodyfontenvironment[9pt][interlinespace=11pt]
%D \stoptypen
%D
%D One can still use \type{\setupinterlinespace} (without
%D arguments) to set the interline space according to the
%D current font, e.g. a \type{\bfa}.

\newif\iflocalinterlinespace

% font-ini

\ifx\bodyfontinterlinespecs\undefined

  \let\bodyfontinterlinespecs\empty
  \let\bodyfontinterlinespace\empty

\fi

\def\presetnormallineheight
  {\edef\normallineheight{\@@itregel}%
   \iflocalinterlinespace \else
     \doifdefined\bodyfontinterlinespecs
       {\doifsomething\bodyfontinterlinespace
          {\edef\normallineheight{\bodyfontinterlinespace}}}%
   \fi}

\def\setupspecifiedinterlinespace[#1]%
  {\getparameters[\??it][#1]%
   \scratchdimen0\@@ithoogte\s!pt
   \advance\scratchdimen 0\@@itdiepte\s!pt
   \ifdim\scratchdimen>1\s!pt
     \showmessage\m!layouts{10}{\@@ithoogte,\@@itdiepte}%
     \let\@@ithoogte\strutheightfactor
     \let\@@itdiepte\strutdepthfactor
   \else
     \let\strutheightfactor\@@ithoogte
     \let\strutdepthfactor \@@itdiepte
   \fi
   \let\minimallinedistance\@@itafstand
   \let\normallineheight\@@itregel % let ! ! ! ! ! ivm ex
   \let\topskipfactor\@@itboven
   \let\maxdepthfactor\@@itonder
   \let\baselinegluefactor\@@itrek
   \setfontparameters % redundant, can be \setstrut, test first
   \updateraggedskips} % yes indeed

\def\setuprelativeinterlinespace[#1]%
  {\processallactionsinset % \regelwit = dummy !
     [#1]
     [     \v!aan=>\oninterlineskip,
           \v!uit=>\offinterlineskip,
         \v!reset=>\setfontparameters,% just \setstrut, test first
       \s!unknown=>\assignvalue{#1}\regelwit{1.00}{1.25}{1.50}%
                   \spacing\regelwit]}

\def\complexsetupinterlinespace[#1]% \commalistelement ipv #1
  {\doifassignmentelse{#1}
     \setupspecifiedinterlinespace\setuprelativeinterlinespace[#1]}

\def\setuplocalinterlinespace[#1]%
  {\localinterlinespacetrue
   \setupinterlinespace[#1]%
   \localinterlinespacefalse}

\def\simplesetupinterlinespace
  {\localinterlinespacetrue
   \setfontparameters
   \updateraggedskips % funny one here
   \localinterlinespacefalse}

\definecomplexorsimple\setupinterlinespace

% In earlier versions \type{\bigskipamount} was
% \type{\ht\strutbox} and the stretch was plus or minus
% \type{.4\dp\strutbox}. Don't ask me why. The most recent
% implementation is based on a user supplied distance, which
% is by default \type{.75\normalskipamount} where
% \type{\normalskipamount} equals the current baseline
% distance.

\newif\ifblankoreset        \blankoresetfalse
\newif\ifblankoblokkeer     \blankoblokkeerfalse
\newif\ifblankogeenwit      \blankogeenwitfalse
\newif\ifdoeblanko          \doeblankofalse
\newif\ifblankoflexibel     \blankoflexibeltrue
\newif\ifblankobuiten
\newif\ifblankoforceer

\newskip\blankoskip         \blankoskip=\bigskipamount
\newskip\blankoskipamount

\def\skipfactor    {.75}
\def\skipgluefactor{.25}

\def\normalskipamount
  {\openlineheight
     \ifgridsnapping \else \ifblankoflexibel
       \!!plus\skipgluefactor\openlineheight
       \!!minus\skipgluefactor\openlineheight
     \fi \fi
   \relax}

\def\regelafstand{\normalskipamount}

\def\deblankoskip{\skipfactor\regelafstand}

\def\laatsteblankoskip
  {\blankoskip}

\def\geenblanko
  {\removelastskip}

\def\currentblanko
  {\v!groot}

\def\oldprevdepth {\prevdepth}
\def\newprevdepth {-1001pt}
\def\mindimen     {1sp} % was: 0.00002pt

\newif\iflokaalblankovast
\newif\iflokaalblankoflexibel
\newif\iffuzzyvskip

%%%% pas op, wordt ook in core-pos gebruikt

\def\doassignsomeskip#1\to#2% ook nog \v!halveregel+fuzzysnap
  {\doifelse{#1}\v!regel
     {#2\openlineheight}
     {\ifgridsnapping
        \assigndimension{#1}{#2}%
          {.25\openlineheight}{.5\openlineheight}\openlineheight
      \else
        \assigndimension{#1}{#2}%
          \smallskipamount\medskipamount\bigskipamount
      \fi}}

%%%% dus niet weg

% replaced
%
% \def\dosingleblanko#1%
%   {\doassignsomeskip#1\to\blankoskipamount
%    \global\advance\blankoskip \blankoskipamount}
%
% \def\doblanko#1%
%   {\processallactionsinset % is maar een actie
%      [#1]
%      [    \v!groot=>\dosingleblanko\v!groot, % happens often
%          \v!buiten=>\ifvmode\ifinner\blankobuitentrue\fi\fi,
%           \v!reset=>\global\blankoresettrue,
%        \v!flexibel=>\global\lokaalblankoflexibeltrue,
%            \v!vast=>\global\lokaalblankovasttrue,
%            \v!back=>\geenblanko,
%             \v!wit=>\global\advance\blankoskip \parskip,
%         \v!formule=>\global\advance\blankoskip \medskipamount,
%         \v!geenwit=>\global\blankogeenwittrue,
%            -\v!wit=>\global\advance\blankoskip -\parskip,
%        \v!blokkeer=>\global\blankoblokkeertrue,
%         \v!forceer=>\global\blankoforceertrue,
%           \v!regel=>\global\advance\blankoskip \lineheight,
%      \v!halveregel=>\ifgridsnapping\global\fuzzyvskiptrue\fi
%                     \global\advance\blankoskip .5\lineheight,
%         \s!unknown=>\doindirectblanko{#1}]}
%
% \def\docomplexdoblanko[#1]% pas op \relax's zijn nodig ivm volgende \if
%   {\global\blankoresetfalse
%    \global\blankoblokkeerfalse
%    \global\blankogeenwitfalse
%    \global\lokaalblankoflexibelfalse
%    \global\lokaalblankovastfalse
%    \global\blankoskip\zeropoint
%    \global\blankoforceerfalse
%    \blankobuitenfalse
%    \processcommalist[#1]\doblanko
%    \ifdim\blankoskip=\zeropoint\relax
%      \iflokaalblankoflexibel \dosingleblanko\currentblanko \fi
%      \iflokaalblankovast     \dosingleblanko\currentblanko \fi
%    \fi
%    \ifblankobuiten
%    \else
%      \par
%      \ifvmode          %in pos fonts gaat dit mis
%        \ifblankoforceer%\ifdim\prevdepth>\zeropoint\else
%          % -1000pt signals top of page or column (\ejectcolumn)
%          \verticalstrut\kern-\struttotal
%        \fi
%        \ifblankoblokkeer
%          \global\doeblankofalse
%          \edef\oldprevdepth{\the\prevdepth}%
%          \prevdepth=\newprevdepth
%        \else
%          \global\doeblankotrue
%        \fi
%        \ifblankoreset
%          \global\doeblankotrue
%          \ifdim\prevdepth=\newprevdepth
%            \prevdepth=\oldprevdepth
%          \fi
%        \fi
%        \ifdoeblanko
%          \ifdim\lastskip<\blankoskip\relax
%            % else when \blanko[2*groot] + \blanko[3*groot] with parskip
%            % equaling 1*groot, gives a groot=\parskip so adding a small
%            % value makes it distinguishable; can also be done at parskip
%            % setting time (better)
%            \global\advance\blankoskip by \mindimen\relax % = skip
%            % test this on 2* + 3* and parskip groot
%            \ifblankogeenwit
%              \global\advance\blankoskip by -\parskip
%            \else
%              \ifdim\lastskip=\parskip
%              \else  % force this due to previous comment
%                \ifdim\parskip>\zeropoint\relax
%                  \ifdim\blankoskip<\parskip\relax
%                    \global\blankoskip\zeropoint
%                  \else
%                    \global\advance\blankoskip by -\parskip
%                  \fi
%                \fi
%              \fi
%            \fi
%            \ifblankoflexibel \else
%              \blankoskip=1\blankoskip
%            \fi
%            \iflokaalblankovast
%              \blankoskip=1\blankoskip
%            \fi
%            \iflokaalblankoflexibel
%              \blankoskip=1\blankoskip
%                \!!plus\skipgluefactor\blankoskip
%                \!!minus\skipgluefactor\blankoskip
%            \fi
%            \ifdim\prevdepth=\newprevdepth
%            \else
%              \iffuzzyvskip
%                \removelastfuzzyvskip
%                \fuzzyvskip\blankoskip\relax
%              \else
%                \removelastskip
%                \vskip\blankoskip\relax
%              \fi
%            \fi
%          \else
%            \iffuzzyvskip
%              \removelastfuzzyvskip
%              \fuzzyvskip\blankoskip\relax
%            \fi
%          \fi
%        \fi
%      \fi
%    \fi
%    \global\fuzzyvskipfalse
%    \presetindentation}
%
% \def\complexdodoblanko[#1]%
%   {\flushnotes
%    \ifopelkaar
%      \ifinpagebody
%        \expanded{\docomplexdoblanko[#1]}% \expanded=nieuw
%      \else
%        \par
%      \fi
%    \else
%      \expanded{\docomplexdoblanko[#1]}% \expanded = nieuw
%    \fi}
%
% % old
% %
% % \def\doindirectblanko#1%
% %   {\ifundefined{\??bo#1}% <-etex \expandafter\ifx\csname\??bo#1\endcsname\relax
% %      \expanded{\complexdodoblanko[#1]}%
% %    \else
% %      \expandafter\complexdoblanko\expandafter[\csname\??bo#1\endcsname]%
% %    \fi}
% %
% % \def\complexdoblanko[#1]% enables [force,8\bodyfontsize]
% %   {\doifinstringelse{,}{#1}
% %      {\expanded{\complexdodoblanko[#1]}}
% %      {\doifnumberelse{#1}
% %         {\expanded{\complexdodoblanko[#1]}}
% %         {\doindirectblanko{#1}}}}
% %
% % new, more robust
% %
% % \def\doindirectblanko#1%
% %   {\edef\ascii{#1}\convertcommand\ascii\to\ascii
% %    \ifundefined{\??bo\ascii}% <-etex \expandafter\ifx\csname\??bo#1\endcsname\rel
% %      \herhaalmetcommando[#1]\dosingleblanko
% %    \else
% %      \expandafter\complexdoblanko\expandafter[\csname\??bo\ascii\endcsname]%
% %    \fi}
% %
% % even more robust
%
% \def\doindirectblanko#1%
%   {\edef\ascii{#1}\convertcommand\ascii\to\ascii
%    \ifundefined{\??bo\ascii}% <-etex \expandafter\ifx\csname\??bo#1\endcsname
%      \expanded{\herhaalmetcommando[#1]\noexpand\dosingleblanko}%
%    \else
%      \expandafter\complexdoblanko\expandafter[\csname\??bo\ascii\endcsname]%
%    \fi}

% \def\TestBlank[#1]%
%   {blank : {\convertargument#1\to\ascii\tttf\ascii}\blanko[#1]}
%
% \defineblank[whatever][2*big,2*big]
% \TestBlank[]
% \TestBlank[big]
% \TestBlank[2*big]
% \TestBlank[big,big,2*big]
% \TestBlank[big]
% \TestBlank[whatever]
% \TestBlank[2*big,whatever]
% \TestBlank[3\lineheight]

\def\addblankskip#1#2#3%
  {\global\advance\blankoskip#1\ifgridsnapping#3\else#2\fi}

\def\defineblankmethod[#1]#2{\setvalue{\??bo\??bo#1}{#2}}

\defineblankmethod   [\v!groot]{\addblankskip+\bigskipamount      \openlineheight}
\defineblankmethod  [-\v!groot]{\addblankskip-\bigskipamount      \openlineheight}
\defineblankmethod  [\v!middel]{\addblankskip+\medskipamount   {.5\openlineheight}}
\defineblankmethod [-\v!middel]{\addblankskip-\medskipamount   {.5\openlineheight}}
\defineblankmethod   [\v!klein]{\addblankskip+\smallskipamount{.25\openlineheight}}
\defineblankmethod  [-\v!klein]{\addblankskip-\smallskipamount{.25\openlineheight}}
\defineblankmethod     [\v!wit]{\addblankskip+\parskip\openlineheight}
\defineblankmethod    [-\v!wit]{\addblankskip-\parskip\openlineheight}
\defineblankmethod   [\v!regel]{\addblankskip+\openlineheight\openlineheight}
\defineblankmethod  [-\v!regel]{\addblankskip-\openlineheight\openlineheight}

\defineblankmethod [\v!formule    ]{\global\advance\blankoskip\medskipamount}
\defineblankmethod [\v!geenwit    ]{\global\blankogeenwittrue}
\defineblankmethod [\v!blokkeer   ]{\global\blankoblokkeertrue}
\defineblankmethod [\v!forceer    ]{\global\blankoforceertrue}
\defineblankmethod [\v!buiten     ]{\ifvmode\ifinner\blankobuitentrue\fi\fi}
\defineblankmethod [\v!reset      ]{\global\blankoresettrue}
\defineblankmethod [\v!flexibel   ]{\global\lokaalblankoflexibeltrue}
\defineblankmethod [\v!vast       ]{\global\lokaalblankovasttrue}
\defineblankmethod [\v!back       ]{\geenblanko}
\defineblankmethod [\v!halveregel ]{\ifgridsnapping\global\fuzzyvskiptrue\fi
                                    \global\advance\blankoskip .5\lineheight}

\defineblankmethod [\v!geen       ]{\global\blankoresettrue}
\defineblankmethod [\v!aansluitend]{\ifvmode\nointerlineskip\fi}

% happens often

\defineblankmethod [2*\v!groot]{\addblankskip+{2\bigskipamount}{2\openlineheight}}

% ETEX ! ! !

\beginETEX \ifcsname

\def\doblanko#1%
  {\edef\ascii{#1}\convertcommand\ascii\to\ascii
   \ifx\ascii\empty\else
     \ifcsname\??bo\??bo\ascii\endcsname % internal def
       \csname\??bo\??bo\ascii\endcsname
     \else\ifcsname\??bo\ascii\endcsname % user def / slow
       \@EA\rawprocesscommalist\@EA[\csname\??bo\ascii\endcsname]\doblanko\relax
     \else
       \dorepeatwithcommand[#1]\redoblanko
     \fi\fi
   \fi}

\def\redoblanko#1%
  {\edef\ascii{#1}\convertcommand\ascii\to\ascii
   \ifx\ascii\empty\else
     \ifcsname\??bo\??bo\ascii\endcsname % internal def
       \csname\??bo\??bo\ascii\endcsname
     \else\ifcsname\??bo\ascii\endcsname % user def / slow
       \@EA\rawprocesscommalist\@EA[\csname\??bo\ascii\endcsname]\doblanko\relax
     \else
       \global\advance\blankoskip#1\relax
     \fi\fi
   \fi}

\endETEX

\beginTEX

\def\doblanko#1%
  {\edef\ascii{#1}\convertcommand\ascii\to\ascii
   \ifx\ascii\empty\else
     \@EA\ifx\csname\??bo\??bo\ascii\endcsname\relax
       \@EA\ifx\csname\??bo\ascii\endcsname\relax
         \dorepeatwithcommand[#1]\redoblanko
       \else
         \@EA\rawprocesscommalist\@EA[\csname\??bo\ascii\endcsname]\doblanko\relax
       \fi
     \else
       \csname\??bo\??bo\ascii\endcsname
     \fi
   \fi}

\def\redoblanko#1%
  {\edef\ascii{#1}\convertcommand\ascii\to\ascii
   \ifx\ascii\empty\else
     \@EA\ifx\csname\??bo\??bo\ascii\endcsname\relax
       \@EA\ifx\csname\??bo\ascii\endcsname\relax
         \global\advance\blankoskip#1\relax
       \else
         \@EA\rawprocesscommalist\@EA[\csname\??bo\ascii\endcsname]\doblanko\relax
       \fi
     \else
       \csname\??bo\??bo\ascii\endcsname
     \fi
   \fi}

\endTEX

\unexpanded\def\blanko % the \relax is definitely needed due to the many \if's
  {\relax\complexorsimple\doblanko}

\def\complexdoblanko
  {\flushnotes
   \ifmmode
     \let\next\nocomplexdoblanko
   \else
     \ifopelkaar
       \ifinpagebody
         \let\next\docomplexdoblanko
       \else
         \let\next\nocomplexdoblanko
       \fi
     \else
       \let\next\docomplexdoblanko
     \fi
   \fi
   \next}

\def\nocomplexdoblanko[#1]%
  {% evt blokkeerfalse
   \ifmmode\else\par\fi}

% Overloaded in cont-new!

\newsignal\noblanksignal

\def\docomplexdoblanko[#1]% pas op \relax's zijn nodig ivm volgende \if
  {\global\blankoresetfalse
   \global\blankoblokkeerfalse
   \global\blankogeenwitfalse
   \global\lokaalblankoflexibelfalse
   \global\lokaalblankovastfalse
   \global\blankoskip\zeropoint
   \global\blankoforceerfalse
   \blankobuitenfalse
   \expanded{\rawprocesscommalist[#1]}\doblanko
   \ifdim\blankoskip=\zeropoint\relax
     \iflokaalblankoflexibel
       \doglobal\advance\blankoskip \currentblanko
     \else\iflokaalblankovast
       \doglobal\advance\blankoskip \currentblanko
     \fi\fi
   \fi
   \ifblankobuiten
   \else
     \par
     \ifvmode          %in pos fonts gaat dit mis
       \ifblankoforceer%\ifdim\prevdepth>\zeropoint\else
         % -1000pt signals top of page or column (\ejectcolumn)
         \bgroup\forgeteverypar\verticalstrut\egroup\kern-\struttotal
       \fi
       \ifblankoblokkeer
         \global\doeblankofalse
         \ifgridsnapping
           \ifdim\prevdepth<\zeropoint
             % brrr
           \else
             % dirty trick: smaller blanks are ignored after
             % a larger one, so 10 lines is probably safe; first make
             % sure that we honor penalties
             \scratchcounter\lastpenalty
             % now comes the trick (cross our fingers that this works
             % well in multi columns; maybe an ifinner test is needed
             % \vskip-10\lineheight
             %    \ifnum\scratchcounter=\zerocount \else \penalty\lastpenalty \fi
             %    \vskip 10\lineheight
             % allas, this leads to overfull pages, so we try this:
             \kern-\noblanksignal
             \ifnum\scratchcounter=\zerocount
             \else
               \penalty\lastpenalty
             \fi
             \kern\noblanksignal
             % end-of-dirty-trick
           \fi
         \else
           \ifdim\prevdepth<\zeropoint
             % brrr
           \else
             % ensure at least a proper prevdepth, this should be
             % an option
             \vskip-\prevdepth
             \vskip\strutdepth
             \prevdepth\strutdepth
           \fi
           % the old crappy piece of code
           \edef\oldprevdepth{\the\prevdepth}%
           \prevdepth\newprevdepth
         \fi
       \else
         \global\doeblankotrue
       \fi
       \ifblankoreset
         \global\doeblankotrue
         \ifgridsnapping
            % let's play safe and not fool around with the depth, if
            % only because it took a lot of effort to sort out the grid
            % stuff in the first place
         \else
           \ifdim\prevdepth=\newprevdepth
             \prevdepth\oldprevdepth
           \fi
         \fi
       \fi
       \ifdoeblanko
         \ifdim1\lastskip<1\blankoskip\relax
           % else when \blanko[2*groot] + \blanko[3*groot] with parskip
           % equaling 1*groot, gives a groot=\parskip so adding a small
           % value makes it distinguishable; can also be done at parskip
           % setting time (better)
           \global\advance\blankoskip \mindimen\relax % = skip
           % test this on 2* + 3* and parskip groot
           \ifblankogeenwit
             \global\advance\blankoskip -\parskip
           \else
             \ifdim\lastskip=\parskip
             \else  % force this due to previous comment
               \ifdim\parskip>\zeropoint\relax
                 \ifdim\blankoskip<\parskip\relax
                   \global\blankoskip\zeropoint
                 \else
                   \global\advance\blankoskip -\parskip
                 \fi
               \fi
             \fi
           \fi
           \ifblankoflexibel \else
             \blankoskip1\blankoskip
           \fi
           \iflokaalblankovast
             \blankoskip1\blankoskip
           \fi
           \iflokaalblankoflexibel
             \blankoskip1\blankoskip
               \!!plus\skipgluefactor\blankoskip
               \!!minus\skipgluefactor\blankoskip
           \fi
%           \ifgridsnapping
%             \ifdim\lastkern=\noblanksignal
%               \global\doeblankofalse
%             \fi
%           \else
%             \ifdim\prevdepth=\newprevdepth
%               \global\doeblankofalse
%             \fi
%           \fi
%
           \ifdim\lastkern=\noblanksignal % controled and grid
             \global\doeblankofalse
           \else\ifgridsnapping\else\ifdim\prevdepth=\newprevdepth
             \global\doeblankofalse
           \fi\fi\fi
%
           \ifdoeblanko
             \iffuzzyvskip
               \removelastfuzzyvskip
               \fuzzyvskip\blankoskip\relax
             \else
               \removelastskip
               \vskip\blankoskip\relax
             \fi
           \fi
         \else
           \iffuzzyvskip
             \removelastfuzzyvskip
             \fuzzyvskip\blankoskip\relax
           \else
             % new, test this on pascal
             \ifdim\blankoskip<\zeropoint
               \advance\blankoskip-\lastskip
               \removelastskip
               \ifdim\blankoskip>\zeropoint
                 \vskip\blankoskip
               \else
                 \vskip\zeropoint
               \fi
             \else
               % also new
               \ifdim\blankoskip=\zeropoint
                 \ifblankogeenwit
                   \geenwitruimte
                 \fi
               \fi
             \fi
           \fi
         \fi
       \fi
     \fi
   \fi
   \global\fuzzyvskipfalse
   \presetindentation}

\def\doinhibitblank
  {\kern\noblanksignal}

%D For a long time we had:
%D
%D \starttypen
%D \def\simpledoblanko%
%D   {\doifelse{\currentwitruimte}{\v!geen}
%D      {\blanko[\currentblanko]}
%D      {\blanko[\currentwitruimte]}}
%D \stoptypen
%D
%D But Berend de Boer wanted more control, so now we have:

\def\simpledoblanko % ...
  {\doifelse\currentwitruimte\v!geen
     {\blanko[\currentblanko]}
     {\blanko[\s!default]}}

%D Another useful definition would be:
%D
%D \starttypen
%D \definieerblanko
%D   [\s!default]
%D   [\v!groot]
%D \stoptypen

\def\dosetupblank#1% amount are an plain inheritance
  {\bigskipamount#1\relax
   \ifblankoflexibel \else
     \bigskipamount1\bigskipamount
   \fi
   \medskipamount  \bigskipamount \divide\medskipamount   2
   \smallskipamount\bigskipamount \divide\smallskipamount 4 }%

\def\complexsetupblank[#1]% more \let's
  {\ifgridsnapping
     \blankoflexibelfalse
   \else
     \ExpandFirstAfter\processallactionsinset
       [#1]
       [ \v!flexibel=>\blankoflexibeltrue,
             \v!vast=>\blankoflexibelfalse]%
   \fi
   \ExpandFirstAfter\processallactionsinset
     [#1]
     [ \v!flexibel=>\dosetupblank\deblankoskip,
           \v!vast=>\dosetupblank\deblankoskip,
          \v!regel=>\edef\deblankoskip{\regelafstand}%
                    \dosetupblank\deblankoskip
                    \let\deblanko\v!groot,
     \v!halveregel=>\scratchskip.5\regelafstand
                    \edef\deblankoskip{\the\scratchskip}%
                    \dosetupblank\deblankoskip
                    \let\deblanko\v!middel,
          \v!groot=>\ifgridsnapping
                      \edef\deblankoskip{\regelafstand}%
                      \dosetupblank\deblankoskip
                    \fi
                    \let\currentblanko\v!groot  % was \def, why ?
                    \let\deblanko\v!groot,
         \v!middel=>\let\currentblanko\v!middel % was \def, why ?
                    \let\deblanko\v!middel,
          \v!klein=>\let\currentblanko\v!klein  % was \def, why ?
                    \let\deblanko\v!klein,
        \v!normaal=>\dosetupblank\deblankoskip
                    \let\deblanko\v!groot,
      \v!standaard=>\edef\deblankoskip{\skipfactor\regelafstand}%
                    \dosetupblank\deblankoskip
                    \let\deblanko\v!groot,
        \s!default=>\dosetupblank\deblankoskip
                    \let\deblanko\v!groot,
        \s!unknown=>\let\deblankoskip\commalistelement
                    \dosetupblank\deblankoskip
                    \let\deblanko\v!groot]%
   \simplesetupwhitespace}

% \definecomplexorsimpleempty\setupblank
%
% speed gain: 60 sec -> 30 sec

\definecomplexorsimple\setupblank

\def\simplesetupblank % == snelle \setupblank[\s!default]
  {\ifgridsnapping
     \blankoflexibelfalse
   \fi
   \dosetupblank\deblankoskip
   \let\deblanko\v!groot
   \simplesetupwhitespace}

\def\restorestandardblank% \v!standaard
  {\edef\deblankoskip{\skipfactor\regelafstand}%
   \dosetupblank\deblankoskip
   \let\deblanko\v!groot}

\def\dodefinieerblanko[#1][#2]%
  {\def\docommando##1{\setvalue{\??bo##1}{#2}}%
   \processcommalist[#1]\docommando}

\def\definieerblanko%
  {\dodoubleargument\dodefinieerblanko}

\def\savecurrentblanko%
  {\edef\restorecurrentblanko%
     {\bigskipamount\the\bigskipamount
      \medskipamount\the\medskipamount
      \smallskipamount\the\smallskipamount
      \noexpand\def\noexpand\currentblanko{\currentblanko}%
      \ifblankoflexibel
        \noexpand\blankoflexibeltrue
      \else
        \noexpand\blankoflexibelfalse
      \fi}}

\def\inhibitblank% the fast, local way
  {\endgraf\ifvmode\prevdepth\newprevdepth\fi}

%D Now.

\definieerblanko [\s!default] [\v!wit]
\definieerblanko [\v!hoogte]  [\strutheight]
\definieerblanko [\v!diepte]  [\strutdepth]

\let\currentvoorwit=\empty

\newdimen\voorwit

\newif\ifindentfirstparagraph % \indentfirstparagraphtrue

\def\presetindentation
  {\doifoutervmode{\ifindentfirstparagraph\else\noindentation\fi}}

\definecomplexorsimple\setupindenting

\def\complexsetupindenting[#1]%
  {\processallactionsinset
     [#1]
     [   \v!eerste=>\indentfirstparagraphtrue,
       \v!volgende=>\indentfirstparagraphfalse,
        \s!default=>\simplesetupindenting,
        \s!unknown=>\edef\currentvoorwit{\commalistelement}%
                    \simplesetupindenting]}

\def\simplesetupindenting
  {\assigndimension\currentvoorwit\voorwit{1em}{1.5em}{2em}%
   \parindent\voorwit\relax}

\def\doinspringen[#1]% too many relaxes
  {\processallactionsinset
     [#1]
     [    \v!nee=>\parindent\voorwit\relax\noindent,
         \v!niet=>\parindent\voorwit\relax\noindent,
           \v!ja=>\parindent\voorwit\relax,            % geen \indent !
       \v!eerste=>\indentfirstparagraphtrue,
     \v!volgende=>\indentfirstparagraphfalse,
       \v!altijd=>\parindent\voorwit\relax,            % geen \indent !
        \v!nooit=>\parindent\zeropoint\relax]}

\def\inspringen
  {\dosingleargument\doinspringen}

\def\nietinspringen{\inspringen[\v!nee,\v!volgende]}
\def\welinspringen {\inspringen[\v!ja,\v!eerste]}

\def\dochecknextindentation#1% internal one
  {\checknextindentation[\getvalue{#1\c!springvolgendein}]}

\def\checknextindentation[#1]%
  {\processaction[#1][%\v!handhaaf=>,
      \v!ja=>\doindentation,
     \v!nee=>\noindentation,
    \v!auto=>\autoindentation]}

\def\doindentation% too simple
  {\gdef\checkindentation{\global\indentationtrue}}

\ifx\autoindentation\undefined
  \let\autoindentation\relax
\fi

% \frenchspacing leidt soms tot afbreken tussen -, vandaar
% de variant \newfrenchspacing.

\def\dofrenchspacing#1%
  {\sfcode`\.#1 \sfcode`\,#1\relax
   \sfcode`\?#1 \sfcode`\!#1\relax
   \sfcode`\:#1 \sfcode`\;#1\relax}

\def\frenchspacing   {\dofrenchspacing{1000}}
\def\newfrenchspacing{\dofrenchspacing{1050}}

\def\nonfrenchspacing
  {\sfcode`\.3000 \sfcode`\,1250
   \sfcode`\?3000 \sfcode`\!3000
   \sfcode`\:2000 \sfcode`\;1500 }

\def\definespacingmethod[#1]#2{\setvalue{\??sg\??sg#1}{#2}}

\definespacingmethod[\v!opelkaar]{\newfrenchspacing}
\definespacingmethod[\v!ruim    ]{\nonfrenchspacing}

\def\complexsetupspacing[#1]%
  {\executeifdefined{\??sg\??sg#1}\relax
   \updateraggedskips}

\def\simplesetupspacing
  {\updateraggedskips}

\definecomplexorsimple\setupspacing

\catcode`\~=\@@active % to be sure

\unexpanded\def~{\nonbreakablespace}

\def\space          { }
\def\removelastspace{\ifhmode\unskip\fi}
\def\nospace        {\removelastspace\ignorespaces}

% in tables we need:
%
% \def\fixedspace   {\hskip.5em\relax}
%
% but, since not all fonts have .5em digits:

\def\fixedspace
  {\setbox\scratchbox\hbox\ifmmode{$0$}\else{0}\fi
   \hskip\wd\scratchbox\relax}

\def\fixedspaces
  {\catcode`\~=\@@active
   \def~{\fixedspace}}

% \def\removeunwantedspaces{\ifhmode\unskip\unskip\unskip\unskip\unskip\fi}

\def\removeunwantedspaces
  {\ifhmode
     \doloop{\ifdim\lastskip>\zeropoint\unskip\else\exitloop\fi}%
   \fi}

% better, but not done:
%
% \def\removelastspace
%   {\ifhmode \ifdim\lastskip=\spaceamount\relax
%      \unskip
%    \fi \fi}
%
% due to backward compability

\let\spatie     \space
\let\hardespatie\fixedspace
\let\geenspatie \nospace

% \startbuffer
% \startlines \tt \fixedspaces
%  0~1~~2~~~3~~~~4~~~~~5
%  0~~~~~~~~~~~~~~~~~~~5
% $0~1~~2~~~3~~~~4~~~~~5$
% $0~~~~~~~~~~~~~~~~~~~5$
% \stoplines
%
% \starttabulate[|~|]
% \NC  0~1~~2~~~3~~~~4~~~~~5  \NC \NR \NC  0~~~~~~~~~~~~~~~~~~~5  \NC \NR
% \NC $0~1~~2~~~3~~~~4~~~~~5$ \NC \NR \NC $0~~~~~~~~~~~~~~~~~~~5$ \NC \NR
% \stoptabulate
%
% \starttable[||]
% \NC  0~1~~2~~~3~~~~4~~~~~5  \NC \AR \NC  0~~~~~~~~~~~~~~~~~~~5  \NC \AR
% \NC $0~1~~2~~~3~~~~4~~~~~5$ \NC \AR \NC $0~~~~~~~~~~~~~~~~~~~5$ \NC \AR
% \stoptable
% \stopbuffer
%
% \setupbodyfont[cmr] \getbuffer
% \setupbodyfont[lbr] \getbuffer

\def\opelkaar
  {\nointerlineskip}

\def\omlaag[#1]% nog eens mooier, relateren aan blanko
  {\nointerlineskip
   \vskip#1 }

%D A couple of plain macros:

\ifx\thinspace\undefined

  \def\thinspace   {\kern .16667em }
  \def\negthinspace{\kern-.16667em }
  \def\enspace     {\kern     .5em }

\fi

\ifx\quad\undefined

  \def\enskip{\hskip.5em\relax}
  \def\quad  {\hskip 1em\relax}
  \def\qquad {\hskip 2em\relax}

\fi

\let\emspace\quad

\ifx\smallskip\undefined

  \def\smallskip{\vskip\smallskipamount}
  \def\medskip  {\vskip\medskipamount}
  \def\bigskip  {\vskip\bigskipamount}

\fi

\ifx\allowbreak\undefined

  \def\break     {\penalty-\@M}
  \def\nobreak   {\penalty \@M}
  \def\allowbreak{\penalty \z@}
  \def\filbreak  {\par\vfil\penalty-200\vfilneg}
  \def\goodbreak {\par\penalty-500 }

\fi

%D Made slightly more readable:

\ifx\vglue\undefined

  \def\vglue  {\afterassignment\dovglue\scratchskip=}
  \def\hglue  {\afterassignment\dohglue\scratchskip=}
  \def\topglue{\nointerlineskip\vglue-\topskip\vglue}

  \def\dovglue
    {\par
     \scratchdimen\prevdepth
     \hrule\!!height\zeropoint
     \nobreak\vskip\scratchskip
     \prevdepth\scratchdimen}

  \def\dohglue
    {\leavevmode
     \scratchcounter\spacefactor
     \vrule\!!width\zeropoint
     \nobreak\hskip\scratchskip
     \spacefactor\scratchcounter}

\fi

\ifx\eject\undefined

  \def\eject{\par\break}

\fi

\ifx\supereject\undefined

  \def\supereject{\par\penalty-\@MM}

\fi

\ifx\dosupereject\undefined

  \def\dosupereject
    {\ifnum\insertpenalties>\z@ % something is being held over
       \line{}
       \kern-\topskip
       \nobreak
       \vfill\supereject
     \fi}

\fi

%D We adapt plain's \type {\removelastskip} a bit:

\ifx\removelastskip\undefined

  \def\removelastskip
    {\ifvmode \ifdim\lastskip=\zeropoint \else
       \vskip-\lastskip
     \fi \fi}

\fi

\ifx\smallbreak\undefined

\def\smallbreak
  {\par
   \ifdim\lastskip<\smallskipamount
     \removelastskip
     \penalty-50
     \smallskip
   \fi}

\def\medbreak
  {\par
   \ifdim\lastskip<\medskipamount
     \removelastskip
     \penalty-100
     \medskip
   \fi}

\def\bigbreak
  {\par
   \ifdim\lastskip<\bigskipamount
     \removelastskip
     \penalty-200
     \bigskip
   \fi}

\fi

\newskip\tussenwit \tussenwit\zeropoint

\newif\ifwitruimteflexibel \witruimteflexibeltrue

\def\blankokleinmaat  {\smallskipamount}
\def\blankomiddelmaat {\medskipamount}
\def\blankogrootmaat  {\bigskipamount}
\def\currentwitruimte {\zeropoint}

% \def\stelwitruimteopnieuwin
%   {\expanded{\setupwhitespace[\currentwitruimte]}}
%
% \newif\ifwitruimteflexibel \witruimteflexibeltrue
%
% \definecomplexorsimple\setupwhitespace
%
% \def\complexsetupwhitespace[#1]%
%   {\expanded{\dosetupwhitespace[#1]}%
%    \dodosetupwhitespace}
%
% \def\dosetupwhitespace[#1]%
%   {\processallactionsinset
%      [#1]
%      [\v!herstel=>,
%          \v!vast=>\witruimteflexibelfalse,
%      \v!flexibel=>\witruimteflexibeltrue,
%         \v!regel=>\tussenwit\baselineskip,
%    \v!halveregel=>\tussenwit.5\baselineskip,
%       \s!default=>\doifnot\currentwitruimte\v!geen\stelwitruimteopnieuwin,
%       \s!unknown=>\@EA\assigndimension\@EA{\commalistelement} % \@EA is nodig
%                     \tussenwit\blankokleinmaat\blankomiddelmaat\blankogrootmaat]}   % te vangen
%
% \def\dodosetupwhitespace
%   {\edef\currentwitruimte
%      {\ifdim\tussenwit=\zeropoint
%         \v!geen
%       \else
%         \ifgridsnapping\the\baselineskip\else\the\tussenwit\fi
%       \fi}%
%    \ifgridsnapping
%      \witruimteflexibelfalse
%      \tussenwit1\tussenwit
%      \ifdim\tussenwit>\zeropoint
%        \tussenwit\baselineskip
%      \fi
%    \else
%      \ifwitruimteflexibel \else \tussenwit1\tussenwit \fi
%    \fi
%    \parskip\tussenwit}
%
% \def\simplesetupwhitespace% == snelle \setupwhitespace[\s!default]
%   {\doifnot\currentwitruimte\v!geen\stelwitruimteopnieuwin
%    \dodosetupwhitespace}

\definecomplexorsimple\setupwhitespace

\def\simplesetupwhitespace
  {\doifnot\currentwitruimte\v!geen\dosetupwhitespace}

\def\complexsetupwhitespace[#1]%
  {\doifelsenothing{#1}
     {\simplesetupwhitespace}
     {\edef\currentwitruimte{#1}%
      \dosetupwhitespace}}

\def\dosetupwhitespace
  {\processcommacommand[\currentwitruimte]\dowhitespacemethod
   \dodosetupwhitespace}

\def\dodosetupwhitespace
  {\ifgridsnapping
     \witruimteflexibelfalse
     \tussenwit1\tussenwit
     \ifdim\tussenwit>\zeropoint
       \tussenwit\baselineskip
     \fi
   \else
     \ifwitruimteflexibel \else \tussenwit1\tussenwit \fi
   \fi
   \parskip\tussenwit}

\definesystemvariable {ws} % whitespace

\def\definewhitespacemethod[#1]#2{\setvalue{\??ws\??ws#1}{#2}}

\definewhitespacemethod [\v!herstel]    {}
\definewhitespacemethod [\v!vast]       {\witruimteflexibelfalse}
\definewhitespacemethod [\v!flexibel]   {\witruimteflexibeltrue}
\definewhitespacemethod [\v!regel]      {\tussenwit  \baselineskip}
\definewhitespacemethod [\v!halveregel] {\tussenwit.5\baselineskip}
\definewhitespacemethod [\v!geen]       {\tussenwit  \zeropoint}
\definewhitespacemethod [\v!groot]      {\tussenwit  \blankogrootmaat}
\definewhitespacemethod [\v!middel]     {\tussenwit  \blankomiddelmaat}
\definewhitespacemethod [\v!klein]      {\tussenwit  \blankokleinmaat}

\definewhitespacemethod [\s!default]    {\stelwitruimteopnieuwin}

\def\dowhitespacemethod#1%
  {\executeifdefined{\??ws\??ws#1}{\tussenwit#1}\relax}

\def\geenwitruimte
  {\ifdim\parskip>\zeropoint\relax
     \ifdim\lastskip=-\parskip
     \else
       \vskip-\parskip
     \fi
   \fi}

\def\savecurrentwitruimte
  {\edef\restorecurrentwitruimte
     {\tussenwit\the\tussenwit
      \parskip\the\parskip
      \noexpand\def\noexpand\currentwitruimte{\currentwitruimte}%
      \ifwitruimteflexibel
        \noexpand\witruimteflexibeltrue
      \else
        \noexpand\witruimteflexibelfalse
      \fi}}

% deze variant is nodig binnen \startopelkaar
% steeds testen:
%
% \hoofdstuk{..}
% \plaatslijst[..]
% \hoofdstuk{..}
% \input tufte
%
% met/zonder witruimte

\def\witruimte%
  {\par
   \ifdim\parskip>\zeropoint\relax
    %\ifdim\lastskip>\parskip \else
     % \removelastskip interferes with blanko blokkeer en klein
       \vskip\parskip
    %\fi
   \fi}

\def\nonoblanko[#1]%
  {\par}

\def\noblanko%
  {\dosingleempty\nonoblanko}

% De onderstaande macro handelt ook de situatie dat er geen
% tekst tussen \start ... \stop is geplaatst. Daartoe wordt de
% laatste skip over de lege tekst heen gehaald. Dit komt goed
% van pas bij het plaatsen van (mogelijk lege) lijsten.

\newif\ifopelkaar

\def\noparskipsignal {0.00001pt}
\def\lastdoneparskip {0pt}

\def\startopelkaar
  {\dosingleempty\dostartopelkaar}

\def\dostartopelkaar[#1]% nesting afvangen
  {\par
   \ifvmode
     \edef\lastdoneparskip  {\the\lastskip}%
     \edef\lastdoneprevdepth{\the\prevdepth}% zeer recent toegevoegd
     \ifdim\prevdepth=-\thousandpoint % toegevoegd omdat binnen
     \else                            % een vbox een extra skip
       \witruimte                     % ongewenst is; dit kan
       \baselinecorrection %% zie in \plaatsregister[n=1]
       \vskip\noparskipsignal   % waarschijnlijk ook in
     \fi                        % blanko blokkeer
     \bgroup
     \doifelse{#1}\v!blanko
       \opelkaarfalse
       \opelkaartrue
     \blanko[\v!blokkeer]       % dit is nog niet ok, gaat fout
     \setupwhitespace[\v!geen]  % bovenin vtop (dwz, baseline)
  \fi}

\def\stopopelkaar
  {\par
   \ifvmode
     \egroup
     \ifdim\lastskip=\noparskipsignal\relax
       \removelastskip
       \geenwitruimte
       \vskip-\lastdoneparskip
       \vskip+\lastdoneparskip
      \prevdepth-\lastdoneprevdepth % zeer recent toegevoegd
     \fi
  \fi}

\def\startvanelkaar
  {\blanko
   \leavevmode
   \bgroup}

\def\stopvanelkaar
  {\egroup
   \blanko}

% De onderstaande macro's moeten nog eens nader worden uitgewerkt.
% Ze spelen een rol bij de spatiering rond omkaderde teksten
% en/of boxen zonder diepte.

\def\toonregelcorrectie   {\showbaselinecorrection}
\def\regelcorrectie       {\baselinecorrection}


% \prevdepth crosses pageboundaries!

\let\dorondomregelcorrectie=\relax

\def\startregelcorrectie
  {\dodoubleempty\dostartregelcorrectie}

\def\dostartregelcorrectie[#1][#2]% #2 gobbles spaces
  {\bgroup
   \processaction
     [#1]
     [ \v!blanko=>\let\dorondomregelcorrectie\blanko,
      \s!default=>\let\dorondomregelcorrectie\relax,
      \s!unknown=>{\def\dorondomregelcorrectie{\blanko[#1]}}]%
   \dorondomregelcorrectie
   \startbaselinecorrection
   \offbaselinecorrection
   \ignorespaces}

\def\stopregelcorrectie
  {\stopbaselinecorrection
   \dorondomregelcorrectie
   \egroup}

\def\corrigeerwitruimte
  {\dowithnextbox
     {\startbaselinecorrection
      \flushnextbox
      \stopbaselinecorrection}%
   \vbox}

\def\verticalstrut  {\normalvbox{\hsize\zeropoint\strut}}
\def\horizontalstrut{\normalhbox                {\strut}}

% Hieronder volgen enkele instellingen en macro's ten behoeve
% van de interlinie en \strut. De waarden 2.8, 0.07, 0.72 en
% 0.28 zijn ooit eens ontleend aan INRS-TEX en moeten wellicht
% nog eens instelbaar worden.
%
%   \lineheight        : de hoogte van een regel
%   \spacing{getal}    : instellen interlinie
%   \normalbaselines   : instellen regelafstend
%
%   \setstrut          : instellen \strut
%   \setnostrut        : resetten \strut, \endstrut, \begstrut
%
%   \setteststrut      : instellen zichtbare struts
%   \resetteststrut    : instellen onzichtbare struts
%
%   \setfontparameters : instellen na fontset
%
% De hoogte van een regel (\lineheight) is gelijk aan de
% som van de hoogte (\ht) en diepte (\dp) van \strutbox.
%
%   \strut            : denkbeeldig blokje met hoogte en diepte
%
% Een \hbox kan als deze aan het begin van een regel staat
% een breedte \hsize krijgen. Dit is soms te voorkomen met het
% commando \leavevmode. Binnen een \vbox geeft dit echter
% niet altijd het gewenste resultaat, vandaar het commando
%
%   \leaveoutervmode

% Pas op: niet zomaar \topskip en \baselineskip aanpassen
% en zeker niet \widowpenalty. Dit kan ernstige gevolgen
% hebben voor kolommen.
%
% Enige glue kan op zich geen kwaad, echter als blanko=vast,
% dan moet ook de rek 0 zijn. Binnen kolommen is rek ook
% niet bepaald mooi. Een hele kleine waarde (0.025) voldoet,
% omdat een positieve glue eindeloos rekbaar is.

\newdimen\strutdimen
\newdimen\lineheight
\newdimen\openlineheight
\newdimen\openstrutheight
\newdimen\openstrutdepth
\newdimen\topskipgap
\newdimen\struttotal

\def\strutheightfactor      {.72}
\def\strutdepthfactor       {.28}

\def\baselinefactor         {2.8}
\def\baselinegluefactor     {0}

\def\normallineheight       {\baselinefactor ex}
\def\minimallinedistance    {\lineskip}

\def\strutheight            {0pt}
\def\strutdepth             {0pt}
\def\strutwidth             {0pt}

\def\spacingfactor          {1}

\def\topskipfactor          {1.0}
\def\maxdepthfactor         {0.5}

\def\systemtopskipfactor    {\topskipfactor}
\def\systemmaxdepthfactor   {\maxdepthfactor}

% De onderstaande definitie wordt in de font-module overruled

\ifx\globalbodyfontsize\undefined
  \newdimen\globalbodyfontsize
  \globalbodyfontsize=12pt
\fi

\ifx\normalizedbodyfontsize\undefined
  \def\normalizedbodyfontsize{12pt}
\fi

% door een \dimen. Dit is geen probleem omdat (1) de default
% korpsgrootte 12pt is en (2) de fonts nog niet geladen zijn
% en de instellingen bij het laden nogmaals plaatsvinden.

\def\topskipcorrection
  {\ifdim\topskip>\openstrutheight
     % == \vskip\topskipgap
     \vskip\topskip
     \vskip-\openstrutheight
   \fi
   \verticalstrut
   \vskip-\struttotal}

\def\settopskip % the extra test is needed for the lbr family
  {\topskip\systemtopskipfactor\globalbodyfontsize
   \ifgridsnapping \else
     \ifr@ggedbottom\!!plus5\globalbodyfontsize\fi
   \fi
   \relax % the skip
   \topskipgap\topskip
   \advance\topskipgap -\openstrutheight\relax
   \ifdim\topskip<\strutheightfactor\openlineheight
     \topskip\strutheightfactor\openlineheight\relax
   \fi}

\def\setmaxdepth
  {\maxdepth\systemmaxdepthfactor\globalbodyfontsize}

\def\normalbaselines
  {\baselineskip\normalbaselineskip
   \lineskip\normallineskip
   \lineskiplimit\normallineskiplimit}

\def\setnormalbaselines
  {\ifdim\normallineheight>\zeropoint
     \lineheight\normallineheight
   \fi
   \openlineheight\spacingfactor\lineheight
   \openstrutheight\strutheightfactor\openlineheight
   \openstrutdepth \strutdepthfactor \openlineheight
   \normalbaselineskip\openlineheight
     \!!plus\baselinegluefactor\openlineheight
     \!!minus\baselinegluefactor\openlineheight
   \normallineskip\minimallinedistance\relax % \!!onepoint\relax
   \normallineskiplimit\zeropoint\relax
   \normalbaselines}

\def\setspacingfactor#1\to#2\by#3\\%
  {\strutdimen#2\s!pt
   \strutdimen#3\strutdimen
   \edef#1{\withoutpt{\the\strutdimen}}}

\def\spacing#1%
  {\ifgridsnapping
    %\doifnot{#1}{1}{\showmessage\m!layouts{11}{#1}}%
     \ifdim#1\s!pt=1\s!pt\else\showmessage\m!layouts{11}{#1}\fi
     \edef\spacingfactor{1}%
   \else
     \edef\spacingfactor{#1}%
   \fi
   \setspacingfactor\systemtopskipfactor \to\topskipfactor \by#1\\%
   \setspacingfactor\systemmaxdepthfactor\to\maxdepthfactor\by#1\\%
   \setnormalbaselines
   \setstrut}

\def\setstrutdimen#1#2#3%             % een strut is n.m maal ex
  {\strutdimen\normallineheight       % wat niet per se \lineheight
   \strutdimen#2\strutdimen           % is omdat een strut lokaal
   \strutdimen#3\strutdimen           % kan afwijken van de globale
   \edef#1{\the\strutdimen}} % macro  % strut

% plain definition:
%
% \def\strut{\relax\ifmmode\copy\strutbox\else\unhcopy\strutbox\fi}
%
% could be:
%
% \def\strut{\relax\ifmmode\copy\else\unhcopy\fi\strutbox}

\ifx\strutbox\undefined

  \newbox\strutbox

  \setbox\strutbox=\hbox{\vrule height8.5pt depth3.5pt width\z@}

 %\def\strut{\relax\ifmmode\copy\strutbox\else\unhcopy\strutbox\fi}
  \def\strut{\relax\ifmmode\copy\else\unhcopy\fi\strutbox}

\fi

\let\normalstrut=\strut

% The double \hbox construction enables us to \backtrack
% boxes.

% \def\setstrut
%   {\setstrutdimen\strutheight\strutheightfactor\spacingfactor
%    \setstrutdimen\strutdepth \strutdepthfactor \spacingfactor
%    \let\strut=\normalstrut
%    \setbox\strutbox=\normalhbox
%      {\normalhbox
%         {\vrule
%            \!!width  \strutwidth
%            \!!height \strutheight
%            \!!depth  \strutdepth
%            \normalkern-\strutwidth}}}

% \def\setstrut
%   {\setstrutdimen\strutheight\strutheightfactor\spacingfactor
%    \setstrutdimen\strutdepth \strutdepthfactor \spacingfactor
%    \dosetstrut}

\def\setstrut
  {\strutdimen\normallineheight
   \strutdimen\strutheightfactor\strutdimen
   \strutdimen\spacingfactor\strutdimen
   \edef\strutheight{\the\strutdimen}%
   \strutdimen\normallineheight
   \ifgridsnapping
     \advance\strutdimen-\strutheight
   \else
     \strutdimen\strutdepthfactor\strutdimen
     \strutdimen\spacingfactor\strutdimen
   \fi
   \edef\strutdepth{\the\strutdimen}%
   \dosetstrut}

\def\setcharstrut#1%
  {\setbox\strutbox\hbox{#1}%
   \edef\strutheight{\the\strutht}%
   \edef\strutdepth {\the\strutdp}%
   \dosetstrut}

\def\setfontstrut
  {\setcharstrut{(}}

\def\setcapstrut% could be M, but Q has descender
  {\setcharstrut{Q}}

%D Centered looks nicer:

\def\dosetstrut
  {\let\strut\normalstrut
   \setbox\strutbox\normalhbox
     {\normalhbox to \zeropoint
        {% \hss % new, will be option
         \vrule
           \!!width \strutwidth
           \!!height\strutheight
           \!!depth \strutdepth
         \hss}}%
   \struttotal\strutht
   \advance\struttotal\strutdp}

%D The dimen \type {\struttotal} holds the exact size of the
%D strut; occasionally a one scaled point difference can show
%D up with the lineheight.

%D Sometimes a capstrut comes in handy
%D
%D \starttabulatie[|Tl|l|l|]
%D \NC yes          \NC normal strut               \NC {\showstruts\setupstrut[ja]\strut}  \NC \NR
%D \NC no           \NC no strut                   \NC {\showstruts\setupstrut[nee]\strut}  \NC \NR
%D \NC kap          \NC a capital strut (i.e. Q)   \NC {\showstruts\setupstrut[kap]\strut} \NC \NR
%D \NC A B \unknown \NC a character strut (e.g. A) \NC {\showstruts\setupstrut[A]\strut}   \NC \NR
%D \NC              \NC a normal strut             \NC {\showstruts\setupstrut\strut}      \NC \NR
%D \stoptabulatie

\def\setupstrut%
  {\dosingleempty\dosetupstrut}

\def\dosetupstrut[#1]% yet undocumented, todo: fontstrut
  {\processaction
     [#1]
     [     \v!ja=>\setstrut,
          \v!nee=>\setnostrut,
          \v!kap=>\setcapstrut,
      \v!passend=>\setfontstrut,
        \v!regel=>\setstrut,
      \s!default=>\setstrut,
      \s!unknown=>\setcharstrut\commalistelement]}

\def\setteststrut
  {\def\strutwidth{.8pt}%
   \setstrut}

% simple version
%
% \def\begstrut
%   {\relax\ifcase\strutht\else
%      \strut
%      \normalpenalty\@M % \!!tenthousand
%      \normalhskip\zeropoint
%      \ignorespaces
%    \fi}
%
% \def\endstrut
%   {\relax\ifhmode\ifcase\strutht\else
%      \removeunwantedspaces
%      \normalpenalty\@M % \!!tenthousand
%      \normalhskip\zeropoint
%      \strut
%    \fi\fi}

% when enabled, sigstruts will remove themselves if nothing
% goes inbetween

\newsignal\strutsignal \setfalse\sigstruts

\def\begstrut
  {\relax\ifcase\strutht\else
     \ifconditional\sigstruts
       \noindent\horizontalstrut
       \normalpenalty\@M % \!!tenthousand
       \normalhskip-\strutsignal
       \normalhskip\strutsignal
     \else
       \strut
       \normalpenalty\@M % \!!tenthousand
       \normalhskip\zeropoint
     \fi
     \ignorespaces
   \fi}

\def\endstrut
  {\relax\ifhmode\ifcase\strutht\else
     \ifconditional\sigstruts
       \ifdim\lastskip=\strutsignal
         \unskip\unskip\unpenalty\setbox\scratchbox\lastbox
       \else
         \normalpenalty\@M % \!!tenthousand
         \normalhskip\zeropoint
         \strut
       \fi
     \else
       \removeunwantedspaces
       \normalpenalty\@M % \!!tenthousand
       \normalhskip\zeropoint
       \strut
     \fi
   \fi\fi}

\newbox\nostrutbox \setbox\nostrutbox\normalhbox{\normalhbox{}}

\def\setnostrut
  {\setbox\strutbox\copy\nostrutbox
   \let\strut\empty
   \let\endstrut\empty
   \let\begstrut\empty}

% unsave:
%
% \def\pseudostrut
%   {\bgroup
%    \setnostrut
%    \normalstrut
%    \egroup}
%
% try:
%
% \startchemie
%   \chemie[ONE,Z0,SB15,MOV1,SB15,Z0][C,C]
% \stopchemie
%
% so:

\def\pseudostrut
  {\noindent} % better: \dontleavehmode

\let\pseudobegstrut\pseudostrut

\let\pseudoendstrut\removeunwantedspaces

\def\resetteststrut
  {\let\strutwidth\!!zeropoint
   \setstrut}

\ifx\setfontparameters\undefined
  \def\setfontparameters{\the\everybodyfont}
\fi

%D Handy:

\def\baselinedistance{\the\lineheight}

%D We need \type{\normaloffinterlineskip} because the new
%D definition contains an assignment, and |<|don't ask me
%D why|>| this assignment gives troubles in for instance the
%D visual debugger.

%D The plain ones:

\def\offinterlineskip
  {\baselineskip-\thousandpoint
   \lineskip\zeropoint
   \lineskiplimit\maxdimen}

\def\nointerlineskip
  {\prevdepth-\thousandpoint}

\let\normaloffinterlineskip=\offinterlineskip % knuth's original

%D My own one:

\def\offinterlineskip
  {\ifdim\baselineskip>\zeropoint
     \edef\oninterlineskip
       {\baselineskip\the\baselineskip
        \lineskip\the\lineskip
        \lineskiplimit\the\lineskiplimit
        \let\noexpand\offinterlineskip\noexpand\normaloffinterlineskip}%
   \else
     \let\oninterlineskip\setnormalbaselines
   \fi
   \normaloffinterlineskip}

\let\oninterlineskip=\relax

\def\leaveoutervmode
  {\ifvmode\ifinner\else
     \leavevmode
   \fi\fi}

% We stellen enkele penalties anders in dan Plain TEX:

\def\defaultwidowpenalty{2000} % was: 1000
\def\defaultclubpenalty {2000} % was:  800

\widowpenalty=\defaultwidowpenalty\relax
\clubpenalty =\defaultclubpenalty \relax

% Bovendien definieren we enkele extra \fill's:

\def\hfilll{\hskip\zeropoint\!!plus1filll\relax}
\def\vfilll{\vskip\zeropoint\!!plus1filll\relax}

% De onderstaande hulpmacro's moeten nog eens instelbaar worden
% gemaakt.

\def\tfskipsize{1em\relax}
\def\tfkernsize{1ex\relax}

\def\tfskip{\dotfskip\tfskipsize}
\def\tfkern{\dotfkern\tfkernsize}

\def\dotfskip#1{{\tf\hskip#1}}
\def\dotfkern#1{{\tf\kern #1}}

\newskip\linkssmaller
\newskip\rechtssmaller
\newskip\middensmaller

\def\dosinglesmaller#1%
  {\processaction
     [#1]
     [    \v!links=>\global\advance\linkssmaller  \@@sllinks,
         \v!midden=>\global\advance\middensmaller \@@slmidden,
         \v!rechts=>\global\advance\rechtssmaller \@@slrechts,
           \v!geen=>,
        \s!unknown=>\global\advance\middensmaller \commalistelement]}

\def\dosmaller[#1]%
  {\processaction
     [#1]
     [    \v!links=>\global\advance\linkssmaller  \@@sllinks,
         \v!midden=>\global\advance\middensmaller \@@slmidden,
         \v!rechts=>\global\advance\rechtssmaller \@@slrechts,
           \v!geen=>,% handy for delimitedtexts
        \s!unknown=>{\herhaalmetcommando[#1]\dosinglesmaller}]}

\def\complexstartsmaller[#1]%
  {\par
   \bgroup
   \global\linkssmaller \zeropoint
   \global\rechtssmaller\zeropoint
   \global\middensmaller\zeropoint
   \processcommalistwithparameters[#1]\dosmaller
   \advance\leftskip  \linkssmaller
   \advance\rightskip \rechtssmaller
   \advance\leftskip  \middensmaller
   \advance\rightskip \middensmaller
   \seteffectivehsize}

\def\simplestartsmaller
  {\startsmaller[\v!midden]}

\definecomplexorsimple\startsmaller

\def\stopsmaller
  {\par % else skips forgotten
   \egroup}

\def\setupnarrower
  {\dodoubleargument\getparameters[\??sl]}

\newdimen\@@effectivehsize     \def\effectivehsize    {\hsize}
\newdimen\@@effectiveleftskip  \def\effectiveleftskip {\leftskip}
\newdimen\@@effectiverightskip \def\effectiverightskip{\rightskip}

\def\seteffectivehsize
  {\setlocalhsize
   \@@effectivehsize      \localhsize
   \@@effectiveleftskip   \leftskip
   \@@effectiverightskip  \rightskip
   \let\effectivehsize    \@@effectivehsize
   \let\effectiveleftskip \@@effectiveleftskip
   \let\effectiverightskip\@@effectiverightskip}

\def\dodefinieerhbox[#1][#2]%
  {\setvalue{hbox#1}##1%
     {\hbox to #2{\begstrut##1\endstrut\hss}}}

\def\definieerhbox%
  {\dodoubleargument\dodefinieerhbox}

\def\lrcbox#1#2#%
  {\vbox#2\bgroup
   \let\\=\endgraf
   \forgetall#1\let\next=}

\def\lbox{\lrcbox\raggedleft}
\def\rbox{\lrcbox\raggedright}
\def\cbox{\lrcbox\raggedcenter}

\def\iobox#1#2#3#% here #3# is not really needed
  {\vbox\bgroup  % we want to return a vbox like the others
     \hbox\bgroup% we need to pack the signal with the box
       \signalrightpage
       \dowithnextboxcontent
         {\let\\=\endgraf\forgetall\doifrightpageelse#1#2}
         {\box\nextbox\egroup\egroup}
       \vbox#3}

\def\obox{\iobox\raggedleft \raggedright} % outerbox
\def\ibox{\iobox\raggedright\raggedleft}  % innerbox

\def\dosetraggedvbox#1%
  {\processaction
     [#1]
     [  \v!links=>\let\raggedbox\lbox,
       \v!rechts=>\let\raggedbox\rbox,
       \v!midden=>\let\raggedbox\cbox,
       \v!binnen=>\let\raggedbox\ibox,
       \v!buiten=>\let\raggedbox\obox,
          \v!nee=>\def\raggedbox{\vbox\bgroup\raggedright\let\next=},
      \s!default=>\let\raggedbox\vbox,
      \s!unknown=>\let\raggedbox\vbox]}

\def\dosetraggedhbox#1%
  {\processaction % slow
     [#1]
     [  \v!links=>\def\raggedbox{\doregelplaats\v!links },
       \v!rechts=>\def\raggedbox{\doregelplaats\v!rechts},
       \v!midden=>\def\raggedbox{\doregelplaats\v!midden},
       \v!binnen=>\def\raggedbox{\doregelplaats\v!binnen},
       \v!buiten=>\def\raggedbox{\doregelplaats\v!buiten},
      \v!normaal=>\let\raggedbox\hbox,
      \s!default=>\let\raggedbox\hbox,
      \s!unknown=>\let\raggedbox\hbox]}

% \def\dosetraggedcommand#1% ook ruim,rechts en zo
%   {\processaction
%      [#1]
%      [  \v!links=>\def\raggedcommand{\raggedleft},
%        \v!rechts=>\def\raggedcommand{\raggedright},
%        \v!midden=>\def\raggedcommand{\raggedcenter},
%           \v!nee=>\def\raggedcommand{\raggedright},
%       \v!normaal=>\let\raggedcommand\relax,
%       \s!default=>\def\raggedcommand{\raggedcenter},
%       \s!unknown=>\let\raggedcommand\relax]}

\def\dosetraggedcommand#1%
  {\expanded{\dodosetraggedcommand{#1}}}

% \def\dodosetraggedcommand#1%
%   {\doifinsetelse{\v!ruim} {#1}{\!!doneatrue}{\!!doneafalse}%
%    \doifinsetelse{\v!breed}{#1}{\!!donebtrue}{\!!donebfalse}%
%    \let\raggedcommand\relax
%    \let\raggedtopcommand\empty
%    \let\raggedbottomcommand\empty
%    \!!donectrue
%    \ExpandFirstAfter\processallactionsinset
%      [#1]
%      [  \v!links=>\if!!donea      \def\raggedcommand{\veryraggedleft}%
%                   \else           \def\raggedcommand{\raggedleft}%
%                   \fi
%                   \!!donecfalse,                    % {\v!links,\v!midden}
%        \v!rechts=>\if!!donea      \def\raggedcommand{\veryraggedright}%
%                   \else           \def\raggedcommand{\raggedright}%
%                   \fi
%                   \!!donecfalse,                    % {\v!rechts,\v!midden}
%        \v!midden=>\if!!donec
%                     \if!!doneb      \def\raggedcommand{\raggedwidecenter}%
%                     \else\if!!donea \def\raggedcommand{\veryraggedcenter}%
%                     \else           \def\raggedcommand{\raggedcenter}%
%                     \fi\fi
%                     \!!donecfalse                   % {\v!midden,\v!midden}
%                   \else
%                     \let\raggedbottomcommand\vfilll % bonus, pretty strong
%                     \let\raggedtopcommand   \vfilll % used with \framed for
%                   \fi,                              % instance in tables
%          \v!hoog=>\let\raggedbottomcommand\vfilll,  % and since we lack a
%          \v!laag=>\let\raggedtopcommand   \vfilll,  % proper keyword, but
%          \v!laho=>\let\raggedbottomcommand\vfilll   % we do support the
%                   \let\raggedtopcommand   \vfilll,  % ugly laho (lohi)
%           \v!nee=>\def\raggedcommand{\raggedright},
%            \v!ja=>\let\raggedcommand\notragged,  % was \relax
%       \v!normaal=>\let\raggedcommand\notragged]} % was \relax
%
% much faster and important since TABLE uses them a lot:

\def\dodosetraggedcommand#1% beware: #1=empty is ignored, keep that!
  {\let\raggedcommand\relax
   \let\raggedtopcommand\empty
   \let\raggedbottomcommand\empty
   \doifsomething{#1}
     {\doifinsetelse\v!ruim {#1}\!!doneatrue\!!doneafalse
      \doifinsetelse\v!breed{#1}\!!donebtrue\!!donebfalse
      \!!donectrue
      \rawprocesscommalist[#1]\dododosetraggedcommand}}

\def\dododosetraggedcommand#1%
  {\executeifdefined{\@@ragged@@command\string#1}\relax}

\def\@@ragged@@command{@@raggedcommand}

\setvalue{\@@ragged@@command\v!links}%
  {\if!!donea \def\raggedcommand{\veryraggedleft}%
   \else      \def\raggedcommand{\raggedleft}%
   \fi
   \!!donecfalse}

\setvalue{\@@ragged@@command\v!rechts}%
  {\if!!donea \def\raggedcommand{\veryraggedright}%
   \else      \def\raggedcommand{\raggedright}%
   \fi
   \!!donecfalse}

\setvalue{\@@ragged@@command\v!midden}%
  {\if!!donec
     \if!!doneb      \def\raggedcommand{\raggedwidecenter}%
     \else\if!!donea \def\raggedcommand{\veryraggedcenter}%
     \else           \def\raggedcommand{\raggedcenter}%
     \fi\fi
     \!!donecfalse
   \else
     \let\raggedbottomcommand\vfilll % bonus, pretty strong
     \let\raggedtopcommand   \vfilll % used with \framed for
   \fi}                              % instance in tables

\setvalue{\@@ragged@@command\v!hoog}%
  {\let\raggedbottomcommand\vfilll}  % and since we lack a

\setvalue{\@@ragged@@command\v!laag}%
  {\let\raggedtopcommand\vfilll}     % proper keyword, but

\setvalue{\@@ragged@@command\v!laho}%
  {\let\raggedbottomcommand\vfilll   % we do support the
   \let\raggedtopcommand\vfilll}     % ugly laho (lohi)

\setvalue{\@@ragged@@command\v!nee}%
  {\def\raggedcommand{\raggedright}}

\setvalue{\@@ragged@@command\v!ja}%
  {\let\raggedcommand\notragged}

\setvalue{\@@ragged@@command\v!normaal}%
  {\let\raggedcommand\notragged}

\setvalue{\@@ragged@@command\v!binnen}% not yet perfect
  {\signalrightpage % may interfere
   \getvalue{\@@ragged@@command\doifrightpageelse\v!rechts\v!links}}

\setvalue{\@@ragged@@command\v!buiten}% not yet perfect
  {\signalrightpage % may interfere
   \getvalue{\@@ragged@@command\doifrightpageelse\v!links\v!rechts}}

% Nodig i.v.m. inspringen eerste alineas

\def\explicithmode{\unhbox\voidb@x}

% Nodig voor gebruikers

\def\geentest{\donottest}

% Nog doen:
%
%  \goodbreak -> \allowbreak en \dosomebreak{..} in koppen
%
% bij koppen zowieso: \blanko[reset]

% Nog in commando verwerken:
%
% \voorkeur  la \blanko
%
% Om ongewenste witruimte te voorkomen kan met \dosomebreak{\break}
% een \penalty vr witruimte worden geplaatst.

\def\removelastskip% a redefinition of plain
  {\ifvmode\ifdim\lastskip=\zeropoint\else\vskip-\lastskip\fi\fi}

\def\dosomebreak#1%
  {\scratchskip\lastskip
   \removelastskip
   %\type{#1}%
   #1\relax
   \ifdim\scratchskip=\zeropoint \else
     \vskip\scratchskip
   \fi}

% beter, vooral in \vbox; nog in \pagina toepassen s!

\def\doifoutervmode#1%
  {\ifvmode\ifinner\else#1\fi\fi}

\def\dosomebreak#1%
  {\doifoutervmode
     {\scratchskip\lastskip
      \removelastskip
      %\leavevmode\type{#1}%
      #1\relax
      \ifdim\scratchskip=\zeropoint % else interference with footnotes
      \else
        \vskip\scratchskip
      \fi}}

% Idem:
%
% \springin

%\def\noindentation% vervallen
%   {\EveryPar
%     {\ifdim\parindent=\zeropoint
%      \else
%        \bgroup
%        \setbox\scratchbox\lastbox
%        \egroup
%      \fi
%      \EveryPar{}}}

\newif\ifindentation \indentationtrue  % documenteren, naar buiten

\let\checkindentation=\relax

\def\donoindentation
  {\ifdim\parindent=\zeropoint \else
     \bgroup \setbox\scratchbox\lastbox \egroup
   \fi}

\def\noindentation % made global
  {\ifinpagebody \else
     \global\indentationfalse
     \gdef\checkindentation
       {\donoindentation
        \gdef\checkindentation{\global\indentationtrue}}%
   \fi}

\def\nonoindentation % bv bij floats
  {\ifinpagebody \else
     \global\indentationtrue
     \gdef\checkindentation{\global\indentationtrue}%
   \fi}

\def\indentation
  {\ifvmode \ifdim\parindent=\zeropoint \else
     % was : \hskip\parindent
     % can be: \indent
     % but we test:
     \noindent\hskip\parindent
   \fi \fi}

% vergeten

%\def\forgeteverypar
%  {\everypar\emptytoks}

\def\forgeteverypar
  {\everypar{\the\neverypar}}

%\def\forgetparindent
%  {\forgeteverypar
%   \indentfirstparagraphtrue % recently added
%   \setupindenting[\v!geen]}

%\def\forgetparskip
%  {\setupwhitespace[\v!geen]}

\def\forgetparindent
  {\forgeteverypar
   \indentfirstparagraphtrue % recently added
   \let\currentvoorwit\v!geen
   \voorwit\zeropoint
   \parindent\zeropoint\relax}

\def\forgetparskip
  {\let\currentwitruimte\v!geen
   \tussenwit\zeropoint
   \parskip\zeropoint\relax}

\def\forgetbothskips
  {\tolerance1500
   \leftskip\zeropoint
   \rightskip\zeropoint\relax}

\def\forgetspacing
  {\emergencystretch\zeropoint}

\def\forgetall
  {\the\everyforgetall}

\newif\ifforgotten % rather good signal for inner

\appendtoks \forgottentrue      \to \everyforgetall
\appendtoks \forgetragged       \to \everyforgetall
\appendtoks \forgetparskip      \to \everyforgetall
\appendtoks \forgetparindent    \to \everyforgetall
\appendtoks \forgetbothskips    \to \everyforgetall
\appendtoks \forgetspacing      \to \everyforgetall % i.v.m. funny spacing in pagebody
\appendtoks \everypar\emptytoks \to \everyforgetall % indeed!

\def\localvbox#1#%
  {\vbox#1\bgroup
     \forgetparskip
     \setlocalhsize
     \hsize\localhsize
     \forgetparindent
     \forgetbothskips
     \forgeteverypar
     \let\next=}

% ach ja, hoort niet hier

% \unexpanded\def\dostartattributes#1#2#3%
%   {\begingroup  % geen \bgroup, anders in mathmode lege \hbox
%    \doifdefinedelse{#1#2}
%      {\def\fontattribute{\getvalue{#1#2}}}
%      {\let\fontattribute=\empty}%
%    \doifdefinedelse{#1#3}
%      {\def\colorattribute{\getvalue{#1#3}}}
%      {\let\colorattribute=\empty}%
%    \startcolor[\colorattribute]%
%    \@EA\doconvertfont\@EA{\fontattribute}}
%
% \unexpanded\def\dostopattributes%
%   {\stopcolor
%    \endgroup}
%
% \unexpanded\def\doattributes#1#2#3#4%
%   {\dostartattributes{#1}{#2}{#3}{#4}\dostopattributes}

%D A hardly faster implementation follows. We cannot use
%D \type {csname} testing since the first argument can be
%D anything, even a raw fontswitch. No a real improvement
%D (some 5 seconds on 260 seconds for the maps bibliography).

\let\dostopattributes\relax % in case these commands end up in an edef

\beginTEX

\unexpanded\def\dostartattributes#1#2#3%
  {\begingroup  % geen \bgroup, anders in mathmode lege \hbox
   \@EA\ifx\csname#1#3\endcsname\relax
     \let\dostopattributes\@@nostopattributes
   \else
     \let\dostopattributes\@@dostopattributes
     \startcolor[\csname#1#3\endcsname]%
   \fi
   \@EA\ifx\csname#1#2\endcsname\relax
     \expandafter\gobbleoneargument
   \else
     \expandafter\doconvertfont
   \fi{\csname#1#2\endcsname}}

\endTEX

\beginETEX \ifcsname

\unexpanded\def\dostartattributes#1#2#3%
  {\begingroup  % geen \bgroup, anders in mathmode lege \hbox
   \ifcsname#1#3\endcsname
     \let\dostopattributes\@@dostopattributes
     \startcolor[\csname#1#3\endcsname]%
   \else
     \let\dostopattributes\@@nostopattributes
   \fi
   \ifcsname#1#2\endcsname
     \expandafter\doconvertfont
   \else
     \expandafter\gobbleoneargument
   \fi{\csname#1#2\endcsname}}

\endETEX

\unexpanded\def\@@dostopattributes
  {\stopcolor
   \endgroup}

\unexpanded\def\@@nostopattributes
  {\endgroup}

\unexpanded\def\doattributes#1#2#3#4%
  {\dostartattributes{#1}{#2}{#3}{#4}\dostopattributes}

% An even faster \ETEX\ version:

\beginETEX

% \unexpanded\def\dostartattributes#1#2#3%
%   {\begingroup  % geen \bgroup, anders in mathmode lege \hbox
%    \ifcsname#1#3\endcsname
%      \let\dostopattributes\@@dostopattributes
%      \startcolor[\csname#1#3\endcsname]%
%    \else
%      \let\dostopattributes\@@nostopattributes
%    \fi
%    \ifcsname#1#2\endcsname
%      \@EAEAEA\doconvertfont\@EA\@EA\csname#1#2\endcsname
%    \fi}
%
% \unexpanded\def\@@dostopattributes%
%   {\stopcolor
%    \endgroup}
%
% \unexpanded\def\@@nostopattributes%
%   {\endgroup}

\unexpanded\def\dostartattributes#1#2#3%
  {\begingroup  % geen \bgroup, anders in mathmode lege \hbox
   \ifincolor
     \ifcsname#1#3\endcsname
       \let\dostopattributes\@@dostopattributes
       \doglobalstartcolor[\csname#1#3\endcsname]%
     \else
       \let\dostopattributes\@@nostopattributes
     \fi
   \else
     \let\dostopattributes\@@nostopattributes
   \fi
   \ifcsname#1#2\endcsname
     \@EAEAEA\doconvertfont\@EA\@EA\csname#1#2\endcsname
   \fi}

\unexpanded\def\@@dostopattributes
  {\doglobalstopcolor
   \endgroup}

\unexpanded\def\@@nostopattributes
  {\endgroup}

\endETEX

%D Bonus macro, see core-sec.tex

\beginTEX

\unexpanded\def\dosetfontattribute#1#2%
  {\@EA\ifx\csname#1#2\endcsname\relax\else
     \@EAEAEA\doconvertfont\@EA\@EA\csname#1#2\endcsname
   \fi\empty}

\endTEX

\beginETEX \ifcsname

\unexpanded\def\dosetfontattribute#1#2%
  {\ifcsname#1#2\endcsname
     \@EAEAEA\doconvertfont\@EA\@EA\csname#1#2\endcsname
   \fi\empty}

\endETEX

%D Since this happens a lot, and sometimes large arguments
%D are passed in \type {#4}, we just copy some code:

\beginETEX \ifcsname

\unexpanded\def\doattributes#1#2#3#4%
  {\begingroup  % geen \bgroup, anders in mathmode lege \hbox
   \ifincolor
     \ifcsname#1#3\endcsname
       \let\dostopattributes\@@dostopattributes
       \doglobalstartcolor[\csname#1#3\endcsname]%
     \else
       \let\dostopattributes\endgroup
     \fi
   \else
     \let\dostopattributes\endgroup
   \fi
   \ifcsname#1#2\endcsname
     \@EAEAEA\doconvertfont\@EA\@EA\csname#1#2\endcsname
   \fi
   {#4}%
   \dostopattributes}

\endETEX

% Kan vaker worden toegepast en moet bovendien sneller!

\newskip\leftskipadaption
\newskip\rightskipadaption

\def\doadaptleftskip#1%
  {\dosetleftskipadaption{#1}%
   \advance\leftskip \leftskipadaption}

\def\doadaptrightskip#1%
  {\dosetrightskipadaption{#1}%
   \advance\rightskip \rightskipadaption}

\beginTEX

\def\dosetleftskipadaption#1%
  {\leftskipadaption\zeropoint
   \processaction[#1]
     [\v!standaard=>\leftskipadaption
                    \ifdim\voorwit=\zeropoint\@@sllinks\else\voorwit\fi,
             \v!ja=>\leftskipadaption
                    \ifdim\voorwit=\zeropoint\@@sllinks\else\voorwit\fi,
            \v!nee=>,
        \s!unknown=>\leftskipadaption#1]}

\def\dosetrightskipadaption#1%
  {\rightskipadaption\zeropoint
   \processaction[#1]
     [\v!standaard=>\rightskipadaption\@@slrechts,
             \v!ja=>\rightskipadaption\@@slrechts,
            \v!nee=>,
        \s!unknown=>\rightskipadaption#1]}

\endTEX

\beginETEX

% installation

\setvalue{@lsa@\v!standaard}%
  {\ifdim\voorwit=\zeropoint\@@sllinks\else\voorwit\fi}

\setvalue{@lsa@\v!ja}%
  {\ifdim\voorwit=\zeropoint\@@sllinks\else\voorwit\fi}

\letvalue{@lsa@\v!nee      }\zeropoint
\letvalue{@lsa@\empty      }\zeropoint

\setvalue{@rsa@\v!standaard}{\@@slrechts}
\setvalue{@rsa@\v!ja       }{\@@slrechts}
\letvalue{@rsa@\v!nee      }\zeropoint
\letvalue{@rsa@\empty      }\zeropoint

% not safe for 2\parindent
%
% \def\dosetleftskipadaption#1%
%   {\leftskipadaption
%      \ifcsname @lsa@#1\endcsname
%        \csname @lsa@#1\endcsname
%      \else
%        #1%
%      \fi
%    \relax}

\def\dosetleftskipadaption#1%
  {\edef\ascii{@lsa@#1}%
   \convertcommand\ascii\to\ascii
   \leftskipadaption
     \ifcsname\ascii\endcsname
       \csname\ascii\endcsname
     \else
       #1%
     \fi
   \relax}

\def\dosetrightskipadaption#1%
  {\edef\ascii{@rsa@#1}%
   \convertcommand\ascii\to\ascii
   \rightskipadaption
     \ifcsname\ascii\endcsname
       \csname\ascii\endcsname
     \else
       #1%
     \fi
   \relax}

\endETEX

% Dit hoort eigenlijk thuis onder het kopje boodschappen cq,
% meldingen.

\let\mindermeldingen\dontcomplain

\definetwopasslist\s!paragraph

\newcounter\nofraggedparagraphs

\def\doparagraphreference% looks very much like domarginreference
  {\doglobal\increment\nofraggedparagraphs\relax
   \edef\writeparref%
     {\writeutilitycommand%
        {\twopassentry%
           {\s!paragraph}%
           {\nofraggedparagraphs}%
           {\noexpand\realfolio}}}%
   \writeparref}

% \def\setraggedparagraphmode#1#2%
%   {\ifinner
%      \ifdubbelzijdig
%        \gettwopassdata{\s!paragraph}%
%        \iftwopassdatafound
%          \ifodd\twopassdata#1\else#2\fi
%        \else
%          \ifodd\realfolio#1\else#2\fi
%        \fi
%        \doparagraphreference
%      \else
%        #2\relax
%      \fi
%    \else
%      #2\relax
%    \fi}

\def\setraggedparagraphmode#1#2% combineren met \ifrightpage
  {\ifinpagebody
     \ifdubbelzijdig
       \ifodd\realpageno\relax#1\else#2\fi
     \else
       #2\relax
     \fi
   \else\ifinner
     \ifdubbelzijdig
       \gettwopassdata\s!paragraph
       \iftwopassdatafound
         \ifodd\twopassdata\relax#1\else#2\fi
       \else
         \ifodd\realpageno\relax#1\else#2\fi
       \fi
       \doparagraphreference
     \else
       #2\relax
     \fi
   \else
     #2\relax
   \fi\fi}

% \let\doifrightpageelse\setraggedparagraphmode

% in both (otr) modules !

% \def\doifrightpageelse#1#2%
%   {\ifdubbelzijdig
%      \gettwopassdata\s!paragraph
%      \iftwopassdatafound
%        \ifodd\twopassdata#1\else#2\fi
%      \else
%        \ifodd\realfolio#1\else#2\fi
%      \fi
%    \else
%      #1% was #2
%    \fi}
%
% better :

\def\doifrightpageelse % watch out: other default ! ! !
  {\ifinpagebody
     \ifdubbelzijdig
       \ifodd\twopassdata\relax
         \twopassdatafoundtrue \else \twopassdatafoundfalse
       \fi
     \else
       \twopassdatafoundtrue
     \fi
   \else
     \ifdubbelzijdig
       \gettwopassdata\s!paragraph
       \iftwopassdatafound
         \ifodd\twopassdata\relax
           \twopassdatafoundtrue \else \twopassdatafoundfalse
         \fi
       \else
         \ifodd\realpageno\relax
           \twopassdatafoundtrue \else \twopassdatafoundfalse
         \fi
       \fi
     \else
       \twopassdatafoundtrue
     \fi
   \fi
   \iftwopassdatafound
     \@EA\firstoftwoarguments
   \else
     \@EA\secondoftwoarguments
   \fi}

\def\signalrightpage
  {\ifdubbelzijdig
     \doparagraphreference
   \fi}

% De onderstaande macro's zijn opgenomen in Plain TeX.
%
% \def\raggedright%
%   {\rightskip\z@ plus2em \spaceskip.3333em \xspaceskip.5em\relax}
%
% \def\ttraggedright%
%   {\tttf\rightskip\z@ plus2em\relax}
%
% \newif\ifr@ggedbottom
%
% \def\raggedbottom%
%   {\topskip 10\p@ plus60\p@ \r@ggedbottomtrue}
%
% \def\normalbottom%
%   {\topskip 10\p@ \r@ggedbottomfalse}
%
% en worden hieronder wat aangepast.

% the three boolean will become obsolete some day in favour
% of \bottomraggedness

\chardef\bottomraggedness=0 % 0=ragged 1=normal/align 2=baseline

\def\bottomalignlimit{3\lineheight}

\newif\ifn@rmalbottom
\newif\ifr@ggedbottom
\newif\ifb@selinebottom

\def\normalbottom%
  {% \topskip 10pt
   \r@ggedbottomfalse}

\def\raggedbottom
  {\chardef\bottomraggedness0
   \n@rmalbottomfalse
   \r@ggedbottomtrue
   \b@selinebottomfalse
   \settopskip}

\def\alignbottom
  {\chardef\bottomraggedness1
   \n@rmalbottomtrue
   \r@ggedbottomfalse
   \b@selinebottomfalse
   \settopskip}

\def\baselinebottom
  {\chardef\bottomraggedness2
   \n@rmalbottomfalse
   \r@ggedbottomfalse
   \b@selinebottomtrue
   \settopskip}

\let\normalbottom=\alignbottom % downward compatible

% so, the new one will be
%
% \chardef\bottomraggedness=0 % 0=ragged 1=normal/align 2=baseline
%
% \def\bottomalignlimit{3\lineheight} % will be settable
%
% \def\raggedbottom  {\chardef\bottomraggedness=0 \settopskip}
% \def\alignbottom   {\chardef\bottomraggedness=1 \settopskip}
% \def\baselinebottom{\chardef\bottomraggedness=2 \settopskip}
%
% \let\normalbottom  =\alignbottom

% \hyphenpenalty  = ( 2.5 * \hsize ) / \raggedness
% \tolerance     >= 1500 % was 200
% \raggedness     = 2 .. 6\korpsgrootte

\chardef\raggedstatus=0 % normal left center right

\def\leftraggedness   {2\bodyfontsize}
\def\rightraggedness  {2\bodyfontsize}
\def\middleraggedness {6\bodyfontsize}

%D More hyphenation control, will be combined with align
%D setup.

\def\nohyphens
  {\ifx\dohyphens\relax
     \edef\dohyphens
       {\hyphenpenalty\the\hyphenpenalty
        \exhyphenpenalty\the\exhyphenpenalty\relax}%
   \fi
   \hyphenpenalty\@M
   \exhyphenpenalty\@M}

\let\dohyphens\relax

%D To prevent unwanted side effects, we also have to check
%D for hyphens here:

\def\setraggedness#1%
  {\ifnum\tolerance<1500\relax    % small values have
     \tolerance1500\relax         % unwanted side effects
   \fi
   \spaceskip2.5\hsize            % we misuse these registers
   \xspaceskip#1\relax            % for temporary storage;
   \divide\spaceskip \xspaceskip  % they are changed anyway
   \ifx\dohyphens\relax
     \hyphenpenalty\spaceskip     % \else no hyphens is active
   \fi}

\let\updateraggedskips\relax

\def\setraggedskips#1#2#3#4#5#6#7% never change this name
  {\def\updateraggedskips%
     {\dosetraggedskips{#1}{#2}{#3}{#4}{#5}{#6}{#7}}%
   \updateraggedskips}

\def\dosetraggedskips#1#2#3#4#5#6#7%
  {\chardef    \raggedstatus#1\relax
   \leftskip   1\leftskip\!!plus#2\relax  % zie: Tex By Topic 8.1.3
   \rightskip  1\rightskip\!!plus#3\relax % zie: Tex By Topic 8.1.3
   \spaceskip  #4\relax
   \xspaceskip #5\relax
   \parfillskip\zeropoint\!!plus#6\relax
   \parindent  #7\relax}

% \def\notragged%
%   {\setraggedskips{0}{0em}{0em}{0em}{0em}{1fil}{\parindent}}

% todo

\def\raggedfillamount    {1fil}
\def\raggedhalffillamount{.5fil}
\def\raggedspaceamount   {.3333em}
\def\raggedxspaceamount  {.5em}

\def\notragged
  {\chardef\raggedstatus\zerocount
   \leftskip1\leftskip
   \rightskip1\rightskip
   \spaceskip\zeropoint
   \xspaceskip\zeropoint
   \parfillskip\zeropoint\!!plus\raggedfillamount\relax
   \let\updateraggedskips\relax} % new

\let\forgetragged\notragged

\def\raggedleft
  {\setraggedness\leftraggedness
   \setraggedskips1\leftraggedness\zeropoint\raggedspaceamount
     \raggedxspaceamount\zeropoint\zeropoint}

\def\raggedcenter
  {\setraggedness\middleraggedness
   \setraggedskips2\middleraggedness\middleraggedness\raggedspaceamount
     \raggedxspaceamount\zeropoint\zeropoint}

%D We used to have:
%D
%D \starttypen
%D \def\raggedright
%D   {\setraggedness\rightraggedness
%D    \setraggedskips{3}{0em}{\rightraggedness}{.3333em}{.5em}{0em}{\parindent}}
%D \stoptypen
%D
%D However, the next alternative, suggested by Taco, is better.

\def\raggedright
  {\setraggedness\rightraggedness
   \setraggedskips3\zeropoint\rightraggedness\raggedspaceamount
     \raggedxspaceamount\raggedfillamount\parindent}

\def\veryraggedleft
  {\setraggedskips1\raggedfillamount\zeropoint\raggedspaceamount
     \raggedxspaceamount\zeropoint\zeropoint}

%D When we want the last line to have a natural width:
%D
%D \starttypen
%D \def\veryraggedleft%
%D   {\setraggedskips{1}{1fil}{0em}{.3333em}{.5em}{0em}{-1fil}}
%D \stoptypen
%D
%D but this one is not accepted by the macros.

\def\veryraggedcenter
  {\setraggedskips2\raggedfillamount\raggedfillamount\raggedspaceamount
     \raggedxspaceamount\zeropoint\zeropoint}

\def\veryraggedright
  {\setraggedskips3\zeropoint\raggedfillamount\raggedspaceamount
     \raggedxspaceamount\zeropoint\parindent}

\def\ttraggedright
  {\tttf
   \setraggedskips3\zeropoint\rightraggedness
     \zeropoint\zeropoint\zeropoint\parindent} % \voorwit

%D A bonus one:

\def\raggedwidecenter
  {\setraggedness\middleraggedness
   \setraggedskips2\raggedhalffillamount\raggedhalffillamount
     \raggedspaceamount\raggedxspaceamount\zeropoint\zeropoint}

\newif\if@@asragged \@@asraggedtrue % old method

\def\dodosetupalign[#1]%
  {\doifinsetelse\v!ruim {#1}\!!doneatrue\!!doneafalse
   \doifinsetelse\v!breed{#1}\!!donebtrue\!!donebfalse
   \ExpandFirstAfter\processallactionsinset
     [#1]
     [   \v!regel=>\baselinebottom,
         \v!onder=>\raggedbottom,
        \v!hoogte=>\normalbottom,
       \v!breedte=>\notragged,
       \v!normaal=>\notragged,
            \v!ja=>\notragged,
           \v!nee=>\raggedright,
\if@@asragged\v!binnen\else\v!buiten\fi
                 =>\setraggedparagraphmode\raggedleft\raggedright,
\if@@asragged\v!buiten\else\v!binnen\fi
                 =>\setraggedparagraphmode\raggedright\raggedleft,
\if@@asragged\v!links\else\v!rechts\fi
                 =>\if!!donea\veryraggedleft  \else\raggedleft  \fi,
\if@@asragged\v!rechts\else\v!links\fi
                 =>\if!!donea\veryraggedright \else\raggedright \fi,
        \v!midden=>\if!!doneb\raggedwidecenter\else
                   \if!!donea\veryraggedcenter\else\raggedcenter\fi\fi,
       \v!hangend=>\enableprotruding,
   \v!niethangend=>\disableprotruding,
    \v!afgebroken=>\dohyphens,
\v!nietafgebroken=>\nohyphens,
         \v!nieuw=>\@@asraggedfalse, % so new will give you consistency
         \v!reset=>\notragged\normalbottom]}

\def\dosetupalign[#1]%
  {\expanded{\dodosetupalign[#1]}}

\def\setupalign
  {\dosingleargument\dosetupalign}

\def\startuitlijnen
  {\bgroup
   \setupalign}

\def\stopuitlijnen
  {\par
   \egroup}

\chardef\alignstrutmode=1

% see later for the real definition, which in the simple case is:

\def\doalignline#1#2% \\ == newline
 {\bgroup
  \setlocalhsize % new
  \def\\{\egroup\par\doalignline{#1}{#2}\bgroup}%
  \dowithnextbox
    {\noindent
     \hbox to \localhsize
       {\ifcase\alignstrutmode\or\strut\fi
         #1\unhbox\nextbox#2}\egroup}
    \hbox}

% directe commando's

\def\regellinks {\doalignline \relax \hss  }
\def\regelmidden{\doalignline \hss   \hss  }
\def\regelrechts{\doalignline \hss   \relax}

\def\regelbegrensd#1{\limitatetext{#1}{\hsize}{\unknown}}

% indirecte commando's

\setvalue{\s!do\v!regel\v!links }{\doalignline \relax \hss  }
\setvalue{\s!do\v!regel\v!rechts}{\doalignline \hss   \relax}
\setvalue{\s!do\v!regel\v!midden}{\doalignline \hss   \hss  }

\def\doregelplaats#1{\csname\s!do\v!regel#1\endcsname}

%D Experimental:

% simple version
%
% \def\doxalignline#1#2%
%   {\bgroup
%    \setlocalhsize
%    \def\\{\egroup\par\doxalignline{#1}{#2}\bgroup}% inefficient
%    \dowithnextbox
%      {\noindent\hbox to \localhsize
%         {\ifcase\alignstrutmode\or\strut\fi
%          \signalrightpage
%          \doifrightpageelse{#1\unhbox\nextbox#2}{#2\unhbox\nextbox#1}}%
%       \egroup}
%      \hbox}
%
% \setvalue{\s!do\v!regel\v!binnen}{\doxalignline\relax\hss}
% \setvalue{\s!do\v!regel\v!buiten}{\doxalignline\hss\relax}
%
% more extensive:

\def\doxalignline#1#2#3#4#5#6%
  {\bgroup
   \setlocalhsize
   \def\\{\egroup\par\doxalignline#1#2#3#4#5#6\bgroup}% inefficient
   \dowithnextbox
     {\noindent
      \hbox to \localhsize
        {#1\hskip\ifdone#2\else#3\fi#4%
         \hbox to \localhsize
           {\ifcase\alignstrutmode\or\strut\fi
            \ifdone#5\unhbox\nextbox#6\else#6\unhbox\nextbox#5\fi}%
         \hss}%
        \egroup}
     \hbox}

\def\doxcheckline
  {\signalrightpage\doifrightpageelse\donetrue\donefalse}

\setvalue{\s!do\v!regel\v!binnen      }{\doxalignline\doxcheckline++\zeropoint       \relax\hss  }
\setvalue{\s!do\v!regel\v!buiten      }{\doxalignline\doxcheckline++\zeropoint       \hss  \relax}
\setvalue{\s!do\v!regel\v!binnenmarge }{\doxalignline\doxcheckline-+\innermargintotal\relax\hss  }
\setvalue{\s!do\v!regel\v!buitenmarge }{\doxalignline\doxcheckline+-\outermargintotal\hss  \relax}
\setvalue{\s!do\v!regel\v!binnenrand  }{\doxalignline\doxcheckline-+\inneredgetotal  \relax\hss  }
\setvalue{\s!do\v!regel\v!buitenrand  }{\doxalignline\doxcheckline+-\outeredgetotal  \hss  \relax}
\setvalue{\s!do\v!regel\v!rugwit      }{\doxalignline\doxcheckline-+\rugwit          \relax\hss  }
\setvalue{\s!do\v!regel\v!snijwit     }{\doxalignline\doxcheckline+-\snijwit         \hss  \relax}

\setvalue{\s!do\v!regel\v!linkermarge }{\doxalignline\donefalse   --\leftmargintotal \hss  \relax}
\setvalue{\s!do\v!regel\v!rechtermarge}{\doxalignline\donefalse   ++\rightmargintotal\relax\hss  }
\setvalue{\s!do\v!regel\v!linkerrand  }{\doxalignline\donefalse   --\leftedgetotal   \hss  \relax}
\setvalue{\s!do\v!regel\v!rechterrand }{\doxalignline\donefalse   ++\rightedgetotal  \relax\hss  }

% ! ! ! beware, redefining \doalignline gives the wrong results ! ! !
%
% \def\doalignline{\doxalignline\donefalse++\zeropoint}

%D Better:

\def\doregelplaats#1{\csname\s!do\v!regel#1\endcsname}

\def\alignedline#1#2% setting default
  {\csname
     \s!do\v!regel
     \ifundefined{\s!do\v!regel#1}#2\else#1\fi
   \endcsname}

% \def\doregelplaats#1%
%   {\alignedline{#1}\v!links}

%D ...

\def\dosetuptolerance[#1]%
  {\doifinsetelse\v!vertikaal{#1}%
     {\ExpandFirstAfter\processallactionsinset
        [#1]
        [\v!zeerstreng=>\def\bottomtolerance{},
             \v!streng=>\def\bottomtolerance{.050},
             \v!soepel=>\def\bottomtolerance{.075},
         \v!zeersoepel=>\def\bottomtolerance{.100}]}%
     {\ExpandFirstAfter\processallactionsinset
        [#1]
        [       \v!rek=>\emergencystretch\bodyfontsize,
             \v!spatie=>\spaceskip.5em\!!plus.25em\!!minus.25em\relax,
         \v!zeerstreng=>\tolerance 200,
             \v!streng=>\tolerance1500,
             \v!soepel=>\tolerance3000,
         \v!zeersoepel=>\tolerance4500]}}

\def\setuptolerance
  {\dosingleargument\dosetuptolerance}

% \def\woordrechts
%   {\groupedcommand{\hfill\hbox}{\parfillskip\zeropoint}}

\def\woordrechts % zie naw
  {\groupedcommand
     {\removeunwantedspaces
      \hfill
      \hskip\zeropoint % permit break, \allowbreak fails here
      \strut
      \hfill
      \quad % decent spacing
      \hbox}
     {\parfillskip\zeropoint
      \par}}

%D \macros
%D   {pushindentation,popindentation}
%D
%D The pushing and popping is done by:

\newbox\indentationboxA
\newbox\indentationboxB

\def\pushindentation%
  {\bgroup
   \ifhmode
     \unskip
     \setbox\indentationboxA\lastbox       % get \strut if present
     \unskip
     \setbox\indentationboxB\lastbox       % get \indent generated box
     \unskip
   \else
     \hskip\zeropoint                      % switch to horizontal mode
     \unskip
     \setbox\indentationboxA\lastbox       % get \indent generated box
     \setbox\indentationboxB\box\voidb@x
   \fi}

\def\popindentation%
  {\box\indentationboxB\box\indentationboxA % put back the boxes
   \egroup}

%D The only complication lays in \type{\strut}. In \PLAIN\
%D \TEX\ a \type{\strut} is defined as:
%D
%D \starttypen
%D \def\strut%
%D   {\relax\ifmmode\copy\strutbox\else\unhcopy\strutbox\fi}
%D \stoptypen
%D
%D But what is a \type{\strut}? Normally it's a rule of width
%D zero, but when made visual, it's a rule and a negative skip.
%D The mechanism for putting things in the margins described
%D here cannot handle this situation very well. One
%D characteristic of \type{\strut} is that the \type{\unhcopy}
%D results in entering horizontal mode, which in return leads
%D to some indentation.
%D
%D To serve our purpose a bit better, the macro \type{\strut}
%D can be redefined as:
%D
%D \starttypen
%D \def\strut
%D   {\relax\ifmmode\else\hskip0pt\fi\copy\strutbox}
%D \stoptypen
%D
%D Or more compatible:
%D
%D \starttypen
%D \def\strut
%D   {\relax\ifmmode
%D      \copy\strutbox
%D    \else
%D      \bgroup\setbox\strutbox=\normalhbox{\box\strutbox}\unhcopy\strutbox\egroup
%D    \fi}
%D \stoptypen
%D
%D In \CONTEXT\ however we save some processing time by putting
%D an extra \type{\hbox} around the \type{\strutbox}.

% moved from page-lin.tex to here (due to visualization added
% in august 2003)
%
% \unexpanded \def\crlf
%   {\ifhmode\unskip\else\strut\fi\ifcase\raggedstatus\hfil\fi\break}

\unexpanded \def\crlf
  {\ifhmode
     \unskip
     \prewordbreak\crlfplaceholder
     \ifcase\raggedstatus\hfil\or\or\or\hfil\fi
     \break
   \else
     \crlfplaceholder
     \endgraf
   \fi}

\def\crlfplaceholder
  {\strut}

\def\settestcrlf
  {\def\crlfplaceholder
     {\hbox to \zeropoint
        {\strut{\infofont\kern.25em}\lohi{\infofont CR}{\infofont LF}\hss}}}

%D \starttyping
%D % \setuplayout[grid=yes] \showgrid
%D
%D \startbuffer
%D test 1\crlf
%D test 2\crlf
%D
%D \crlf test 3
%D
%D test 4\crlf
%D test 5
%D
%D \crlf
%D \crlf
%D \crlf
%D test 6
%D \stopbuffer
%D
%D \hbox
%D   {\hsize5em
%D    \ruledvtop{\getbuffer}\enspace
%D    \ruledvtop{\showstruts\getbuffer}\enspace
%D    \hsize15em \setuptyping[before=,after=]%
%D    \ruledvtop{\typebuffer}}
%D \stoptyping

\def\opeenregel % to be used grouped
  {\def\crlf{\removelastspace\space}\let\\\crlf}

\def\showstruts
  {\setteststrut
   \settestcrlf}

\def\definehspace
  {\dotripleempty\dodefinehspace}

\def\dodefinehspace[#1][#2][#3]% #1 = optional namespace
  {\ifthirdargument
     \setvalue{\??hs#1:#2}{#3}%
   \else
     \setvalue{\??hs:#1}{#2}%
   \fi}

\unexpanded\def\hspace
  {\dodoubleempty\dohspace}

%\def\dohspace[#1][#2]%
%  {\ifhmode
%     \removeunwantedspaces
%     \hskip
%     \ifsecondargument
%       \hspaceamount{#1}{#2}%
%     \else
%       \hspaceamount\empty{\iffirstargument#1\else\s!default\fi}%
%     \fi
%     \expandafter\ignorespaces
%   \fi}

\def\dohspace[#1][#2]%
  {\ifsecondargument
     \dodohspace[#1][#2]%
   \else\iffirstargument
     \hspace[][#1]%
   \else
     \hspace[][\s!default]%
   \fi\fi}

\def\dodohspace[#1][#2#3]%
  {\ifhmode
     \removeunwantedspaces
     \doifelse{#2}{-}
       {{\scratchskip\hspaceamount{#1}{#3}\hskip-\scratchskip}}
       {\hskip\hspaceamount{#1}{#2#3}}%
     \expandafter\ignorespaces
    \fi}

\def\hspaceamount#1#2%
  {\executeifdefined{\??hs#1:#2}{\executeifdefined{\??hs:#2}\zeropoint}}

\def\emspaceamount{\fontdimen6\font}
\def\spaceamount  {\fontdimen2\font}

\definehspace [\v!klein]   [.25\emspaceamount]
\definehspace [\v!middel]  [.5\emspaceamount]
\definehspace [\v!groot]   [1\emspaceamount]
\definehspace [\v!normaal] [1\spaceamount]
\definehspace [\v!default] [\spaceamount]

%D Taken from Taco's math module (cq. \AMS\ macros), but
%D adapted to \type {\hspace}:

\unexpanded\def\textormathspace#1#2#3%
  {\ifmmode\mskip#1#2\else\kern#1\hspaceamount\empty{#3}\fi\relax}

\def\thinspace    {\textormathspace+\thinmuskip 1}
\def\medspace     {\textormathspace+\medmuskip  2}
\def\thickspace   {\textormathspace+\thickmuskip3}
\def\negthinspace {\textormathspace-\thinmuskip 1}
\def\negmedspace  {\textormathspace-\medmuskip  2}
\def\negthickspace{\textormathspace-\thickmuskip3}

\let \, \thinspace
\let \: \medspace
\let \; \thickspace
\let \! \negthinspace

\definehspace[1][.1667em]
\definehspace[2][.2222em]
\definehspace[3][.2777em]

% Very nasty but needed for margin stuff inside colored
% paragraphs.

\let\normalvadjust\vadjust

\def\graphicvadjust % bad, those low level color calls here
  {\dowithnextbox
     {\normalvadjust
        {\dostartgraphicgroup
         \localstarttextcolor
         \unvbox\nextbox
         \localstoptextcolor
         \dostopgraphicgroup}}%
     \vbox}

%D This works only in a properly strutted line, and is meant
%D for deeply burried operations, like in heads.

\def\fakedvadjust
  {\dowithnextbox
     {\setbox\nextbox\hbox{\llap{\lower\strutdepth\box\nextbox}}%
      \smashedbox\nextbox}%
   \vtop}

\def\flexiblespaceamount#1#2#3%
         {#1\fontdimen2\font
   \!!plus#2\fontdimen3\font
  \!!minus#3\fontdimen4\font}

\def\fixedspaceamount#1%
         {#1\fontdimen2\font}

\setupwhitespace
  [\v!geen]

\inspringen
  [\v!nooit]

\setupindenting
  [\v!geen]

\setupblank
  [\v!standaard,
   \v!groot]

\definieerblanko[\v!default] [\currentblanko]
\definieerblanko[\v!voor]    [\v!default]
\definieerblanko[\v!tussen]  [\v!default]
\definieerblanko[\v!na]      [\v!voor]

% doen?

\def\@@blankovoor  {\blanko[\v!voor]}   %
\def\@@blankotussen{\blanko[\v!tussen]} %  scheelt 5 tokens == >20 bytes
\def\@@blankona    {\blanko[\v!na]}     %

\setupinterlinespace
  [\c!hoogte=.72,
   \c!diepte=.28,
   \c!boven=1.0,
   \c!onder=0.4,
   \c!afstand=1pt,
   \c!regel=2.8ex,
   \c!rek=0]

\setupnarrower
  [\c!links=1.5em,
   \c!rechts=1.5em,
   \c!midden=1.5em]

\setuptolerance
  [\v!horizontaal,\v!zeerstreng]

\setuptolerance
  [\v!vertikaal,\v!streng]

\setupalign
  [\v!onder,
   \v!breedte]

\setupspacing
  [\v!opelkaar]

\protect \endinput
