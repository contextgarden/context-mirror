%D \module
%D   [       file=core-spa,
%D        version=1997.03.31,
%D          title=\CONTEXT\ Core Macros,
%D       subtitle=Spacing,
%D         author=Hans Hagen,
%D           date=\currentdate,
%D      copyright={PRAGMA / Hans Hagen \& Ton Otten}]
%C
%C This module is part of the \CONTEXT\ macro||package and is
%C therefore copyrighted by \PRAGMA. See mreadme.pdf for
%C details.

\writestatus{loading}{Context Spacing Macros}

\unprotect 

\newevery \everybodyfont   \Everybodyfont   % just to be sure
\newevery \everyfontswitch \EveryFontSwitch % just to be sure

\appendtoks \presetnormallineheight \to \everybodyfont
\appendtoks \setnormalbaselines     \to \everybodyfont
\appendtoks \setstrut               \to \everybodyfont
\appendtoks \settopskip             \to \everybodyfont
\appendtoks \setmaxdepth            \to \everybodyfont
\appendtoks \spacing               1\to \everybodyfont
\appendtoks \stelinspringenin       \to \everybodyfont
\appendtoks \stelblankoin           \to \everybodyfont
\appendtoks \stelwitruimtein        \to \everybodyfont
%appendtoks \setupfootnotes         \to \everybodyfont % not
\appendtoks \stelspatieringin       \to \everybodyfont % nieuw
\appendtoks \setdisplayskips        \to \everybodyfont % nieuw

\appendtoks \updateraggedskips      \to \everyfontswitch  % under test 

\def\stelfactorenin%
  {\stelwitruimtein
   \stelblankoin
   \settopskip
   \setmaxdepth}

%D The dreadful sequence \type {\bgroup} \unknown\
%D \type{\carryoverpar} \unknown\ \type{\egroup} is needed
%D when for instance sidefloats are used in combination with
%D something that starts with a group. This is because
%D otherwise the indentation as set (by the output routine)
%D inside the group are forgotten afterwards. 

\global\let\carriedoverpar\relax 

\def\carryoverpar#1%
  {\expanded
     {\noexpand#1%
      \hangindent\the\hangindent
      \hangafter \the\hangafter
      \parskip   \the\parskip
      \leftskip  \the\leftskip
      \rightskip \the\rightskip}}

%D There are two ways to influence the interline spacing. The
%D most general and often most consistent way is using
%D
%D \showsetup{\y!stelinterliniein}
%D
%D For instance
%D
%D \starttypen
%D \setupinterlinespace[line=2.8ex]
%D \stoptypen
%D
%D This setting adapts itself to the bodyfontsize, while for
%D instance saying
%D
%D \starttypen
%D \setupinterlinespace[line=12pt]
%D \stoptypen
%D
%D sets things fixed for all sizes, which is definitely not
%D what we want. Therefore one can also say:
%D
%D \starttypen
%D \definecorpsenvironment[9pt][interlinespace=11pt]
%D \stoptypen
%D
%D One can still use \type{\setupinterlinespace} (without
%D arguments) to set the interline space according to the
%D current font, e.g. a \type{\bfa}.

\newif\iflocalinterlinespace

% font-ini

\ifx\bodyfontinterlinespecs\undefined

  \let\bodyfontinterlinespecs\empty
  \let\bodyfontinterlinespace\empty

\fi

\def\presetnormallineheight%
  {\edef\normallineheight{\@@itregel}%
   \iflocalinterlinespace \else
     \doifdefined{\bodyfontinterlinespecs}
       {\doifsomething{\bodyfontinterlinespace}
          {\edef\normallineheight{\bodyfontinterlinespace}}}%
   \fi}

\def\complexstelinterliniein[#1]% \commalistelement ipv #1
  {\doifassignmentelse{#1}
     {\getparameters[\??it][#1]%
      \scratchdimen=0\@@ithoogte pt
      \advance\scratchdimen by 0\@@itdiepte pt
      \ifdim\scratchdimen>1pt
        \showmessage{\m!layouts}{10}{\@@ithoogte,\@@itdiepte}%
        \let\@@ithoogte=\strutheightfactor
        \let\@@itdiepte=\strutdepthfactor
      \else
        \let\strutheightfactor=\@@ithoogte
        \let\strutdepthfactor=\@@itdiepte
      \fi
      \let\minimallinedistance=\@@itafstand
      \let\normallineheight=\@@itregel % let ! ! ! ! ! ivm ex 
      \let\topskipfactor=\@@itboven
      \let\maxdepthfactor=\@@itonder
      \setfontparameters % redundant, can be \setstrut, test first 
      \updateraggedskips} % yes indeed
     {\processallactionsinset % \regelwit = dummy !
        [#1]
        [     \v!aan=>\oninterlineskip,
              \v!uit=>\offinterlineskip,
            \v!reset=>\setfontparameters,% just \setstrut, test first 
          \s!unknown=>\assignvalue{#1}{\regelwit}{1.00}{1.25}{1.50}%
                      \spacing{\regelwit}]}}

\def\simplestelinterliniein%
  {\localinterlinespacetrue
   \setfontparameters
   \updateraggedskips % funny one here
   \localinterlinespacefalse}

\definecomplexorsimple\stelinterliniein

% In earlier versions \type{\bigskipamount} was
% \type{\ht\strutbox} and the stretch was plus or minus
% \type{.4\dp\strutbox}. Don't ask me why. The most recent
% implementation is based on a user supplied distance, which
% is by default \type{.75\normalskipamount} where
% \type{\normalskipamount} equals the current baseline
% distance.

\newif\ifblankoreset        \blankoresetfalse
\newif\ifblankoblokkeer     \blankoblokkeerfalse
\newif\ifblankogeenwit      \blankogeenwitfalse
\newif\ifdoeblanko          \doeblankofalse
\newif\ifblankoflexibel     \blankoflexibeltrue
\newif\ifblankobuiten
\newif\ifblankoforceer

\newskip\blankoskip         \blankoskip=\bigskipamount
\newskip\blankoskipamount

\def\skipfactor       {.75}
\def\skipgluefactor   {.25}

\def\normalskipamount%
  {\openlineheight
     \ifgridsnapping \else \ifblankoflexibel
       \!!plus\skipgluefactor\openlineheight
       \!!minus\skipgluefactor\openlineheight
     \fi \fi
   \relax}

\def\regelafstand{\normalskipamount}

\def\deblankoskip{\skipfactor\regelafstand}

\def\laatsteblankoskip%
  {\blankoskip}

\def\geenblanko%
  {\removelastskip}

\def\doassignsomeskip#1\to#2% ook nog \v!halveregel+fuzzysnap
  {\doifelse{#1}{\v!regel}
     {#2\openlineheight}
     {\ifgridsnapping
        \assigndimension{#1}{#2}%
          {.25\openlineheight}{.5\openlineheight}{\openlineheight}%
      \else
        \assigndimension{#1}{#2}%
          {\smallskipamount}{\medskipamount}{\bigskipamount}%
      \fi}}

\def\dosingleblanko#1% 
  {\doassignsomeskip#1\to\blankoskipamount 
   \global\advance\blankoskip by \blankoskipamount}

\newif\iffuzzyvskip

% old
%
% \def\doblanko#1%
%   {\processallactionsinset
%      [#1]
%      [    \v!groot=>\dosingleblanko\v!groot, % happens often
%          \v!buiten=>\ifvmode\ifinner\blankobuitentrue\fi\fi,
%           \v!reset=>\global\blankoresettrue,
%        \v!flexibel=>\global\lokaalblankoflexibeltrue,
%            \v!vast=>\global\lokaalblankovasttrue,
%            \v!back=>\geenblanko,
%             \v!wit=>\global\advance\blankoskip by \parskip,
%         \v!formule=>\global\advance\blankoskip by \medskipamount,
%         \v!geenwit=>\global\blankogeenwittrue,
%            -\v!wit=>\global\advance\blankoskip by -\parskip,
%        \v!blokkeer=>\global\blankoblokkeertrue,
%         \v!forceer=>\global\blankoforceertrue,
%           \v!regel=>\global\advance\blankoskip by \lineheight,
%      \v!halveregel=>\global\fuzzyvskiptrue\global\advance\blankoskip by .5\lineheight,
%         \s!unknown=>{\herhaalmetcommando[#1]\dosingleblanko}]}
%
% new, see below

\def\doblanko#1%
  {\processallactionsinset
     [#1]
     [    \v!groot=>\dosingleblanko\v!groot, % happens often
         \v!buiten=>\ifvmode\ifinner\blankobuitentrue\fi\fi,
          \v!reset=>\global\blankoresettrue,
       \v!flexibel=>\global\lokaalblankoflexibeltrue,
           \v!vast=>\global\lokaalblankovasttrue,
           \v!back=>\geenblanko,
            \v!wit=>\global\advance\blankoskip by \parskip,
        \v!formule=>\global\advance\blankoskip by \medskipamount,
        \v!geenwit=>\global\blankogeenwittrue,
           -\v!wit=>\global\advance\blankoskip by -\parskip,
       \v!blokkeer=>\global\blankoblokkeertrue,
        \v!forceer=>\global\blankoforceertrue,
          \v!regel=>\global\advance\blankoskip by \lineheight,
     \v!halveregel=>\global\fuzzyvskiptrue\global\advance\blankoskip by .5\lineheight,
        \s!unknown=>\doindirectblanko{#1}]}

\def\oldprevdepth{\prevdepth}%
\def\newprevdepth{-1001pt}

\def\mindimen{0.00002pt} % beter 1sp 

\newif\iflokaalblankovast
\newif\iflokaalblankoflexibel

\def\docomplexdoblanko[#1]% pas op \relax's zijn nodig ivm volgende \if
  {\global\blankoresetfalse
   \global\blankoblokkeerfalse
   \global\blankogeenwitfalse
   \global\lokaalblankoflexibelfalse
   \global\lokaalblankovastfalse
   \global\blankoskip=\!!zeropoint
   \global\blankoforceerfalse
   \blankobuitenfalse
   \processcommalist[#1]\doblanko
\ifdim\blankoskip=\!!zeropoint\relax
  \iflokaalblankoflexibel \dosingleblanko\currentblanko \fi
  \iflokaalblankovast     \dosingleblanko\currentblanko \fi
\fi
   \ifblankobuiten
   \else
     \par
     \ifvmode          %in pos fonts gaat dit mis 
       \ifblankoforceer%\ifdim\prevdepth>\!!zeropoint\else
         % -1000pt signals top of page or column (\ejectcolumn)
         \vbox{\strut}\kern-\lineheight
       \fi%\fi
       \ifblankoblokkeer
         \global\doeblankofalse
         \edef\oldprevdepth{\the\prevdepth}%
         \prevdepth=\newprevdepth
       \else
         \global\doeblankotrue
       \fi
       \ifblankoreset
         \global\doeblankotrue
         \ifdim\prevdepth=\newprevdepth
           \prevdepth=\oldprevdepth
         \fi
       \fi
       \ifdoeblanko
         \ifdim\lastskip<\blankoskip\relax
           % else when \blanko[2*groot] + \blanko[3*groot] with parskip
           % equaling 1*groot, gives a groot=\parskip so adding a small
           % value makes it distinguishable; can also be done at parskip
           % setting time (better)
           \global\advance\blankoskip by \mindimen\relax % = skip
           % test this on 2* + 3* and parskip groot
           \ifblankogeenwit
             \global\advance\blankoskip by -\parskip
           \else
             \ifdim\lastskip=\parskip
             \else  % force this due to previous comment
               \ifdim\parskip>\!!zeropoint\relax
                 \ifdim\blankoskip<\parskip\relax
                   \global\blankoskip=\!!zeropoint
                 \else
                   \global\advance\blankoskip by -\parskip
                 \fi
               \fi
             \fi
           \fi
\ifblankoflexibel \else
  \blankoskip=1\blankoskip 
\fi
\iflokaalblankovast 
  \blankoskip=1\blankoskip 
\fi
\iflokaalblankoflexibel       
  \blankoskip=1\blankoskip 
    \!!plus\skipgluefactor\blankoskip
    \!!minus\skipgluefactor\blankoskip
\fi
           \ifdim\prevdepth=\newprevdepth
           \else
             \iffuzzyvskip
               \removelastfuzzyvskip
               \fuzzyvskip\blankoskip\relax
             \else
               \removelastskip
               \vskip\blankoskip\relax
             \fi
           \fi
         \else
           \iffuzzyvskip
             \removelastfuzzyvskip
             \fuzzyvskip\blankoskip\relax
           \fi
         \fi
       \fi
     \fi
   \fi
   \global\fuzzyvskipfalse
   \presetindentation}

\def\complexdodoblanko[#1]%
  {\flushfootnotes
   \ifopelkaar
     \ifinpagebody
       \expanded{\docomplexdoblanko[#1]}% \expanded=nieuw
     \else
       \par
     \fi
   \else
     \expanded{\docomplexdoblanko[#1]}% \expanded = nieuw
   \fi}

% old
%
% \def\doindirectblanko#1%
%   {\ifundefined{\??bo#1}% <-etex \expandafter\ifx\csname\??bo#1\endcsname\relax
%      \expanded{\complexdodoblanko[#1]}%
%    \else
%      \expandafter\complexdoblanko\expandafter[\csname\??bo#1\endcsname]%
%    \fi}
%
% \def\complexdoblanko[#1]% enables [force,8\bodyfontsize]
%   {\doifinstringelse{,}{#1}
%      {\expanded{\complexdodoblanko[#1]}}
%      {\doifnumberelse{#1}
%         {\expanded{\complexdodoblanko[#1]}}
%         {\doindirectblanko{#1}}}}
%
% new, more robust 
%
% \def\doindirectblanko#1%
%   {\edef\ascii{#1}\convertcommand\ascii\to\ascii
%    \ifundefined{\??bo\ascii}% <-etex \expandafter\ifx\csname\??bo#1\endcsname\rel
%      \herhaalmetcommando[#1]\dosingleblanko
%    \else
%      \expandafter\complexdoblanko\expandafter[\csname\??bo\ascii\endcsname]%
%    \fi}
% 
% even more robust

\def\doindirectblanko#1%
  {\edef\ascii{#1}\convertcommand\ascii\to\ascii
   \ifundefined{\??bo\ascii}% <-etex \expandafter\ifx\csname\??bo#1\endcsname
     \expanded{\herhaalmetcommando[#1]\noexpand\dosingleblanko}%
   \else
     \expandafter\complexdoblanko\expandafter[\csname\??bo\ascii\endcsname]%
   \fi}

\def\complexdoblanko[#1]% enables [force,8\bodyfontsize]
  {\expanded{\complexdodoblanko[#1]}}

\def\currentblanko%
  {\v!groot}

%D For a long time we had: 
%D
%D \starttypen 
%D \def\simpledoblanko%
%D   {\doifelse{\currentwitruimte}{\v!geen}
%D      {\blanko[\currentblanko]}
%D      {\blanko[\currentwitruimte]}}
%D \stoptypen
%D
%D But Berend de Boer wanted more control, so now we have:  

\def\simpledoblanko%
  {\doifelse{\currentwitruimte}{\v!geen}
     {\blanko[\currentblanko]}
     {\blanko[\s!default]}}

%D Another useful definition would be:
%D
%D \starttypen 
%D \definieerblanko
%D   [\s!default]
%D   [\v!groot]
%D \stoptypen

\def\blanko% % the \relax is definitely needed due to the many \if's
  {\relax\complexorsimple\doblanko}

%\def\dostelblankoin#1%
%  {\bgroup % rommelig 
%   \skip0=#1\relax
%   \xdef\globalblanko{\the\skip0}%
%   \egroup
%   \bigskipamount=\globalblanko
%   \smallskipamount=\globalblanko
%   \medskipamount=\globalblanko
%   \divide\medskipamount by 2\relax
%   \divide\smallskipamount by 4\relax}%

\def\dostelblankoin#1%
  {\bigskipamount=#1\relax
   \ifblankoflexibel \else
     \bigskipamount=1\bigskipamount
   \fi
   \smallskipamount=\bigskipamount
   \medskipamount=\bigskipamount
   \divide\medskipamount by 2
   \divide\smallskipamount by 4 }%

\def\complexstelblankoin[#1]%
  {\ifgridsnapping
     \blankoflexibelfalse
   \else
     \ExpandFirstAfter\processallactionsinset
       [#1]
       [ \v!flexibel=>\blankoflexibeltrue,
             \v!vast=>\blankoflexibelfalse]%
   \fi
   \ExpandFirstAfter\processallactionsinset
     [#1]
     [ \v!flexibel=>\dostelblankoin{\deblankoskip},
           \v!vast=>\dostelblankoin{\deblankoskip},
          \v!regel=>\edef\deblankoskip{\regelafstand}%
                    \dostelblankoin{\deblankoskip}%
                    \let\deblanko=\v!groot,
     \v!halveregel=>\scratchskip=.5\regelafstand
                    \edef\deblankoskip{\the\scratchskip}%
                    \dostelblankoin{\deblankoskip}%
                    \let\deblanko=\v!middel,
          \v!groot=>\ifgridsnapping
                      \edef\deblankoskip{\regelafstand}%
                      \dostelblankoin{\deblankoskip}%
                    \fi
                    \def\currentblanko{\v!groot}%
                    \let\deblanko=\v!groot,
         \v!middel=>\def\currentblanko{\v!middel}%
                    \let\deblanko=\v!middel,
          \v!klein=>\def\currentblanko{\v!klein}%
                    \let\deblanko=\v!klein,
        \v!normaal=>\dostelblankoin{\deblankoskip}%
                    \let\deblanko=\v!groot,
      \v!standaard=>\edef\deblankoskip{\skipfactor\regelafstand}%
                    \dostelblankoin{\deblankoskip}%
                    \let\deblanko=\v!groot,
        \s!default=>\dostelblankoin{\deblankoskip}%
                    \let\deblanko=\v!groot,
        \s!unknown=>\let\deblankoskip=\commalistelement
                    \dostelblankoin{\deblankoskip}%
                    \let\deblanko=\v!groot]%
   \stelwitruimtein}

% \definecomplexorsimpleempty\stelblankoin
%
% speed gain: 60 sec -> 30 sec

\definecomplexorsimple\stelblankoin

\def\simplestelblankoin% == snelle \stelblankoin[\s!default]
  {\ifgridsnapping
     \blankoflexibelfalse
   \fi
   \dostelblankoin{\deblankoskip}%
   \let\deblanko\v!groot
   \stelwitruimtein}

\def\dodefinieerblanko[#1][#2]%
  {\def\docommando##1{\setvalue{\??bo##1}{#2}}%
   \processcommalist[#1]\docommando}

\def\definieerblanko%
  {\dodoubleargument\dodefinieerblanko}

\def\savecurrentblanko%
  {\edef\restorecurrentblanko%
     {\bigskipamount=\the\bigskipamount
      \medskipamount=\the\medskipamount
      \smallskipamount=\the\smallskipamount
      \noexpand\def\noexpand\currentblanko{\currentblanko}%
      \ifblankoflexibel
        \noexpand\blankoflexibeltrue
      \else
        \noexpand\blankoflexibelfalse
      \fi}}

\def\inhibitblank% the fast, local way
  {\endgraf\ifvmode\prevdepth\newprevdepth\fi}

%D Now. 

\definieerblanko
  [\s!default]
  [\v!wit]

\let\currentvoorwit=\empty

\newdimen\voorwit

\newif\ifindentfirstparagraph % \indentfirstparagraphtrue

\def\presetindentation%
  {\doifoutervmode
     {\ifindentfirstparagraph\else\noindentation\fi}}

%\def\dostelinspringenin[#1]%
%  {\processallactionsinset
%     [#1]
%     [   \v!eerste=>\indentfirstparagraphtrue,
%       \v!volgende=>\indentfirstparagraphfalse,
%        \s!default=>\dodostelinspringenin,
%        \s!unknown=>\edef\currentvoorwit{\commalistelement}%
%                    \dodostelinspringenin]}
%
%\def\dodostelinspringenin%
%  {\assigndimension{\currentvoorwit}{\voorwit}{1em}{1.5em}{2em}%
%   \parindent=\voorwit\relax}
%
%\def\stelinspringenin%
%  {\dosingleempty\dostelinspringenin}

\definecomplexorsimple\stelinspringenin

\def\complexstelinspringenin[#1]%
  {\processallactionsinset
     [#1]
     [   \v!eerste=>\indentfirstparagraphtrue,
       \v!volgende=>\indentfirstparagraphfalse,
        \s!default=>\simplestelinspringenin,
        \s!unknown=>\edef\currentvoorwit{\commalistelement}%
                    \simplestelinspringenin]}

\def\simplestelinspringenin
  {\assigndimension{\currentvoorwit}{\voorwit}{1em}{1.5em}{2em}%
   \parindent=\voorwit\relax}

\def\doinspringen[#1]%
  {\processallactionsinset
     [#1]
     [    \v!nee=>\parindent=\voorwit\relax\noindent,
         \v!niet=>\parindent=\voorwit\relax\noindent,
           \v!ja=>\parindent=\voorwit\relax,            % geen \indent !
       \v!eerste=>\indentfirstparagraphtrue,
     \v!volgende=>\indentfirstparagraphfalse,
       \v!altijd=>\parindent=\voorwit\relax,            % geen \indent !
        \v!nooit=>\parindent=\!!zeropoint\relax]}

\def\inspringen%
  {\dosingleargument\doinspringen}

\def\nietinspringen{\inspringen[\v!nee,\v!volgende]}
\def\welinspringen {\inspringen[\v!ja,\v!eerste]}

% \frenchspacing leidt soms tot afbreken tussen -, vandaar
% de variant \newfrenchspacing.

\def\dofrenchspacing#1%
  {\sfcode`\.#1 \sfcode`\,#1\relax
   \sfcode`\?#1 \sfcode`\!#1\relax
   \sfcode`\:#1 \sfcode`\;#1\relax}

\def\frenchspacing%
  {\dofrenchspacing{1000}}   % \@m

\def\newfrenchspacing%
  {\dofrenchspacing{1050}}   % \@ml

\def\complexstelspatieringin[#1]%
  {\processaction
     [#1]
     [\v!opelkaar=>\newfrenchspacing,
          \v!ruim=>\nonfrenchspacing]%
   \updateraggedskips}

\def\simplestelspatieringin%
  {\updateraggedskips}

\definecomplexorsimple\stelspatieringin

\bgroup
\catcode`\~=\@@active       % eigenlijk is ~ al actief
\gdef\fixedspaces%          % in Plain \TeX, maar we weten
  {\catcode`\~=\@@active    % nooit wat er inmiddels is
   \def~{\fixedspace}}      % gebeurd, vandaar.
\egroup

\def\space      { }
\def\fixedspace {\hskip.5em\relax}
\def\nospace    {\unskip\ignorespaces}

\let\spatie     \space
\let\hardespatie\fixedspace
\let\geenspatie \nospace

\def\opelkaar%
  {\nointerlineskip}

\def\omlaag[#1]% nog eens mooier, relateren aan blanko
  {\nointerlineskip
   \vskip#1 }

\newskip\tussenwit
\tussenwit=\!!zeropoint

\def\blankokleinmaat%
  {\smallskipamount}

\def\blankomiddelmaat%
  {\medskipamount}

\def\blankogrootmaat%
  {\bigskipamount}

\def\currentwitruimte%
  {\!!zeropoint}

\def\stelwitruimteopnieuwin%
  {\expanded{\stelwitruimtein[\currentwitruimte]}}

\newif\ifwitruimteflexibel \witruimteflexibeltrue

%\def\dodostelwitruimtein[#1]%
%  {%\witruimteflexibeltrue
%   \processallactionsinset
%     [#1]
%     [\v!herstel=>,
%         \v!vast=>\witruimteflexibelfalse,
%     \v!flexibel=>\witruimteflexibeltrue,
%        \v!regel=>\tussenwit=\baselineskip,
%   \v!halveregel=>\tussenwit=.5\baselineskip,
%      \s!default=>\doifnot{\currentwitruimte}{\v!geen}
%                    {\stelwitruimteopnieuwin},
%      \s!unknown=>\@EA\assigndimension\@EA{\commalistelement} % \@EA is nodig
%                    {\tussenwit}
%                    {\blankokleinmaat}{\blankomiddelmaat}{\blankogrootmaat}]%   % te vangen
%   \edef\currentwitruimte%
%     {\ifdim\tussenwit=\!!zeropoint
%        \v!geen
%      \else
%        \ifgridsnapping\the\baselineskip\else\the\tussenwit\fi
%      \fi}%
%   \ifgridsnapping
%     \witruimteflexibelfalse
%     \tussenwit=1\tussenwit
%     \ifdim\tussenwit>\!!zeropoint
%       \tussenwit=\baselineskip
%     \fi
%   \else
%     \ifwitruimteflexibel \else \tussenwit=1\tussenwit \fi
%   \fi
%   \parskip=\tussenwit}
%
%\def\dostelwitruimtein[#1]%
%  {\expanded{\dodostelwitruimtein[#1]}}
%
%\def\stelwitruimtein%
%  {\dosingleempty\dostelwitruimtein}

\definecomplexorsimple\stelwitruimtein

\def\complexstelwitruimtein[#1]%
  {\expanded{\dostelwitruimtein[#1]}%
   \dodostelwitruimtein}

\def\dostelwitruimtein[#1]%
  {\processallactionsinset
     [#1]
     [\v!herstel=>,
         \v!vast=>\witruimteflexibelfalse,
     \v!flexibel=>\witruimteflexibeltrue,
        \v!regel=>\tussenwit=\baselineskip,
   \v!halveregel=>\tussenwit=.5\baselineskip,
      \s!default=>\doifnot{\currentwitruimte}{\v!geen}
                    {\stelwitruimteopnieuwin},
      \s!unknown=>\@EA\assigndimension\@EA{\commalistelement} % \@EA is nodig
                    {\tussenwit}
                    {\blankokleinmaat}{\blankomiddelmaat}{\blankogrootmaat}]}   % te vangen

\def\dodostelwitruimtein%
  {\edef\currentwitruimte%
     {\ifdim\tussenwit=\!!zeropoint
        \v!geen
      \else
        \ifgridsnapping\the\baselineskip\else\the\tussenwit\fi
      \fi}%
   \ifgridsnapping
     \witruimteflexibelfalse
     \tussenwit=1\tussenwit
     \ifdim\tussenwit>\!!zeropoint
       \tussenwit=\baselineskip
     \fi
   \else
     \ifwitruimteflexibel \else \tussenwit=1\tussenwit \fi
   \fi
   \parskip=\tussenwit}

\def\simplestelwitruimtein% == snelle \stelwitruimtein[\s!default]
  {\doifnot{\currentwitruimte}{\v!geen}
     {\stelwitruimteopnieuwin}%
   \dodostelwitruimtein}

\def\geenwitruimte%
  {\ifdim\parskip>\!!zeropoint\relax
     \ifdim\lastskip=-\parskip
     \else
       \vskip-\parskip
     \fi
   \fi}

\def\savecurrentwitruimte%
  {\edef\restorecurrentwitruimte%
     {\tussenwit=\the\tussenwit
      \parskip=\the\parskip
      \noexpand\def\noexpand\currentwitruimte{\currentwitruimte}%
      \ifwitruimteflexibel
        \noexpand\witruimteflexibeltrue
      \else
        \noexpand\witruimteflexibelfalse
      \fi}}

% deze variant is nodig binnen \startopelkaar
% steeds testen:
%
% \hoofdstuk{..}
% \plaatslijst[..]
% \hoofdstuk{..}
% \input tufte
%
% met/zonder witruimte

\def\witruimte%
  {\par
   \ifdim\parskip>\!!zeropoint\relax
    %\ifdim\lastskip>\parskip \else
     % \removelastskip interferes with blanko blokkeer en klein
       \vskip\parskip
    %\fi
   \fi}

\def\nonoblanko[#1]%
  {\par}

\def\noblanko%
  {\dosingleempty\nonoblanko}

% De onderstaande macro handelt ook de situatie dat er geen
% tekst tussen \start ... \stop is geplaatst. Daartoe wordt de
% laatste skip over de lege tekst heen gehaald. Dit komt goed
% van pas bij het plaatsen van (mogelijk lege) lijsten.

\newif\ifopelkaar

\def\noparskipsignal {0.00001pt}
\def\lastdoneparskip {0pt}

\def\startopelkaar%
  {\dosingleempty\dostartopelkaar}

\def\dostartopelkaar[#1]% nesting afvangen
  {\par
   \ifvmode
     \edef\lastdoneparskip{\the\lastskip}%
\edef\lastdoneprevdepth{\the\prevdepth}% zeer recent toegevoegd
     \ifdim\prevdepth=-1000pt   % toegevoegd omdat binnen
     \else                      % een vbox een extra skip
       \witruimte               % ongewenst is; dit kan
\baselinecorrection %% zie in \plaatsregister[n=1]
       \vskip\noparskipsignal   % waarschijnlijk ook in
     \fi                        % blanko blokkeer
     \bgroup
     \doifelse{#1}{\v!blanko}
       {\opelkaarfalse}
       {\opelkaartrue}%
     \blanko[\v!blokkeer]%
     \stelwitruimtein[\v!geen]
  \fi}

\def\stopopelkaar%
  {\par
\ifvmode
   \egroup
   \ifdim\lastskip=\noparskipsignal\relax
     \removelastskip
     \geenwitruimte
     \vskip-\lastdoneparskip
     \vskip+\lastdoneparskip
\prevdepth-\lastdoneprevdepth % zeer recent toegevoegd
   \fi
\fi}

\def\startvanelkaar%
  {\blanko
   \leavevmode
   \bgroup}

\def\stopvanelkaar%
  {\egroup
   \blanko}

% De onderstaande macro's moeten nog eens nader worden uitgewerkt.
% Ze spelen een rol bij de spatiering rond omkaderde teksten
% en/of boxen zonder diepte.

\def\toonregelcorrectie   {\showbaselinecorrection}
\def\regelcorrectie       {\baselinecorrection}

\definecomplexorsimpleempty\startregelcorrectie

% \prevdepth crosses pageboundaries!

\let\dorondomregelcorrectie=\relax

\def\complexstartregelcorrectie[#1]%
  {\bgroup
   \processaction
     [#1]
     [ \v!blanko=>\let\dorondomregelcorrectie=\blanko,
      \s!default=>\let\dorondomregelcorrectie=\relax,
      \s!unknown=>{\def\dorondomregelcorrectie{\blanko[#1]}}]%
   \dorondomregelcorrectie
   \startbaselinecorrection
   \offbaselinecorrection}

\def\stopregelcorrectie%
  {\stopbaselinecorrection
   \dorondomregelcorrectie
   \egroup}

\def\corrigeerwitruimte%
  {\dowithnextbox
     {\startbaselinecorrection
      \box\nextbox
      \stopbaselinecorrection}%
   \vbox}

\def\toonstruts%
  {\setteststrut}

% Hieronder volgen enkele instellingen en macro's ten behoeve
% van de interlinie en \strut. De waarden 2.8, 0.07, 0.72 en
% 0.28 zijn ooit eens ontleend aan INRS-TEX en moeten wellicht
% nog eens instelbaar worden.
%
%   \lineheight        : de hoogte van een regel
%   \spacing{getal}    : instellen interlinie
%   \normalbaselines   : instellen regelafstend
%
%   \setstrut          : instellen \strut
%   \setnostrut        : resetten \strut, \endstrut, \begstrut
%
%   \setteststrut      : instellen zichtbare struts
%   \resetteststrut    : instellen onzichtbare struts
%
%   \setfontparameters : instellen na fontset
%
% De hoogte van een regel (\lineheight) is gelijk aan de
% som van de hoogte (\ht) en diepte (\dp) van \strutbox.
%
%   \strut            : denkbeeldig blokje met hoogte en diepte
%
% Een \hbox kan als deze aan het begin van een regel staat
% een breedte \hsize krijgen. Dit is soms te voorkomen met het
% commando \leavevmode. Binnen een \vbox geeft dit echter
% niet altijd het gewenste resultaat, vandaar het commando
%
%   \leaveoutervmode

% Pas op: niet zomaar \topskip en \baselineskip aanpassen
% en zeker niet \widowpenalty. Dit kan ernstige gevolgen
% hebben voor kolommen.
%
% Enige glue kan op zich geen kwaad, echter als blanko=vast,
% dan moet ook de rek 0 zijn. Binnen kolommen is rek ook
% niet bepaald mooi. Een hele kleine waarde (0.025) voldoet,
% omdat een positieve glue eindeloos rekbaar is.

\newdimen\strutdimen
\newdimen\lineheight
\newdimen\openlineheight
\newdimen\openstrutheight
\newdimen\openstrutdepth
\def\strutheightfactor      {.72}
\def\strutdepthfactor       {.28}

\def\baselinefactor         {2.8}
\def\baselinegluefactor     {0}

\def\normallineheight       {\baselinefactor ex}
\def\minimallinedistance    {\lineskip} 

\def\strutheight            {0pt}
\def\strutdepth             {0pt}
\def\strutwidth             {0pt}

\def\spacingfactor          {1}

\def\topskipfactor          {1.0}
\def\maxdepthfactor         {0.5}

\def\systemtopskipfactor    {\topskipfactor}
\def\systemmaxdepthfactor   {\maxdepthfactor}

% De onderstaande definitie wordt in de font-module overruled

\ifx\globalbodyfontsize\undefined
  \newdimen\globalbodyfontsize
  \globalbodyfontsize=12pt
\fi
\ifx\normalizedbodyfontsize\undefined
  \def\normalizedbodyfontsize{12pt}
\fi

% door een \dimen. Dit is geen probleem omdat (1) de default
% korpsgrootte 12pt is en (2) de fonts nog niet geladen zijn
% en de instellingen bij het laden nogmaals plaatsvinden.

\def\topskipcorrection%
  {\ifdim\topskip>\openstrutheight
     \vskip\topskip
     \vskip-\openstrutheight
   \fi
   \vbox{\strut}
   \vskip-\openlineheight}

\def\settopskip% the extra test is needed for the lbr family
  {\topskip=\systemtopskipfactor\globalbodyfontsize
   \ifgridsnapping \else
     \ifr@ggedbottom\!!plus5\globalbodyfontsize\fi
   \fi
   \relax % the skip
   \ifdim\topskip<\strutheightfactor\openlineheight
     \topskip=\strutheightfactor\openlineheight\relax
   \fi}

\def\setmaxdepth%
  {\maxdepth=\systemmaxdepthfactor\globalbodyfontsize}

\def\normalbaselines%
  {\baselineskip\normalbaselineskip
   \lineskip\normallineskip
   \lineskiplimit\normallineskiplimit}

\def\setnormalbaselines%
  {\lineheight=\normallineheight
   \openlineheight=\spacingfactor\lineheight
\openstrutheight=\strutheightfactor\openlineheight
\openstrutdepth =\strutdepthfactor \openlineheight
   \normalbaselineskip=
     \openlineheight
     \!!plus\baselinegluefactor\openlineheight
     \!!minus\baselinegluefactor\openlineheight
   \normallineskip\minimallinedistance\relax % \!!onepoint\relax
   \normallineskiplimit\!!zeropoint\relax
   \normalbaselines}

\def\setspacingfactor#1\to#2\by#3\\%
  {\strutdimen=#2pt\relax
   \strutdimen=#3\strutdimen
   \edef#1{\withoutpt{\the\strutdimen}}}

\def\spacing#1%
  {\ifgridsnapping
     \doifnot{#1}{1}{\showmessage{\m!layouts}{11}{#1}}%
     \edef\spacingfactor{1}%
   \else
     \edef\spacingfactor{#1}%
   \fi
   \setspacingfactor\systemtopskipfactor\to\topskipfactor\by#1\\%
   \setspacingfactor\systemmaxdepthfactor\to\maxdepthfactor\by#1\\%
   \setnormalbaselines
   \setstrut}

\def\setstrutdimen#1#2#3%              % een strut is n.m maal ex
  {\strutdimen=\normallineheight       % wat niet per se \lineheight
   \strutdimen=#2\strutdimen           % is omdat een strut lokaal
   \strutdimen=#3\strutdimen           % kan afwijken van de globale
   \edef#1{\the\strutdimen}}           % strut

% plain definition:
%
% \def\strut{\relax\ifmmode\copy\strutbox\else\unhcopy\strutbox\fi}
%
% could be: 
%
% \def\strut{\relax\ifmmode\copy\else\unhcopy\fi\strutbox}

\let\normalstrut=\strut 

% The double \hbox construction enables us to \backtrack
% boxes.

% \def\setstrut%
%   {\setstrutdimen\strutheight\strutheightfactor\spacingfactor
%    \setstrutdimen\strutdepth \strutdepthfactor \spacingfactor
%    \let\strut=\normalstrut
%    \setbox\strutbox=\normalhbox
%      {\normalhbox
%         {\vrule
%            \!!width  \strutwidth
%            \!!height \strutheight
%            \!!depth  \strutdepth
%            \normalkern-\strutwidth}}}

\def\setstrut%
  {\setstrutdimen\strutheight\strutheightfactor\spacingfactor
   \setstrutdimen\strutdepth \strutdepthfactor \spacingfactor
   \dosetstrut}

\def\setcharstrut#1%
  {\setbox\strutbox=\hbox{#1}% 
   \edef\strutheight{\the\ht\strutbox}%
   \edef\strutdepth {\the\dp\strutbox}%
   \dosetstrut}

\def\setcapstrut% could be M, but Q has descender
  {\setcharstrut{Q}} 

%D Centered looks nicer: 

\def\dosetstrut%
  {\let\strut=\normalstrut
   \setbox\strutbox=\normalhbox
     {\normalhbox to \!!zeropoint
        {% \hss % new, will be option 
         \vrule
           \!!width \strutwidth
           \!!height\strutheight
           \!!depth \strutdepth
         \hss}}}

%D Sometimes a capstrut comes in handy
%D
%D \starttabulatie[|Tl|l|l|]
%D \NC yes          \NC normal strut               \NC {\toonstruts\setupstrut[ja]\strut}  \NC \NR 
%D \NC no           \NC no strut                   \NC {\toonstruts\setupstrut[nee]\strut}  \NC \NR 
%D \NC kap          \NC a capital strut (i.e. Q)   \NC {\toonstruts\setupstrut[kap]\strut} \NC \NR 
%D \NC A B \unknown \NC a character strut (e.g. A) \NC {\toonstruts\setupstrut[A]\strut}   \NC \NR 
%D \NC              \NC a normal strut             \NC {\toonstruts\setupstrut\strut}      \NC \NR 
%D \stoptabulatie

\def\setupstrut%
  {\dosingleempty\dosetupstrut}

\def\dosetupstrut[#1]% yet undocumented 
  {\processaction
     [#1]
     [     \v!ja=>\setstrut,
          \v!nee=>\setnostrut,
          \v!kap=>\setcapstrut,
      \s!default=>\setstrut,
      \s!unknown=>\setcharstrut{\commalistelement}]}

\def\setteststrut%
  {\def\strutwidth{.8pt}%
   \setstrut}

\def\begstrut%
  {\relax\ifdim\ht\strutbox=\!!zeropoint\else
     \strut
     \normalpenalty\!!tenthousand
     \normalhskip\!!zeropoint
     \ignorespaces
   \fi}

\def\endstrut%
  {\relax\ifhmode\ifdim\ht\strutbox=\!!zeropoint\else
     \unskip\unskip\unskip
     \normalpenalty\!!tenthousand
     \normalhskip\!!zeropoint
     \strut
   \fi\fi}

\def\setnostrut%
  {\setbox\strutbox=\normalhbox{\normalhbox{}}%
   \let\strut=\empty
   \let\endstrut=\empty
   \let\begstrut=\empty}

% unsave:
%
% \def\pseudostrut%
%   {\bgroup
%    \setnostrut
%    \normalstrut
%    \egroup}
%
% try:
%
% \startchemie
%   \chemie[ONE,Z0,SB15,MOV1,SB15,Z0][C,C]
% \stopchemie
%
% so:

\def\pseudostrut%
  {\noindent} % better: \dontleavehmode

\let\pseudobegstrut\pseudostrut

\def\pseudoendstrut% removes all kind of signals 
  {\ifhmode\unskip\unskip\unskip\unskip\fi}

\def\resetteststrut%
  {\let\strutwidth=\!!zeropoint
   \setstrut}

\ifx\setfontparameters\undefined
  \def\setfontparameters{\the\everybodyfont}
\fi

%D Handy: 

\def\baselinedistance{\the\lineheight}

%D We need \type{\normaloffinterlineskip} because the new
%D definition contains an assignment, and |<|don't ask me
%D why|>| this assignment gives troubles in for instance the
%D visual debugger.

\ifx\undefined\normaloffinterlineskip
  \let\normaloffinterlineskip=\offinterlineskip % knuth's original
\fi

\def\offinterlineskip%
  {\ifdim\baselineskip>\!!zeropoint
     \edef\oninterlineskip%
       {\baselineskip=\the\baselineskip
        \lineskip=\the\lineskip
        \lineskiplimit=\the\lineskiplimit
        \noexpand\let\noexpand\offinterlineskip=\noexpand\normaloffinterlineskip}%
   \else
     \let\oninterlineskip=\setnormalbaselines
   \fi
   \normaloffinterlineskip}

\let\oninterlineskip=\relax

\def\leaveoutervmode%
  {\ifvmode\ifinner\else
     \leavevmode
   \fi\fi}

% We stellen enkele penalties anders in dan Plain TEX:

\def\defaultwidowpenalty{2000} % was: 1000
\def\defaultclubpenalty {2000} % was:  800

\widowpenalty=\defaultwidowpenalty\relax
\clubpenalty =\defaultclubpenalty \relax

% Bovendien definieren we enkele extra \fill's:

\def\hfilll%
  {\hskip\!!zeropoint\!!plus1filll\relax}

\def\vfilll%
  {\vskip\!!zeropoint\!!plus1filll\relax}

% De onderstaande hulpmacro's moeten nog eens instelbaar worden
% gemaakt.

\def\tfskipsize{1em\relax}

\def\tfkernsize{1ex\relax}

\def\tfskip%
  {{\tf\hskip\tfskipsize}}

\def\tfkern%
  {{\tf\kern\tfkernsize}}

\newskip\linkssmaller
\newskip\rechtssmaller
\newskip\middensmaller

\def\dosinglesmaller#1%
  {\processaction
     [#1]
     [    \v!links=>\global\advance\linkssmaller  by \@@sllinks,
         \v!midden=>\global\advance\middensmaller by \@@slmidden,
         \v!rechts=>\global\advance\rechtssmaller by \@@slrechts,
        \s!unknown=>\global\advance\middensmaller by \commalistelement]}

\def\dosmaller[#1]%
  {\processaction
     [#1]
     [    \v!links=>\global\advance\linkssmaller  by \@@sllinks,
         \v!midden=>\global\advance\middensmaller by \@@slmidden,
         \v!rechts=>\global\advance\rechtssmaller by \@@slrechts,
        \s!unknown=>{\herhaalmetcommando[#1]\dosinglesmaller}]}

\def\complexstartsmaller[#1]%
  {\par
   \bgroup
   \global\linkssmaller=\!!zeropoint
   \global\rechtssmaller=\!!zeropoint
   \global\middensmaller=\!!zeropoint
   \processcommalistwithparameters[#1]\dosmaller
   \advance\leftskip  by \linkssmaller
   \advance\rightskip by \rechtssmaller
   \advance\leftskip  by \middensmaller
   \advance\rightskip by \middensmaller}

\def\simplestartsmaller%
  {\startsmaller[\v!midden]}

\definecomplexorsimple\startsmaller

\def\stopsmaller%
  {\par % else skips forgotten
   \egroup}

\def\stelsmallerin%
  {\dodoubleargument\getparameters[\??sl]}

\def\dodefinieerhbox[#1][#2]%
  {\setvalue{hbox#1}##1%
     {\hbox to #2{\begstrut##1\endstrut\hss}}}

\def\definieerhbox%
  {\dodoubleargument\dodefinieerhbox}

\def\lrcbox#1#2#%
  {\vbox#2\bgroup
   \let\\=\endgraf
   \forgetall#1\let\next=}

\def\lbox%
  {\lrcbox\raggedleft}

\def\rbox%
  {\lrcbox\raggedright}

\def\cbox%
  {\lrcbox\raggedcenter}

\def\dosetraggedvbox#1%
  {\processaction
     [#1]
     [  \v!links=>\def\raggedbox{\lbox},
       \v!rechts=>\def\raggedbox{\rbox},
       \v!midden=>\def\raggedbox{\cbox},
          \v!nee=>\def\raggedbox{\vbox\bgroup\raggedright\let\next=},
      \s!default=>\def\raggedbox{\vbox},
      \s!unknown=>\def\raggedbox{\vbox}]}

\def\dosetraggedhbox#1%
  {\processaction
     [#1]
     [  \v!links=>\let\raggedbox\regellinks,
       \v!rechts=>\let\raggedbox\regelrechts,
       \v!midden=>\let\raggedbox\regelmidden,
      \v!normaal=>\let\raggedbox\hbox,
      \s!default=>\let\raggedbox\hbox,
      \s!unknown=>\let\raggedbox\hbox]}

% \def\dosetraggedcommand#1% ook ruim,rechts en zo
%   {\processaction
%      [#1]
%      [  \v!links=>\def\raggedcommand{\raggedleft},
%        \v!rechts=>\def\raggedcommand{\raggedright},
%        \v!midden=>\def\raggedcommand{\raggedcenter},
%           \v!nee=>\def\raggedcommand{\raggedright},
%       \v!normaal=>\let\raggedcommand\relax,
%       \s!default=>\def\raggedcommand{\raggedcenter},
%       \s!unknown=>\let\raggedcommand\relax]}

\def\dosetraggedcommand#1% 
  {\expanded{\dodosetraggedcommand{#1}}}
 
\def\dodosetraggedcommand#1% 
  {\doifinsetelse{\v!ruim} {#1}{\!!doneatrue}{\!!doneafalse}%
   \doifinsetelse{\v!breed}{#1}{\!!donebtrue}{\!!donebfalse}%
   \let\raggedcommand\relax
   \let\raggedtopcommand\empty
   \let\raggedbottomcommand\empty
   \!!donectrue
   \ExpandFirstAfter\processallactionsinset
     [#1]
     [  \v!links=>\if!!donea      \def\raggedcommand{\veryraggedleft}%
                  \else           \def\raggedcommand{\raggedleft}%
                  \fi
                  \!!donecfalse,                    % {\v!links,\v!midden}
       \v!rechts=>\if!!donea      \def\raggedcommand{\veryraggedright}%
                  \else           \def\raggedcommand{\raggedright}%
                  \fi
                  \!!donecfalse,                    % {\v!rechts,\v!midden}
       \v!midden=>\if!!donec
                    \if!!doneb      \def\raggedcommand{\raggedwidecenter}%
                    \else\if!!donea \def\raggedcommand{\veryraggedcenter}%
                    \else           \def\raggedcommand{\raggedcenter}%
                    \fi\fi
                    \!!donecfalse                   % {\v!midden,\v!midden}
                  \else
                    \let\raggedbottomcommand\vfilll % bonus, pretty strong 
                    \let\raggedtopcommand   \vfilll % used with \framed for 
                  \fi,                              % instance in tables
         \v!hoog=>\let\raggedbottomcommand\vfilll,  % and since we lack a 
         \v!laag=>\let\raggedtopcommand   \vfilll,  % proper keyword, but
         \v!laho=>\let\raggedbottomcommand\vfilll   % we do support the 
                  \let\raggedtopcommand   \vfilll,  % ugly laho (lohi)
          \v!nee=>\def\raggedcommand{\raggedright},
           \v!ja=>\let\raggedcommand\notragged,  % was \relax
      \v!normaal=>\let\raggedcommand\notragged]} % was \relax

% Nodig i.v.m. inspringen eerste alineas

\def\explicithmode%
  {\unhbox\voidb@x}

% Nodig voor gebruikers

\def\geentest{\donottest}

% Nog doen:
%
%  \goodbreak -> \allowbreak en \dosomebreak{..} in koppen
%
% bij koppen zowieso: \blanko[reset]

% Nog in commando verwerken:
%
% \voorkeur … la \blanko
%
% Om ongewenste witruimte te voorkomen kan met \dosomebreak{\break}
% een \penalty v¢¢r witruimte worden geplaatst.

\def\removelastskip% a redefinition of plain 
  {\ifvmode\ifdim\lastskip=\z@\else\vskip-\lastskip\fi\fi}

\def\dosomebreak#1%
  {\skip0=\lastskip
   \removelastskip
   %\type{#1}%
   #1\relax
   \ifdim\skip0=\!!zeropoint
   \else
     \vskip\skip0
   \fi}

% beter, vooral in \vbox; nog in \pagina toepassen s!

\def\doifoutervmode#1%
  {\ifvmode\ifinner\else#1\fi\fi}

\def\dosomebreak#1%
  {\doifoutervmode
     {\skip0=\lastskip
      \removelastskip
      %\leavevmode\type{#1}%
      #1\relax
      \ifdim\skip0=\!!zeropoint % else interference with footnotes
      \else
        \vskip\skip0
      \fi}}

% Idem:
%
% \springin

%\def\noindentation% vervallen
%   {\EveryPar
%     {\ifdim\parindent=\!!zeropoint
%      \else
%        \bgroup
%        \setbox0=\lastbox
%        \egroup
%      \fi
%      \EveryPar{}}}

\newif\ifindentation \indentationtrue  % documenteren, naar buiten

\let\checkindentation=\relax

\def\donoindentation%
  {\ifdim\parindent=\!!zeropoint
   \else
     \bgroup
     \setbox0=\lastbox
     \egroup
   \fi}

\def\noindentation% made global
  {\ifinpagebody \else
     \global\indentationfalse
     \gdef\checkindentation%
       {\donoindentation
        \gdef\checkindentation{\global\indentationtrue}}%
   \fi}

\def\nonoindentation% bv bij floats
  {\ifinpagebody \else
     \global\indentationtrue
     \gdef\checkindentation{\global\indentationtrue}%
   \fi}

\def\indentation%
  {\ifvmode \ifdim\parindent=\!!zeropoint \else
     % was : \hskip\parindent 
     % can be: \indent  
     % but we test: 
     \noindent\hskip\parindent 
   \fi \fi}

% vergeten

%\def\forgeteverypar%
%  {\everypar\emptytoks}

\def\forgeteverypar%
  {\everypar{\the\neverypar}}

%\def\forgetparindent%
%  {\forgeteverypar
%   \indentfirstparagraphtrue % recently added
%   \stelinspringenin[\v!geen]}

%\def\forgetparskip%
%  {\stelwitruimtein[\v!geen]}

\def\forgetparindent
  {\forgeteverypar
   \indentfirstparagraphtrue % recently added
   \let\currentvoorwit\v!geen
   \voorwit\zeropoint
   \parindent\zeropoint\relax}

\def\forgetparskip%
  {\let\currentwitruimte\v!geen
   \tussenwit\zeropoint
   \parskip\zeropoint\relax}

\def\forgetbothskips%
  {\tolerance=1500
   \leftskip\!!zeropoint
   \rightskip\!!zeropoint\relax}

\def\forgetspacing%
  {\emergencystretch\!!zeropoint\relax}

\def\forgetall%
  {\the\everyforgetall}

\appendtoks \forgetragged       \to \everyforgetall 
\appendtoks \forgetparskip      \to \everyforgetall  
\appendtoks \forgetparindent    \to \everyforgetall 
\appendtoks \forgetbothskips    \to \everyforgetall 
\appendtoks \forgetspacing      \to \everyforgetall % i.v.m. funny spacing in pagebody
\appendtoks \everypar\emptytoks \to \everyforgetall % indeed!

\def\localvbox#1#%
  {\vbox#1\bgroup
     \forgetparskip
     \setlocalhsize
     \hsize=\localhsize
     \forgetparindent
     \forgetbothskips
     \forgeteverypar
     \let\next=}

% ach ja, hoort niet hier

% \unexpanded\def\dostartattributes#1#2#3%
%   {\begingroup  % geen \bgroup, anders in mathmode lege \hbox
%    \doifdefinedelse{#1#2}
%      {\def\fontattribute{\getvalue{#1#2}}}
%      {\let\fontattribute=\empty}%
%    \doifdefinedelse{#1#3}
%      {\def\colorattribute{\getvalue{#1#3}}}
%      {\let\colorattribute=\empty}%
%    \startcolor[\colorattribute]%
%    \@EA\doconvertfont\@EA{\fontattribute}}
% 
% \unexpanded\def\dostopattributes%
%   {\stopcolor
%    \endgroup}
% 
% \unexpanded\def\doattributes#1#2#3#4%
%   {\dostartattributes{#1}{#2}{#3}{#4}\dostopattributes}

%D A hardly faster implementation follows. We cannot use 
%D \type {csname} testing since the first argument can be 
%D anything, even a raw fontswitch. No a real improvement 
%D (some 5 seconds on 260 seconds for the maps bibliography).  
 
\def\@@dodoconvertfont#1{\csname\@letter@  #1\endcsname}
\def\@@donoconvertfont#1{\csname\@noletter@#1\endcsname}

\unexpanded\def\dodoconvertfont#1%#2%
  {\doifdefinedelse{\@letter@#1}
     {\doifelsenothing{#1}
        {\let\next\gobbleoneargument}
        {\let\next\@@dodoconvertfont}}
     {\doifdefinedelse{#1}
        {\let\next\getvalue}
        {\let\next\firstofoneargument}}%
   \next{#1}}%{#2}}

\let\doconvertfont=\dodoconvertfont

\def\noconvertfont#1%#2%
  {\doifdefinedelse{\@noletter@#1}
     {\doifelsenothing{#1}
        {\let\next\gobbleoneargument}
        {\let\next\@@donoconvertfont}}
     {\let\next\firstofoneargument}%
   \next{#1}}%{#2}}

\beginTEX 

\unexpanded\def\dostartattributes#1#2#3%
  {\begingroup  % geen \bgroup, anders in mathmode lege \hbox
   \@EA\ifx\csname#1#3\endcsname\relax
     \let\dostopattributes\endgroup
   \else
     \let\dostopattributes\@@dostopattributes
     \startcolor[\csname#1#3\endcsname]%
   \fi
   \@EA\ifx\csname#1#2\endcsname\relax
     \expandafter\gobbleoneargument
   \else
     \expandafter\doconvertfont
   \fi{\csname#1#2\endcsname}}

\endTEX

\beginETEX \ifcsname

\unexpanded\def\dostartattributes#1#2#3%
  {\begingroup  % geen \bgroup, anders in mathmode lege \hbox
   \ifcsname#1#3\endcsname
     \let\dostopattributes\@@dostopattributes
     \startcolor[\csname#1#3\endcsname]%
   \else                  
     \let\dostopattributes\endgroup
   \fi
   \ifcsname#1#2\endcsname
     \expandafter\doconvertfont
   \else
     \expandafter\gobbleoneargument
   \fi{\csname#1#2\endcsname}}

\endETEX

\unexpanded\def\@@dostopattributes%
  {\stopcolor
   \endgroup}

\unexpanded\def\doattributes#1#2#3#4%
  {\dostartattributes{#1}{#2}{#3}{#4}\dostopattributes}

% Kan vaker worden toegepast en moet bovendien sneller!

\newskip\leftskipadaption

\def\doadaptleftskip#1%
  {\dosetleftskipadaption{#1}%
   \advance\leftskip by \leftskipadaption}

\beginTEX

\def\dosetleftskipadaption#1%
  {\leftskipadaption\zeropoint
   \processaction[#1] % \ExpandFirstAfter
     [\v!standaard=>\leftskipadaption=
                    \ifdim\voorwit=\zeropoint\@@sllinks\else\voorwit\fi,
             \v!ja=>\leftskipadaption=
                    \ifdim\voorwit=\zeropoint\@@sllinks\else\voorwit\fi,
            \v!nee=>,
        \s!unknown=>\leftskipadaption=#1]}

\endTEX

\beginETEX

% installation 

\setvalue{@lsa@\v!standaard}%
  {\ifdim\voorwit=\zeropoint\@@sllinks\else\voorwit\fi}

\setvalue{@lsa@\v!ja}%
  {\ifdim\voorwit=\zeropoint\@@sllinks\else\voorwit\fi}

\setvalue{@lsa@\v!nee}%
  {\zeropoint}

\setvalue{@lsa@\empty}%
  {\zeropoint}

\def\dosetleftskipadaption#1%
  {\leftskipadaption
     \ifcsname @lsa@#1\endcsname
       \csname @lsa@#1\endcsname
     \else 
       #1%
     \fi
   \relax}

\endETEX

% Dit hoort eigenlijk thuis onder het kopje boodschappen cq,
% meldingen.

\let\mindermeldingen\dontcomplain

\definetwopasslist{\s!paragraph}

\newcounter\nofraggedparagraphs

\def\doparagraphreference% looks very much like domarginreference
  {\doglobal\increment\nofraggedparagraphs\relax
   \edef\writeparref%
     {\writeutilitycommand%
        {\twopassentry%
           {\s!paragraph}%
           {\nofraggedparagraphs}%
           {\noexpand\realfolio}}}%
   \writeparref}

\def\setraggedparagraphmode#1#2%
  {\ifinner
     \ifdubbelzijdig
       \gettwopassdata{\s!paragraph}%
       \iftwopassdatafound
         \ifodd\twopassdata#1\else#2\fi
       \else
         \ifodd\realfolio#1\else#2\fi
       \fi
       \doparagraphreference
     \else
       #2\relax
     \fi
   \else
     #2\relax
   \fi}

% \let\doifrightpageelse\setraggedparagraphmode

% De onderstaande macro's zijn opgenomen in Plain TeX.
%
% \def\raggedright%
%   {\rightskip\z@ plus2em \spaceskip.3333em \xspaceskip.5em\relax}
%
% \def\ttraggedright%
%   {\tttf\rightskip\z@ plus2em\relax}
%
% \newif\ifr@ggedbottom
%
% \def\raggedbottom%
%   {\topskip 10\p@ plus60\p@ \r@ggedbottomtrue}
%
% \def\normalbottom%
%   {\topskip 10\p@ \r@ggedbottomfalse}
%
% en worden hieronder wat aangepast.

% the three boolean will become obsolete some day in favour 
% of \bottomraggedness

\chardef\bottomraggedness=0 % 0=ragged 1=normal/align 2=baseline

\def\bottomalignlimit{3\lineheight}

\newif\ifn@rmalbottom
\newif\ifr@ggedbottom
\newif\ifb@selinebottom

\def\raggedbottom%
  {\chardef\bottomraggedness=0
   \n@rmalbottomfalse
   \r@ggedbottomtrue
   \b@selinebottomfalse
   \settopskip}

\def\alignbottom%
  {\chardef\bottomraggedness=1
   \n@rmalbottomtrue
   \r@ggedbottomfalse
   \b@selinebottomfalse
   \settopskip}

\def\baselinebottom%
  {\chardef\bottomraggedness=2
   \n@rmalbottomfalse
   \r@ggedbottomfalse
   \b@selinebottomtrue
   \settopskip}

\let\normalbottom=\alignbottom % downward compatible

% so, the new one will be
% 
% \chardef\bottomraggedness=0 % 0=ragged 1=normal/align 2=baseline
% 
% \def\bottomalignlimit{3\lineheight} % will be settable 
% 
% \def\raggedbottom  {\chardef\bottomraggedness=0 \settopskip}
% \def\alignbottom   {\chardef\bottomraggedness=1 \settopskip}
% \def\baselinebottom{\chardef\bottomraggedness=2 \settopskip}
%
% \let\normalbottom  =\alignbottom

% \hyphenpenalty  = ( 2.5 * \hsize ) / \raggedness
% \tolerance     >= 1500 % was 200
% \raggedness     = 2 .. 6\korpsgrootte

\chardef\raggedstatus=0 % normal left center right 

\def\leftraggedness   {2\bodyfontsize}
\def\rightraggedness  {2\bodyfontsize}
\def\middleraggedness {6\bodyfontsize}

%D More hyphenation control, will be combined with align 
%D setup. 

\def\nohyphens%
  {\ifx\dohyphens\relax
     \edef\dohyphens%
       {\hyphenpenalty\the\hyphenpenalty
        \exhyphenpenalty\the\exhyphenpenalty\relax}%
   \fi
   \hyphenpenalty\@M
   \exhyphenpenalty\@M}

\let\dohyphens\relax

%D To prevent unwanted side effects, we also have to check 
%D for hyphens here: 

\def\setraggedness#1%
  {\ifnum\tolerance<1500\relax       % small values have
     \tolerance=1500\relax           % unwanted side effects
   \fi                               
   \spaceskip=2.5\hsize              % we misuse these registers
   \xspaceskip=#1\relax              % for temporary storage;
   \divide\spaceskip by \xspaceskip  % they are changed anyway
   \ifx\dohyphens\relax               
     \hyphenpenalty=\spaceskip       % \else no hyphens is active 
   \fi}                              

\let\updateraggedskips\relax

\def\setraggedskips#1#2#3#4#5#6#7% never change this name
  {\def\updateraggedskips%
     {\dosetraggedskips{#1}{#2}{#3}{#4}{#5}{#6}{#7}}%
   \updateraggedskips}

\def\dosetraggedskips#1#2#3#4#5#6#7%
  {\chardef\raggedstatus=#1\relax 
   \leftskip=1\leftskip\!!plus#2\relax   % zie: Tex By Topic 8.1.3
   \rightskip=1\rightskip\!!plus#3\relax % zie: Tex By Topic 8.1.3
   \spaceskip#4\relax
   \xspaceskip#5\relax
   \parfillskip\!!zeropoint\!!plus#6\relax
   \parindent#7\relax}

% \def\notragged%
%   {\setraggedskips{0}{0em}{0em}{0em}{0em}{1fil}{\parindent}}

\def\notragged
  {\chardef\raggedstatus=0
   \leftskip1\leftskip
   \rightskip1\rightskip
   \spaceskip\!!zeropoint
   \xspaceskip\!!zeropoint
   \parfillskip\!!zeropoint\!!plus1fil\relax
   \let\updateraggedskips\relax} % new 

\let\forgetragged\notragged

\def\raggedleft%
  {\setraggedness\leftraggedness
   \setraggedskips{1}{\leftraggedness}{0em}{.3333em}{.5em}{0em}{0em}}

\def\raggedcenter%
  {\setraggedness\middleraggedness
   \setraggedskips{2}{\middleraggedness}{\middleraggedness}{.3333em}{.5em}{0em}{0em}}

%D We used to have:
%D
%D \starttypen
%D \def\raggedright%
%D   {\setraggedness\rightraggedness
%D    \setraggedskips{3}{0em}{\rightraggedness}{.3333em}{.5em}{0em}{\parindent}}
%D \stoptypen
%D
%D However, the next alternative, suggested by Taco, is better.

\def\raggedright%
  {\setraggedness\rightraggedness
   \setraggedskips{3}{0em}{\rightraggedness}{.3333em}{.5em}{1fil}{\parindent}}

\def\veryraggedleft%
  {\setraggedskips{1}{1fil}{0em}{.3333em}{.5em}{0em}{0em}}

%D When we want the last line to have a natural width:
%D
%D \starttypen
%D \def\veryraggedleft%
%D   {\setraggedskips{1}{1fil}{0em}{.3333em}{.5em}{0em}{-1fil}}
%D \stoptypen
%D
%D but this one is not accepted by the macros.

\def\veryraggedcenter%
  {\setraggedskips{2}{1fil}{1fil}{.3333em}{.5em}{0em}{0em}}

\def\veryraggedright%
  {\setraggedskips{3}{0em}{1fil}{.3333em}{.5em}{0em}{\parindent}}

\def\ttraggedright%
  {\tttf
   \setraggedskips{3}{0em}{\rightraggedness}{0em}{0em}{0em}{\parindent}} % {\voorwit}}

%D A bonus one:

\def\raggedwidecenter%
  {\setraggedness\middleraggedness
   \setraggedskips{2}{.5fil}{.5fil}{.3333em}{.5em}{0em}{0em}}

\newif\if@@asragged \@@asraggedtrue % old method 

\def\dodosteluitlijnenin[#1]%
  {\doifinsetelse{\v!ruim} {#1}{\!!doneatrue}{\!!doneafalse}%
   \doifinsetelse{\v!breed}{#1}{\!!donebtrue}{\!!donebfalse}%
   \ExpandFirstAfter\processallactionsinset
     [#1]
     [   \v!regel=>\baselinebottom,
         \v!onder=>\raggedbottom,
        \v!hoogte=>\normalbottom,
       \v!breedte=>\notragged,
       \v!normaal=>\notragged,
            \v!ja=>\notragged,
           \v!nee=>\raggedright,
\if@@asragged\v!binnen\else\v!buiten\fi
                 =>\setraggedparagraphmode\raggedleft\raggedright,
\if@@asragged\v!buiten\else\v!binnen\fi
                 =>\setraggedparagraphmode\raggedright\raggedleft,
\if@@asragged\v!links\else\v!rechts\fi
                 =>\if!!donea\veryraggedleft  \else\raggedleft  \fi,
\if@@asragged\v!rechts\else\v!links\fi
                 =>\if!!donea\veryraggedright \else\raggedright \fi,
        \v!midden=>\if!!doneb\raggedwidecenter\else
                   \if!!donea\veryraggedcenter\else\raggedcenter\fi\fi,
       \v!hangend=>\enableprotruding,
   \v!niethangend=>\disableprotruding,
    \v!afgebroken=>\dohyphens,
\v!nietafgebroken=>\nohyphens,
         \v!nieuw=>\@@asraggedfalse, % so new will give you consistency
         \v!reset=>\notragged\normalbottom]}

\def\dosteluitlijnenin[#1]%
  {\expanded{\dodosteluitlijnenin[#1]}}

\def\steluitlijnenin%
  {\dosingleargument\dosteluitlijnenin}

\def\startuitlijnen%
  {\bgroup
   \steluitlijnenin}

\def\stopuitlijnen
  {\par
   \egroup}

%\def\regellinks#1%
%  {\noindent\leftline{{\strut#1}}}
%
%\def\regelrechts#1%
%  {\noindent\rightline{{#1\strut}}}
%
%\def\regelmidden#1%
%  {\noindent\centerline{{\strut#1}}}

\def\doalignline#1#2%
  {\dowithnextbox
     {\noindent\hbox to \hsize
        {\strut#1\unhbox\nextbox#2}}
     \hbox}

% also supporting \\
%
% \def\doalignline#1#2%
%   {\dowithnextbox
%      {\noindent\hbox to \hsize
%         {\strut#1\unhbox\nextbox#2}}
%      \hbox\bgroup
%        \def\\{\egroup\par\doalignline#1#2\bgroup}\let\next=}

\def\doalignline#1#2%
  {\bgroup
   \def\\{\egroup\par\doalignline#1#2\bgroup}%
   \dowithnextbox
     {\noindent\hbox to \hsize
        {\strut#1\unhbox\nextbox#2}\egroup}
     \hbox}

% directe commando's

\def\regellinks {\doalignline \relax \hss  }
\def\regelrechts{\doalignline \hss   \relax}
\def\regelmidden{\doalignline \hss   \hss  }

\def\regelbegrensd#1{\limitatetext{#1}{\hsize}{\unknown}}

% indirecte commando's

\setvalue{regel\v!links }{\doalignline \relax \hss  }
\setvalue{regel\v!rechts}{\doalignline \hss   \relax}
\setvalue{regel\v!midden}{\doalignline \hss   \hss  }

\def\doregelplaats#1%
  {\getvalue{regel#1}}

\def\dosteltolerantiein[#1]%
  {\doifinsetelse{\v!vertikaal}{#1}%
     {\ExpandFirstAfter\processallactionsinset
        [#1]
        [\v!zeerstreng=>\def\bottomtolerance{},
             \v!streng=>\def\bottomtolerance{.050},
             \v!soepel=>\def\bottomtolerance{.075},
         \v!zeersoepel=>\def\bottomtolerance{.100}]}%
     {\ExpandFirstAfter\processallactionsinset
        [#1]
        [       \v!rek=>\emergencystretch=\bodyfontsize,
         \v!zeerstreng=>\tolerance=200,
             \v!streng=>\tolerance=1500,
             \v!soepel=>\tolerance=3000,
         \v!zeersoepel=>\tolerance=4500]}}

\def\steltolerantiein%
  {\dosingleargument\dosteltolerantiein}

\def\woordrechts%
  {\groupedcommand{\hfill\hbox}{\parfillskip\!!zeropoint}}

%D \macros
%D   {pushindentation,popindentation}
%D
%D The pushing and popping is done by:

\newbox\indentationboxA
\newbox\indentationboxB

\def\pushindentation%
  {\bgroup
   \ifhmode
     \unskip
     \setbox\indentationboxA=\lastbox       % get \strut if present
     \unskip
     \setbox\indentationboxB=\lastbox       % get \indent generated box
     \unskip
   \else
     \hskip\!!zeropoint                     % switch to horizontal mode
     \unskip
     \setbox\indentationboxA=\lastbox       % get \indent generated box
     \setbox\indentationboxB=\box\voidb@x
   \fi}

\def\popindentation%
  {\box\indentationboxB\box\indentationboxA % put back the boxes
   \egroup}

%D The only complication lays in \type{\strut}. In \PLAIN\
%D \TEX\ a \type{\strut} is defined as:
%D
%D \starttypen
%D \def\strut%
%D   {\relax\ifmmode\copy\strutbox\else\unhcopy\strutbox\fi}
%D \stoptypen
%D
%D But what is a \type{\strut}? Normally it's a rule of width
%D zero, but when made visual, it's a rule and a negative skip.
%D The mechanism for putting things in the margins described
%D here cannot handle this situation very well. One
%D characteristic of \type{\strut} is that the \type{\unhcopy}
%D results in entering horizontal mode, which in return leads
%D to some indentation.
%D
%D To serve our purpose a bit better, the macro \type{\strut}
%D can be redefined as:
%D
%D \starttypen
%D \def\strut%
%D   {\relax\ifmmode\else\hskip0pt\fi\copy\strutbox}
%D \stoptypen
%D
%D Or more compatible:
%D
%D \starttypen
%D \def\strut%
%D   {\relax\ifmmode
%D      \copy\strutbox
%D    \else
%D      \bgroup\setbox\strutbox=\normalhbox{\box\strutbox}\unhcopy\strutbox\egroup
%D    \fi}
%D \stoptypen
%D
%D In \CONTEXT\ however we save some processing time by putting
%D an extra \type{\hbox} around the \type{\strutbox}.

\stelwitruimtein
  [\v!geen]

\inspringen
  [\v!nooit]

\stelinspringenin
  [\v!geen]

\stelblankoin
  [\v!standaard,
   \v!groot]

\definieerblanko[\v!default] [\currentblanko]
\definieerblanko[\v!voor]    [\v!default]
\definieerblanko[\v!tussen]  [\v!default]
\definieerblanko[\v!na]      [\v!voor]

% doen?

\def\@@blankovoor  {\blanko[\v!voor]}   %
\def\@@blankotussen{\blanko[\v!tussen]} %  scheelt 5 tokens == >20 bytes
\def\@@blankona    {\blanko[\v!na]}     %

\stelinterliniein
  [\c!hoogte=.72,
   \c!diepte=.28,
   \c!boven=1.0,
   \c!onder=0.4,
   \c!afstand=1pt,
   \c!regel=2.8ex]

\stelsmallerin
  [\c!links=1.5em,
   \c!rechts=1.5em,
   \c!midden=1.5em]

\steltolerantiein
  [\v!horizontaal,\v!zeerstreng]

\steltolerantiein
  [\v!vertikaal,\v!streng]

\steluitlijnenin
  [\v!onder,
   \v!breedte]

\stelspatieringin
  [\v!opelkaar]

\protect \endinput 
