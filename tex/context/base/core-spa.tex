%D \module
%D   [       file=core-spa,
%D        version=1997.03.31,
%D          title=\CONTEXT\ Core Macros,
%D       subtitle=Spacing,
%D         author=Hans Hagen,
%D           date=\currentdate,
%D      copyright={PRAGMA / Hans Hagen \& Ton Otten}]
%C
%C This module is part of the \CONTEXT\ macro||package and is
%C therefore copyrighted by \PRAGMA. See mreadme.pdf for
%C details.

\writestatus{loading}{Context Spacing Macros}

\unprotect 

\newevery \everybodyfont   \Everybodyfont   % just to be sure
\newevery \everyfontswitch \EveryFontSwitch % just to be sure

\appendtoks \presetnormallineheight \to \everybodyfont
\appendtoks \setnormalbaselines     \to \everybodyfont
\appendtoks \setstrut               \to \everybodyfont
\appendtoks \settopskip             \to \everybodyfont
\appendtoks \setmaxdepth            \to \everybodyfont
\appendtoks \spacing               1\to \everybodyfont
\appendtoks \simplestelinspringenin \to \everybodyfont
\appendtoks \simplestelblankoin     \to \everybodyfont
\appendtoks \simplestelwitruimtein  \to \everybodyfont
%appendtoks \setupfootnotes         \to \everybodyfont % not
\appendtoks \simplestelspatieringin \to \everybodyfont % nieuw
\appendtoks \setdisplayskips        \to \everybodyfont % nieuw

\appendtoks \updateraggedskips \to \everyfontswitch  % under test 

\prependtoks \let\par\endgraf \to \everypagebody % see \fillinline

\def\stelfactorenin%
  {\simplestelwitruimtein
   \simplestelblankoin
   \settopskip
   \setmaxdepth}

%D The dreadful sequence \type {\bgroup} \unknown\
%D \type {\carryoverpar} \unknown\ \type {\egroup} is needed
%D when for instance sidefloats are used in combination with
%D something that starts with a group. This is because
%D otherwise the indentation as set (by the output routine)
%D inside the group are forgotten afterwards. (I must 
%D not forget its existence).

\global\let\carriedoverpar\relax 

\def\carryoverpar#1%
  {\expanded
     {\noexpand#1%
      \hangindent\the\hangindent
      \hangafter \the\hangafter
      \parskip   \the\parskip
      \leftskip  \the\leftskip
      \rightskip \the\rightskip}}

%D A quick way to determine left|/|middle|/|right states 
%D (experimental).

\setvalue{\??as\v!links }{0}
\setvalue{\??as\v!midden}{1}
\setvalue{\??as\v!rechts}{2}

\def\setalignmentswitch#1%
  {\chardef\alignmentswitch=0\csname\??as#1\endcsname\relax}

%D There are two ways to influence the interline spacing. The
%D most general and often most consistent way is using
%D
%D \showsetup{\y!stelinterliniein}
%D
%D For instance
%D
%D \starttypen
%D \setupinterlinespace[line=2.8ex]
%D \stoptypen
%D
%D This setting adapts itself to the bodyfontsize, while for
%D instance saying
%D
%D \starttypen
%D \setupinterlinespace[line=12pt]
%D \stoptypen
%D
%D sets things fixed for all sizes, which is definitely not
%D what we want. Therefore one can also say:
%D
%D \starttypen
%D \definebodyfontenvironment[9pt][interlinespace=11pt]
%D \stoptypen
%D
%D One can still use \type{\setupinterlinespace} (without
%D arguments) to set the interline space according to the
%D current font, e.g. a \type{\bfa}.

\newif\iflocalinterlinespace

% font-ini

\ifx\bodyfontinterlinespecs\undefined

  \let\bodyfontinterlinespecs\empty
  \let\bodyfontinterlinespace\empty

\fi

\def\presetnormallineheight%
  {\edef\normallineheight{\@@itregel}%
   \iflocalinterlinespace \else
     \doifdefined{\bodyfontinterlinespecs}
       {\doifsomething{\bodyfontinterlinespace}
          {\edef\normallineheight{\bodyfontinterlinespace}}}%
   \fi}

\def\complexstelinterliniein[#1]% \commalistelement ipv #1
  {\doifassignmentelse{#1}
     {\getparameters[\??it][#1]%
      \scratchdimen=0\@@ithoogte pt
      \advance\scratchdimen by 0\@@itdiepte pt
      \ifdim\scratchdimen>1pt
        \showmessage{\m!layouts}{10}{\@@ithoogte,\@@itdiepte}%
        \let\@@ithoogte\strutheightfactor
        \let\@@itdiepte\strutdepthfactor
      \else
        \let\strutheightfactor\@@ithoogte
        \let\strutdepthfactor \@@itdiepte
      \fi
      \let\minimallinedistance\@@itafstand
      \let\normallineheight\@@itregel % let ! ! ! ! ! ivm ex 
      \let\topskipfactor\@@itboven
      \let\maxdepthfactor\@@itonder
      \let\baselinegluefactor\@@itrek
      \setfontparameters % redundant, can be \setstrut, test first 
      \updateraggedskips} % yes indeed
     {\processallactionsinset % \regelwit = dummy !
        [#1]
        [     \v!aan=>\oninterlineskip,
              \v!uit=>\offinterlineskip,
            \v!reset=>\setfontparameters,% just \setstrut, test first 
          \s!unknown=>\assignvalue{#1}{\regelwit}{1.00}{1.25}{1.50}%
                      \spacing{\regelwit}]}}

\def\simplestelinterliniein%
  {\localinterlinespacetrue
   \setfontparameters
   \updateraggedskips % funny one here
   \localinterlinespacefalse}

\definecomplexorsimple\stelinterliniein

% In earlier versions \type{\bigskipamount} was
% \type{\ht\strutbox} and the stretch was plus or minus
% \type{.4\dp\strutbox}. Don't ask me why. The most recent
% implementation is based on a user supplied distance, which
% is by default \type{.75\normalskipamount} where
% \type{\normalskipamount} equals the current baseline
% distance.

\newif\ifblankoreset        \blankoresetfalse
\newif\ifblankoblokkeer     \blankoblokkeerfalse
\newif\ifblankogeenwit      \blankogeenwitfalse
\newif\ifdoeblanko          \doeblankofalse
\newif\ifblankoflexibel     \blankoflexibeltrue
\newif\ifblankobuiten
\newif\ifblankoforceer

\newskip\blankoskip         \blankoskip=\bigskipamount
\newskip\blankoskipamount

\def\skipfactor    {.75}
\def\skipgluefactor{.25}

\def\normalskipamount%
  {\openlineheight
     \ifgridsnapping \else \ifblankoflexibel
       \!!plus\skipgluefactor\openlineheight
       \!!minus\skipgluefactor\openlineheight
     \fi \fi
   \relax}

\def\regelafstand{\normalskipamount}

\def\deblankoskip{\skipfactor\regelafstand}

\def\laatsteblankoskip%
  {\blankoskip}

\def\geenblanko%
  {\removelastskip}

\def\currentblanko%
  {\v!groot}
 
\def\oldprevdepth {\prevdepth}%
\def\newprevdepth {-1001pt}
\def\mindimen     {1sp} % was: 0.00002pt
 
\newif\iflokaalblankovast
\newif\iflokaalblankoflexibel
\newif\iffuzzyvskip

%%%% pas op, wordt ook in core-pos gebruikt 

\def\doassignsomeskip#1\to#2% ook nog \v!halveregel+fuzzysnap
  {\doifelse{#1}{\v!regel}
     {#2\openlineheight}
     {\ifgridsnapping
        \assigndimension{#1}{#2}%
          {.25\openlineheight}{.5\openlineheight}{\openlineheight}%
      \else
        \assigndimension{#1}{#2}%
          {\smallskipamount}{\medskipamount}{\bigskipamount}%
      \fi}}

%%%% dus niet weg 

% replaced
%
% \def\dosingleblanko#1% 
%   {\doassignsomeskip#1\to\blankoskipamount 
%    \global\advance\blankoskip \blankoskipamount}
% 
% \def\doblanko#1%
%   {\processallactionsinset % is maar een actie
%      [#1]
%      [    \v!groot=>\dosingleblanko\v!groot, % happens often
%          \v!buiten=>\ifvmode\ifinner\blankobuitentrue\fi\fi,
%           \v!reset=>\global\blankoresettrue,
%        \v!flexibel=>\global\lokaalblankoflexibeltrue,
%            \v!vast=>\global\lokaalblankovasttrue,
%            \v!back=>\geenblanko,
%             \v!wit=>\global\advance\blankoskip by \parskip,
%         \v!formule=>\global\advance\blankoskip by \medskipamount,
%         \v!geenwit=>\global\blankogeenwittrue,
%            -\v!wit=>\global\advance\blankoskip by -\parskip,
%        \v!blokkeer=>\global\blankoblokkeertrue,
%         \v!forceer=>\global\blankoforceertrue,
%           \v!regel=>\global\advance\blankoskip by \lineheight,
%      \v!halveregel=>\ifgridsnapping\global\fuzzyvskiptrue\fi
%                     \global\advance\blankoskip by .5\lineheight,
%         \s!unknown=>\doindirectblanko{#1}]}
% 
% \def\docomplexdoblanko[#1]% pas op \relax's zijn nodig ivm volgende \if
%   {\global\blankoresetfalse
%    \global\blankoblokkeerfalse
%    \global\blankogeenwitfalse
%    \global\lokaalblankoflexibelfalse
%    \global\lokaalblankovastfalse
%    \global\blankoskip\zeropoint
%    \global\blankoforceerfalse
%    \blankobuitenfalse
%    \processcommalist[#1]\doblanko
%    \ifdim\blankoskip=\zeropoint\relax
%      \iflokaalblankoflexibel \dosingleblanko\currentblanko \fi
%      \iflokaalblankovast     \dosingleblanko\currentblanko \fi
%    \fi
%    \ifblankobuiten
%    \else
%      \par
%      \ifvmode          %in pos fonts gaat dit mis 
%        \ifblankoforceer%\ifdim\prevdepth>\zeropoint\else
%          % -1000pt signals top of page or column (\ejectcolumn)
%          \vbox{\strut}\kern-\lineheight
%        \fi
%        \ifblankoblokkeer
%          \global\doeblankofalse
%          \edef\oldprevdepth{\the\prevdepth}%
%          \prevdepth=\newprevdepth
%        \else
%          \global\doeblankotrue
%        \fi
%        \ifblankoreset
%          \global\doeblankotrue
%          \ifdim\prevdepth=\newprevdepth
%            \prevdepth=\oldprevdepth
%          \fi
%        \fi
%        \ifdoeblanko
%          \ifdim\lastskip<\blankoskip\relax
%            % else when \blanko[2*groot] + \blanko[3*groot] with parskip
%            % equaling 1*groot, gives a groot=\parskip so adding a small
%            % value makes it distinguishable; can also be done at parskip
%            % setting time (better)
%            \global\advance\blankoskip by \mindimen\relax % = skip
%            % test this on 2* + 3* and parskip groot
%            \ifblankogeenwit
%              \global\advance\blankoskip by -\parskip
%            \else
%              \ifdim\lastskip=\parskip
%              \else  % force this due to previous comment
%                \ifdim\parskip>\zeropoint\relax
%                  \ifdim\blankoskip<\parskip\relax
%                    \global\blankoskip\zeropoint
%                  \else
%                    \global\advance\blankoskip by -\parskip
%                  \fi
%                \fi
%              \fi
%            \fi
%            \ifblankoflexibel \else
%              \blankoskip=1\blankoskip 
%            \fi
%            \iflokaalblankovast 
%              \blankoskip=1\blankoskip 
%            \fi
%            \iflokaalblankoflexibel       
%              \blankoskip=1\blankoskip 
%                \!!plus\skipgluefactor\blankoskip
%                \!!minus\skipgluefactor\blankoskip
%            \fi
%            \ifdim\prevdepth=\newprevdepth
%            \else
%              \iffuzzyvskip
%                \removelastfuzzyvskip
%                \fuzzyvskip\blankoskip\relax
%              \else
%                \removelastskip
%                \vskip\blankoskip\relax
%              \fi
%            \fi
%          \else
%            \iffuzzyvskip
%              \removelastfuzzyvskip
%              \fuzzyvskip\blankoskip\relax
%            \fi
%          \fi
%        \fi
%      \fi
%    \fi
%    \global\fuzzyvskipfalse
%    \presetindentation}
% 
% \def\complexdodoblanko[#1]%
%   {\flushfootnotes
%    \ifopelkaar
%      \ifinpagebody
%        \expanded{\docomplexdoblanko[#1]}% \expanded=nieuw
%      \else
%        \par
%      \fi
%    \else
%      \expanded{\docomplexdoblanko[#1]}% \expanded = nieuw
%    \fi}
% 
% % old
% %
% % \def\doindirectblanko#1%
% %   {\ifundefined{\??bo#1}% <-etex \expandafter\ifx\csname\??bo#1\endcsname\relax
% %      \expanded{\complexdodoblanko[#1]}%
% %    \else
% %      \expandafter\complexdoblanko\expandafter[\csname\??bo#1\endcsname]%
% %    \fi}
% %
% % \def\complexdoblanko[#1]% enables [force,8\bodyfontsize]
% %   {\doifinstringelse{,}{#1}
% %      {\expanded{\complexdodoblanko[#1]}}
% %      {\doifnumberelse{#1}
% %         {\expanded{\complexdodoblanko[#1]}}
% %         {\doindirectblanko{#1}}}}
% %
% % new, more robust 
% %
% % \def\doindirectblanko#1%
% %   {\edef\ascii{#1}\convertcommand\ascii\to\ascii
% %    \ifundefined{\??bo\ascii}% <-etex \expandafter\ifx\csname\??bo#1\endcsname\rel
% %      \herhaalmetcommando[#1]\dosingleblanko
% %    \else
% %      \expandafter\complexdoblanko\expandafter[\csname\??bo\ascii\endcsname]%
% %    \fi}
% % 
% % even more robust
% 
% \def\doindirectblanko#1%
%   {\edef\ascii{#1}\convertcommand\ascii\to\ascii
%    \ifundefined{\??bo\ascii}% <-etex \expandafter\ifx\csname\??bo#1\endcsname
%      \expanded{\herhaalmetcommando[#1]\noexpand\dosingleblanko}%
%    \else
%      \expandafter\complexdoblanko\expandafter[\csname\??bo\ascii\endcsname]%
%    \fi}

% \def\TestBlank[#1]%
%   {blank : {\convertargument#1\to\ascii\tttf\ascii}\blanko[#1]}
% 
% \defineblank[whatever][2*big,2*big]
% \TestBlank[]
% \TestBlank[big]
% \TestBlank[2*big]
% \TestBlank[big,big,2*big]
% \TestBlank[big]
% \TestBlank[whatever] 
% \TestBlank[2*big,whatever] 
% \TestBlank[3\lineheight]

\def\addblankskip#1#2#3%
  {\global\advance\blankoskip#1\ifgridsnapping#3\else#2\fi}

\def\defineblankmethod[#1]#2{\setvalue{\??bo\??bo#1}{#2}}

\defineblankmethod   [\v!groot]{\addblankskip+\bigskipamount      \openlineheight}
\defineblankmethod  [-\v!groot]{\addblankskip-\bigskipamount      \openlineheight}
\defineblankmethod  [\v!middel]{\addblankskip+\medskipamount   {.5\openlineheight}}
\defineblankmethod [-\v!middel]{\addblankskip-\medskipamount   {.5\openlineheight}}
\defineblankmethod   [\v!klein]{\addblankskip+\smallskipamount{.25\openlineheight}}
\defineblankmethod  [-\v!klein]{\addblankskip-\smallskipamount{.25\openlineheight}}
\defineblankmethod     [\v!wit]{\addblankskip+\parskip\openlineheight}
\defineblankmethod    [-\v!wit]{\addblankskip-\parskip\openlineheight}
\defineblankmethod   [\v!regel]{\addblankskip+\openlineheight\openlineheight}
\defineblankmethod  [-\v!regel]{\addblankskip-\openlineheight\openlineheight}

\defineblankmethod [\v!formule   ]{\global\advance\blankoskip\medskipamount}
\defineblankmethod [\v!geenwit   ]{\global\blankogeenwittrue}
\defineblankmethod [\v!blokkeer  ]{\global\blankoblokkeertrue}
\defineblankmethod [\v!forceer   ]{\global\blankoforceertrue}
\defineblankmethod [\v!buiten    ]{\ifvmode\ifinner\blankobuitentrue\fi\fi}
\defineblankmethod [\v!reset     ]{\global\blankoresettrue}
\defineblankmethod [\v!flexibel  ]{\global\lokaalblankoflexibeltrue}
\defineblankmethod [\v!vast      ]{\global\lokaalblankovasttrue}
\defineblankmethod [\v!back      ]{\geenblanko}
\defineblankmethod [\v!halveregel]{\ifgridsnapping\global\fuzzyvskiptrue\fi
                                   \global\advance\blankoskip .5\lineheight}
% happens often 

\defineblankmethod [2*\v!groot]{\addblankskip+{2\bigskipamount}{2\openlineheight}}

% ETEX ! ! !

\def\doblanko#1%
  {\edef\ascii{#1}\convertcommand\ascii\to\ascii
   \ifx\ascii\empty\else
     \ifcsname\??bo\??bo\ascii\endcsname % internal def 
       \csname\??bo\??bo\ascii\endcsname 
     \else\ifcsname\??bo\ascii\endcsname % user def / slow 
       \@EA\rawprocesscommalist\@EA[\csname\??bo\ascii\endcsname]\doblanko\relax
     \else
       \dorepeatwithcommand[#1]\redoblanko
     \fi\fi
   \fi}

\def\redoblanko#1%
  {\edef\ascii{#1}\convertcommand\ascii\to\ascii
   \ifx\ascii\empty\else
     \ifcsname\??bo\??bo\ascii\endcsname % internal def 
       \csname\??bo\??bo\ascii\endcsname 
     \else\ifcsname\??bo\ascii\endcsname % user def / slow 
       \@EA\rawprocesscommalist\@EA[\csname\??bo\ascii\endcsname]\doblanko\relax
     \else
       \global\advance\blankoskip#1\relax
     \fi\fi
   \fi}

\unexpanded\def\blanko % the \relax is definitely needed due to the many \if's
  {\relax\complexorsimple\doblanko}

\def\complexdoblanko
  {\flushfootnotes
   \ifopelkaar
     \ifinpagebody
       \@EAEAEA\docomplexdoblanko
     \else
       \@EAEAEA\nocomplexdoblanko
     \fi
   \else
     \@EA\docomplexdoblanko
   \fi}

\def\nocomplexdoblanko[#1]% 
  {\par}

\def\docomplexdoblanko[#1]% pas op \relax's zijn nodig ivm volgende \if
  {\global\blankoresetfalse
   \global\blankoblokkeerfalse
   \global\blankogeenwitfalse
   \global\lokaalblankoflexibelfalse
   \global\lokaalblankovastfalse
   \global\blankoskip\zeropoint
   \global\blankoforceerfalse
   \blankobuitenfalse
   \expanded{\rawprocesscommalist[#1]}\doblanko
   \ifdim\blankoskip=\zeropoint\relax
     \iflokaalblankoflexibel 
       \doglobal\advance\blankoskip \currentblanko 
     \else\iflokaalblankovast     
       \doglobal\advance\blankoskip \currentblanko 
     \fi\fi
   \fi
   \ifblankobuiten
   \else
     \par
     \ifvmode          %in pos fonts gaat dit mis 
       \ifblankoforceer%\ifdim\prevdepth>\zeropoint\else
         % -1000pt signals top of page or column (\ejectcolumn)
         \vbox{\strut}\kern-\lineheight
       \fi
       \ifblankoblokkeer
         \global\doeblankofalse
         \edef\oldprevdepth{\the\prevdepth}%
         \prevdepth\newprevdepth
       \else
         \global\doeblankotrue
       \fi
       \ifblankoreset
         \global\doeblankotrue
         \ifdim\prevdepth=\newprevdepth
           \prevdepth\oldprevdepth
         \fi
       \fi
       \ifdoeblanko
         \ifdim\lastskip<\blankoskip\relax
           % else when \blanko[2*groot] + \blanko[3*groot] with parskip
           % equaling 1*groot, gives a groot=\parskip so adding a small
           % value makes it distinguishable; can also be done at parskip
           % setting time (better)
           \global\advance\blankoskip \mindimen\relax % = skip
           % test this on 2* + 3* and parskip groot
           \ifblankogeenwit
             \global\advance\blankoskip -\parskip
           \else
             \ifdim\lastskip=\parskip
             \else  % force this due to previous comment
               \ifdim\parskip>\zeropoint\relax
                 \ifdim\blankoskip<\parskip\relax
                   \global\blankoskip\zeropoint
                 \else
                   \global\advance\blankoskip -\parskip
                 \fi
               \fi
             \fi
           \fi
           \ifblankoflexibel \else
             \blankoskip1\blankoskip 
           \fi
           \iflokaalblankovast 
             \blankoskip1\blankoskip 
           \fi
           \iflokaalblankoflexibel       
             \blankoskip1\blankoskip 
               \!!plus\skipgluefactor\blankoskip
               \!!minus\skipgluefactor\blankoskip
           \fi
           \ifdim\prevdepth=\newprevdepth
           \else
             \iffuzzyvskip
               \removelastfuzzyvskip
               \fuzzyvskip\blankoskip\relax
             \else
               \removelastskip
               \vskip\blankoskip\relax
             \fi
           \fi
         \else
           \iffuzzyvskip
             \removelastfuzzyvskip
             \fuzzyvskip\blankoskip\relax
           \fi
         \fi
       \fi
     \fi
   \fi
   \global\fuzzyvskipfalse
   \presetindentation}

%D For a long time we had: 
%D
%D \starttypen 
%D \def\simpledoblanko%
%D   {\doifelse{\currentwitruimte}{\v!geen}
%D      {\blanko[\currentblanko]}
%D      {\blanko[\currentwitruimte]}}
%D \stoptypen
%D
%D But Berend de Boer wanted more control, so now we have:  

\def\simpledoblanko % ... 
  {\doifelse\currentwitruimte\v!geen
     {\blanko[\currentblanko]}
     {\blanko[\s!default]}}

%D Another useful definition would be:
%D
%D \starttypen 
%D \definieerblanko
%D   [\s!default]
%D   [\v!groot]
%D \stoptypen

\def\dostelblankoin#1% amount are an plain inheritance
  {\bigskipamount=#1\relax
   \ifblankoflexibel \else 
     \bigskipamount=1\bigskipamount 
   \fi
   \medskipamount  \bigskipamount \divide\medskipamount   2
   \smallskipamount\bigskipamount \divide\smallskipamount 4 }%

\def\complexstelblankoin[#1]% more \let's 
  {\ifgridsnapping
     \blankoflexibelfalse
   \else
     \ExpandFirstAfter\processallactionsinset
       [#1]
       [ \v!flexibel=>\blankoflexibeltrue,
             \v!vast=>\blankoflexibelfalse]%
   \fi
   \ExpandFirstAfter\processallactionsinset
     [#1]
     [ \v!flexibel=>\dostelblankoin\deblankoskip,
           \v!vast=>\dostelblankoin\deblankoskip,
          \v!regel=>\edef\deblankoskip{\regelafstand}%
                    \dostelblankoin\deblankoskip
                    \let\deblanko\v!groot,
     \v!halveregel=>\scratchskip.5\regelafstand
                    \edef\deblankoskip{\the\scratchskip}%
                    \dostelblankoin\deblankoskip
                    \let\deblanko\v!middel,
          \v!groot=>\ifgridsnapping
                      \edef\deblankoskip{\regelafstand}%
                      \dostelblankoin\deblankoskip
                    \fi
                    \def\currentblanko{\v!groot}%
                    \let\deblanko\v!groot,
         \v!middel=>\def\currentblanko{\v!middel}%
                    \let\deblanko\v!middel,
          \v!klein=>\def\currentblanko{\v!klein}%
                    \let\deblanko\v!klein,
        \v!normaal=>\dostelblankoin\deblankoskip
                    \let\deblanko\v!groot,
      \v!standaard=>\edef\deblankoskip{\skipfactor\regelafstand}%
                    \dostelblankoin\deblankoskip
                    \let\deblanko\v!groot,
        \s!default=>\dostelblankoin\deblankoskip
                    \let\deblanko\v!groot,
        \s!unknown=>\let\deblankoskip\commalistelement
                    \dostelblankoin\deblankoskip
                    \let\deblanko\v!groot]%
   \simplestelwitruimtein}

% \definecomplexorsimpleempty\stelblankoin
%
% speed gain: 60 sec -> 30 sec

\definecomplexorsimple\stelblankoin

\def\simplestelblankoin% == snelle \stelblankoin[\s!default]
  {\ifgridsnapping
     \blankoflexibelfalse
   \fi
   \dostelblankoin{\deblankoskip}%
   \let\deblanko\v!groot
   \simplestelwitruimtein}

\def\restorestandardblank% \v!standaard
  {\edef\deblankoskip{\skipfactor\regelafstand}%
   \dostelblankoin\deblankoskip
   \let\deblanko\v!groot}

\def\dodefinieerblanko[#1][#2]%
  {\def\docommando##1{\setvalue{\??bo##1}{#2}}%
   \processcommalist[#1]\docommando}

\def\definieerblanko%
  {\dodoubleargument\dodefinieerblanko}

\def\savecurrentblanko%
  {\edef\restorecurrentblanko%
     {\bigskipamount=\the\bigskipamount
      \medskipamount=\the\medskipamount
      \smallskipamount=\the\smallskipamount
      \noexpand\def\noexpand\currentblanko{\currentblanko}%
      \ifblankoflexibel
        \noexpand\blankoflexibeltrue
      \else
        \noexpand\blankoflexibelfalse
      \fi}}

\def\inhibitblank% the fast, local way
  {\endgraf\ifvmode\prevdepth\newprevdepth\fi}

%D Now. 

\definieerblanko [\s!default] [\v!wit]
\definieerblanko [\v!hoogte]  [\strutheight]
\definieerblanko [\v!diepte]  [\strutdepth]

\let\currentvoorwit=\empty

\newdimen\voorwit

\newif\ifindentfirstparagraph % \indentfirstparagraphtrue

\def\presetindentation%
  {\doifoutervmode
     {\ifindentfirstparagraph\else\noindentation\fi}}

\definecomplexorsimple\stelinspringenin

\def\complexstelinspringenin[#1]%
  {\processallactionsinset
     [#1]
     [   \v!eerste=>\indentfirstparagraphtrue,
       \v!volgende=>\indentfirstparagraphfalse,
        \s!default=>\simplestelinspringenin,
        \s!unknown=>\edef\currentvoorwit{\commalistelement}%
                    \simplestelinspringenin]}

\def\simplestelinspringenin
  {\assigndimension{\currentvoorwit}{\voorwit}{1em}{1.5em}{2em}%
   \parindent=\voorwit\relax}

\def\doinspringen[#1]% too many relaxes
  {\processallactionsinset
     [#1]
     [    \v!nee=>\parindent\voorwit\relax\noindent,
         \v!niet=>\parindent\voorwit\relax\noindent,
           \v!ja=>\parindent\voorwit\relax,            % geen \indent !
       \v!eerste=>\indentfirstparagraphtrue,
     \v!volgende=>\indentfirstparagraphfalse,
       \v!altijd=>\parindent\voorwit\relax,            % geen \indent !
        \v!nooit=>\parindent\zeropoint\relax]}

\def\inspringen%
  {\dosingleargument\doinspringen}

\def\nietinspringen{\inspringen[\v!nee,\v!volgende]}
\def\welinspringen {\inspringen[\v!ja,\v!eerste]}

% \frenchspacing leidt soms tot afbreken tussen -, vandaar
% de variant \newfrenchspacing.

\def\dofrenchspacing#1%
  {\sfcode`\.#1 \sfcode`\,#1\relax
   \sfcode`\?#1 \sfcode`\!#1\relax
   \sfcode`\:#1 \sfcode`\;#1\relax}

\def\frenchspacing   {\dofrenchspacing{1000}} 
\def\newfrenchspacing{\dofrenchspacing{1050}} 

\def\nonfrenchspacing
  {\sfcode`\.3000 \sfcode`\,1250 
   \sfcode`\?3000 \sfcode`\!3000
   \sfcode`\:2000 \sfcode`\;1500 }

\def\definespacingmethod[#1]#2{\setvalue{\??sg\??sg#1}{#2}}

\definespacingmethod[\v!opelkaar]{\newfrenchspacing}
\definespacingmethod[\v!ruim    ]{\nonfrenchspacing}

\def\complexstelspatieringin[#1]%
  {\executeifdefined{\??sg\??sg#1}\relax
   \updateraggedskips}

\def\simplestelspatieringin
  {\updateraggedskips}

\definecomplexorsimple\stelspatieringin

\bgroup
\catcode`\~=\@@active       % eigenlijk is ~ al actief
\gdef\fixedspaces%          % in Plain \TeX, maar we weten
  {\catcode`\~=\@@active    % nooit wat er inmiddels is
   \def~{\fixedspace}}      % gebeurd, vandaar.
\egroup

\def\space               { }
\def\fixedspace          {\hskip.5em\relax}
\def\removelastspace     {\ifhmode\unskip\fi}
\def\nospace             {\removelastspace\ignorespaces}
\def\removeunwantedspaces{\ifhmode\unskip\unskip\unskip\unskip\fi}

\let\spatie     \space
\let\hardespatie\fixedspace
\let\geenspatie \nospace

\def\opelkaar%
  {\nointerlineskip}

\def\omlaag[#1]% nog eens mooier, relateren aan blanko
  {\nointerlineskip
   \vskip#1 }

%D A couple of plain macros: 

\ifx\thinspace\undefined

  \def\thinspace   {\kern .16667em }
  \def\negthinspace{\kern-.16667em }
  \def\enspace     {\kern     .5em }

\fi 

\ifx\quad\undefined

  \def\enskip{\hskip.5em\relax}
  \def\quad  {\hskip 1em\relax}
  \def\qquad {\hskip 2em\relax}

\fi 

\ifx\smallskip\undefined

  \def\smallskip{\vskip\smallskipamount}
  \def\medskip  {\vskip\medskipamount}
  \def\bigskip  {\vskip\bigskipamount}

\fi 

\ifx\allowbreak\undefined

  \def\break     {\penalty-\@M}
  \def\nobreak   {\penalty \@M}
  \def\allowbreak{\penalty \z@}
  \def\filbreak  {\par\vfil\penalty-200\vfilneg}
  \def\goodbreak {\par\penalty-500 }

\fi 

%D Made slightly more readable:

\ifx\vglue\undefined

  \def\vglue  {\afterassignment\dovglue\scratchskip=}
  \def\hglue  {\afterassignment\dohglue\scratchskip=}
  \def\topglue{\nointerlineskip\vglue-\topskip\vglue} 

  \def\dovglue
    {\par 
     \scratchdimen\prevdepth 
     \hrule\!!height\zeropoint
     \nobreak\vskip\scratchskip 
     \prevdepth\scratchdimen}

  \def\dohglue
    {\leavevmode 
     \scratchcounter\spacefactor 
     \vrule\!!width\zeropoint
     \nobreak\hskip\scratchskip 
     \spacefactor\scratchcounter}

\fi 

\ifx\eject\undefined 

  \def\eject{\par\break}

\fi 

\ifx\supereject\undefined

  \def\supereject{\par\penalty-\@MM}

\fi 

\ifx\dosupereject\undefined

  \def\dosupereject
    {\ifnum\insertpenalties>\z@ % something is being held over
       \line{}
       \kern-\topskip
       \nobreak
       \vfill\supereject
     \fi}

\fi 

%D We adapt plain's \type {\removelastskip} a bit: 

\ifx\removelastskip\undefined

  \def\removelastskip
    {\ifvmode \ifdim\lastskip=\zeropoint \else
       \vskip-\lastskip
     \fi \fi}

\fi 

\ifx\smallbreak\undefined

\def\smallbreak
  {\par
   \ifdim\lastskip<\smallskipamount
     \removelastskip
     \penalty-50
     \smallskip
   \fi}

\def\medbreak
  {\par
   \ifdim\lastskip<\medskipamount
     \removelastskip
     \penalty-100
     \medskip
   \fi}

\def\bigbreak
  {\par
   \ifdim\lastskip<\bigskipamount
     \removelastskip
     \penalty-200
     \bigskip
   \fi}

\fi 

\newskip\tussenwit \tussenwit\zeropoint

\def\blankokleinmaat  {\smallskipamount}
\def\blankomiddelmaat {\medskipamount}
\def\blankogrootmaat  {\bigskipamount}
\def\currentwitruimte {\zeropoint}

\def\stelwitruimteopnieuwin%
  {\expanded{\stelwitruimtein[\currentwitruimte]}}

\newif\ifwitruimteflexibel \witruimteflexibeltrue

\definecomplexorsimple\stelwitruimtein

\def\complexstelwitruimtein[#1]%
  {\expanded{\dostelwitruimtein[#1]}%
   \dodostelwitruimtein}

\def\dostelwitruimtein[#1]%
  {\processallactionsinset
     [#1]
     [\v!herstel=>,
         \v!vast=>\witruimteflexibelfalse,
     \v!flexibel=>\witruimteflexibeltrue,
        \v!regel=>\tussenwit\baselineskip,
   \v!halveregel=>\tussenwit.5\baselineskip,
      \s!default=>\doifnot\currentwitruimte\v!geen\stelwitruimteopnieuwin,
      \s!unknown=>\@EA\assigndimension\@EA{\commalistelement} % \@EA is nodig
                    \tussenwit\blankokleinmaat\blankomiddelmaat\blankogrootmaat]}   % te vangen

\def\dodostelwitruimtein%
  {\edef\currentwitruimte%
     {\ifdim\tussenwit=\zeropoint
        \v!geen
      \else
        \ifgridsnapping\the\baselineskip\else\the\tussenwit\fi
      \fi}%
   \ifgridsnapping
     \witruimteflexibelfalse
     \tussenwit=1\tussenwit
     \ifdim\tussenwit>\zeropoint
       \tussenwit=\baselineskip
     \fi
   \else
     \ifwitruimteflexibel \else \tussenwit=1\tussenwit \fi
   \fi
   \parskip=\tussenwit}

\def\simplestelwitruimtein% == snelle \stelwitruimtein[\s!default]
  {\doifnot\currentwitruimte\v!geen\stelwitruimteopnieuwin
   \dodostelwitruimtein}

\def\geenwitruimte%
  {\ifdim\parskip>\zeropoint\relax
     \ifdim\lastskip=-\parskip
     \else
       \vskip-\parskip
     \fi
   \fi}

\def\savecurrentwitruimte%
  {\edef\restorecurrentwitruimte%
     {\tussenwit=\the\tussenwit
      \parskip=\the\parskip
      \noexpand\def\noexpand\currentwitruimte{\currentwitruimte}%
      \ifwitruimteflexibel
        \noexpand\witruimteflexibeltrue
      \else
        \noexpand\witruimteflexibelfalse
      \fi}}

% deze variant is nodig binnen \startopelkaar
% steeds testen:
%
% \hoofdstuk{..}
% \plaatslijst[..]
% \hoofdstuk{..}
% \input tufte
%
% met/zonder witruimte

\def\witruimte%
  {\par
   \ifdim\parskip>\zeropoint\relax
    %\ifdim\lastskip>\parskip \else
     % \removelastskip interferes with blanko blokkeer en klein
       \vskip\parskip
    %\fi
   \fi}

\def\nonoblanko[#1]%
  {\par}

\def\noblanko%
  {\dosingleempty\nonoblanko}

% De onderstaande macro handelt ook de situatie dat er geen
% tekst tussen \start ... \stop is geplaatst. Daartoe wordt de
% laatste skip over de lege tekst heen gehaald. Dit komt goed
% van pas bij het plaatsen van (mogelijk lege) lijsten.

\newif\ifopelkaar

\def\noparskipsignal {0.00001pt}
\def\lastdoneparskip {0pt}

\def\startopelkaar%
  {\dosingleempty\dostartopelkaar}

\def\dostartopelkaar[#1]% nesting afvangen
  {\par
   \ifvmode
     \edef\lastdoneparskip{\the\lastskip}%
\edef\lastdoneprevdepth{\the\prevdepth}% zeer recent toegevoegd
     \ifdim\prevdepth=-1000pt   % toegevoegd omdat binnen
     \else                      % een vbox een extra skip
       \witruimte               % ongewenst is; dit kan
\baselinecorrection %% zie in \plaatsregister[n=1]
       \vskip\noparskipsignal   % waarschijnlijk ook in
     \fi                        % blanko blokkeer
     \bgroup
     \doifelse{#1}\v!blanko
       \opelkaarfalse
       \opelkaartrue
     \blanko[\v!blokkeer]
     \stelwitruimtein[\v!geen]
  \fi}

\def\stopopelkaar%
  {\par
\ifvmode
   \egroup
   \ifdim\lastskip=\noparskipsignal\relax
     \removelastskip
     \geenwitruimte
     \vskip-\lastdoneparskip
     \vskip+\lastdoneparskip
\prevdepth-\lastdoneprevdepth % zeer recent toegevoegd
   \fi
\fi}

\def\startvanelkaar%
  {\blanko
   \leavevmode
   \bgroup}

\def\stopvanelkaar%
  {\egroup
   \blanko}

% De onderstaande macro's moeten nog eens nader worden uitgewerkt.
% Ze spelen een rol bij de spatiering rond omkaderde teksten
% en/of boxen zonder diepte.

\def\toonregelcorrectie   {\showbaselinecorrection}
\def\regelcorrectie       {\baselinecorrection}

\definecomplexorsimpleempty\startregelcorrectie

% \prevdepth crosses pageboundaries!

\let\dorondomregelcorrectie=\relax

\def\complexstartregelcorrectie[#1]%
  {\bgroup
   \processaction
     [#1]
     [ \v!blanko=>\let\dorondomregelcorrectie=\blanko,
      \s!default=>\let\dorondomregelcorrectie=\relax,
      \s!unknown=>{\def\dorondomregelcorrectie{\blanko[#1]}}]%
   \dorondomregelcorrectie
   \startbaselinecorrection
   \offbaselinecorrection}

\def\stopregelcorrectie%
  {\stopbaselinecorrection
   \dorondomregelcorrectie
   \egroup}

\def\corrigeerwitruimte%
  {\dowithnextbox
     {\startbaselinecorrection
      \box\nextbox
      \stopbaselinecorrection}%
   \vbox}

\def\toonstruts%
  {\setteststrut}

% Hieronder volgen enkele instellingen en macro's ten behoeve
% van de interlinie en \strut. De waarden 2.8, 0.07, 0.72 en
% 0.28 zijn ooit eens ontleend aan INRS-TEX en moeten wellicht
% nog eens instelbaar worden.
%
%   \lineheight        : de hoogte van een regel
%   \spacing{getal}    : instellen interlinie
%   \normalbaselines   : instellen regelafstend
%
%   \setstrut          : instellen \strut
%   \setnostrut        : resetten \strut, \endstrut, \begstrut
%
%   \setteststrut      : instellen zichtbare struts
%   \resetteststrut    : instellen onzichtbare struts
%
%   \setfontparameters : instellen na fontset
%
% De hoogte van een regel (\lineheight) is gelijk aan de
% som van de hoogte (\ht) en diepte (\dp) van \strutbox.
%
%   \strut            : denkbeeldig blokje met hoogte en diepte
%
% Een \hbox kan als deze aan het begin van een regel staat
% een breedte \hsize krijgen. Dit is soms te voorkomen met het
% commando \leavevmode. Binnen een \vbox geeft dit echter
% niet altijd het gewenste resultaat, vandaar het commando
%
%   \leaveoutervmode

% Pas op: niet zomaar \topskip en \baselineskip aanpassen
% en zeker niet \widowpenalty. Dit kan ernstige gevolgen
% hebben voor kolommen.
%
% Enige glue kan op zich geen kwaad, echter als blanko=vast,
% dan moet ook de rek 0 zijn. Binnen kolommen is rek ook
% niet bepaald mooi. Een hele kleine waarde (0.025) voldoet,
% omdat een positieve glue eindeloos rekbaar is.

\newdimen\strutdimen
\newdimen\lineheight
\newdimen\openlineheight
\newdimen\openstrutheight
\newdimen\openstrutdepth
\def\strutheightfactor      {.72}
\def\strutdepthfactor       {.28}

\def\baselinefactor         {2.8}
\def\baselinegluefactor     {0}

\def\normallineheight       {\baselinefactor ex}
\def\minimallinedistance    {\lineskip} 

\def\strutheight            {0pt}
\def\strutdepth             {0pt}
\def\strutwidth             {0pt}

\def\spacingfactor          {1}

\def\topskipfactor          {1.0}
\def\maxdepthfactor         {0.5}

\def\systemtopskipfactor    {\topskipfactor}
\def\systemmaxdepthfactor   {\maxdepthfactor}

% De onderstaande definitie wordt in de font-module overruled

\ifx\globalbodyfontsize\undefined
  \newdimen\globalbodyfontsize
  \globalbodyfontsize=12pt
\fi
\ifx\normalizedbodyfontsize\undefined
  \def\normalizedbodyfontsize{12pt}
\fi

% door een \dimen. Dit is geen probleem omdat (1) de default
% korpsgrootte 12pt is en (2) de fonts nog niet geladen zijn
% en de instellingen bij het laden nogmaals plaatsvinden.

\def\topskipcorrection%
  {\ifdim\topskip>\openstrutheight
     \vskip\topskip
     \vskip-\openstrutheight
   \fi
   \vbox{\strut}
   \vskip-\openlineheight}

\def\settopskip% the extra test is needed for the lbr family
  {\topskip\systemtopskipfactor\globalbodyfontsize
   \ifgridsnapping \else
     \ifr@ggedbottom\!!plus5\globalbodyfontsize\fi
   \fi
   \relax % the skip
   \ifdim\topskip<\strutheightfactor\openlineheight
     \topskip\strutheightfactor\openlineheight\relax
   \fi}

\def\setmaxdepth%
  {\maxdepth\systemmaxdepthfactor\globalbodyfontsize}

\def\normalbaselines%
  {\baselineskip\normalbaselineskip
   \lineskip\normallineskip
   \lineskiplimit\normallineskiplimit}

\def\setnormalbaselines%
  {\lineheight\normallineheight
   \openlineheight\spacingfactor\lineheight
   \openstrutheight\strutheightfactor\openlineheight
   \openstrutdepth \strutdepthfactor \openlineheight
   \normalbaselineskip\openlineheight
     \!!plus\baselinegluefactor\openlineheight
     \!!minus\baselinegluefactor\openlineheight
   \normallineskip\minimallinedistance\relax % \!!onepoint\relax
   \normallineskiplimit\zeropoint\relax
   \normalbaselines}

\def\setspacingfactor#1\to#2\by#3\\%
  {\strutdimen#2pt\relax
   \strutdimen#3\strutdimen
   \edef#1{\withoutpt{\the\strutdimen}}}

\def\spacing#1%
  {\ifgridsnapping
     \doifnot{#1}{1}{\showmessage{\m!layouts}{11}{#1}}%
     \edef\spacingfactor{1}%
   \else
     \edef\spacingfactor{#1}%
   \fi
   \setspacingfactor\systemtopskipfactor \to\topskipfactor \by#1\\%
   \setspacingfactor\systemmaxdepthfactor\to\maxdepthfactor\by#1\\%
   \setnormalbaselines
   \setstrut}

\def\setstrutdimen#1#2#3%             % een strut is n.m maal ex
  {\strutdimen\normallineheight       % wat niet per se \lineheight
   \strutdimen#2\strutdimen           % is omdat een strut lokaal
   \strutdimen#3\strutdimen           % kan afwijken van de globale
   \edef#1{\the\strutdimen}}          % strut

% plain definition:
%
% \def\strut{\relax\ifmmode\copy\strutbox\else\unhcopy\strutbox\fi}
%
% could be: 
%
% \def\strut{\relax\ifmmode\copy\else\unhcopy\fi\strutbox}

\ifx\strutbox\undefined 
  
  \newbox\strutbox

  \setbox\strutbox=\hbox{\vrule height8.5pt depth3.5pt width\z@}

 %\def\strut{\relax\ifmmode\copy\strutbox\else\unhcopy\strutbox\fi}
  \def\strut{\relax\ifmmode\copy\else\unhcopy\fi\strutbox}

\fi 

\let\normalstrut=\strut 

% The double \hbox construction enables us to \backtrack
% boxes.

% \def\setstrut%
%   {\setstrutdimen\strutheight\strutheightfactor\spacingfactor
%    \setstrutdimen\strutdepth \strutdepthfactor \spacingfactor
%    \let\strut=\normalstrut
%    \setbox\strutbox=\normalhbox
%      {\normalhbox
%         {\vrule
%            \!!width  \strutwidth
%            \!!height \strutheight
%            \!!depth  \strutdepth
%            \normalkern-\strutwidth}}}

\def\setstrut%
  {\setstrutdimen\strutheight\strutheightfactor\spacingfactor
   \setstrutdimen\strutdepth \strutdepthfactor \spacingfactor
   \dosetstrut}

\def\setcharstrut#1%
  {\setbox\strutbox\hbox{#1}% 
   \edef\strutheight{\the\ht\strutbox}%
   \edef\strutdepth {\the\dp\strutbox}%
   \dosetstrut}

\def\setcapstrut% could be M, but Q has descender
  {\setcharstrut{Q}} 

%D Centered looks nicer: 

\def\dosetstrut%
  {\let\strut\normalstrut
   \setbox\strutbox\normalhbox
     {\normalhbox to \zeropoint
        {% \hss % new, will be option 
         \vrule
           \!!width \strutwidth
           \!!height\strutheight
           \!!depth \strutdepth
         \hss}}}

%D Sometimes a capstrut comes in handy
%D
%D \starttabulatie[|Tl|l|l|]
%D \NC yes          \NC normal strut               \NC {\toonstruts\setupstrut[ja]\strut}  \NC \NR 
%D \NC no           \NC no strut                   \NC {\toonstruts\setupstrut[nee]\strut}  \NC \NR 
%D \NC kap          \NC a capital strut (i.e. Q)   \NC {\toonstruts\setupstrut[kap]\strut} \NC \NR 
%D \NC A B \unknown \NC a character strut (e.g. A) \NC {\toonstruts\setupstrut[A]\strut}   \NC \NR 
%D \NC              \NC a normal strut             \NC {\toonstruts\setupstrut\strut}      \NC \NR 
%D \stoptabulatie

\def\setupstrut%
  {\dosingleempty\dosetupstrut}

\def\dosetupstrut[#1]% yet undocumented 
  {\processaction
     [#1]
     [     \v!ja=>\setstrut,
          \v!nee=>\setnostrut,
          \v!kap=>\setcapstrut,
      \s!default=>\setstrut,
      \s!unknown=>\setcharstrut{\commalistelement}]}

\def\setteststrut%
  {\def\strutwidth{.8pt}%
   \setstrut}

\def\begstrut%
  {%relax\ifdim\ht\strutbox=\zeropoint\else
   \relax\ifcase\ht\strutbox\else 
     \strut
     \normalpenalty\@M % \!!tenthousand
     \normalhskip\zeropoint
     \ignorespaces
   \fi}

\def\endstrut%
  {%relax\ifhmode\ifdim\ht\strutbox=\zeropoint\else
   \relax\ifhmode\ifcase\ht\strutbox\else 
     \removeunwantedspaces
     \normalpenalty\@M % \!!tenthousand
     \normalhskip\zeropoint
     \strut
   \fi\fi}

\newbox\nostrutbox \setbox\nostrutbox\normalhbox{\normalhbox{}}

\def\setnostrut%
  {\setbox\strutbox\copy\nostrutbox 
   \let\strut\empty
   \let\endstrut\empty
   \let\begstrut\empty}

% unsave:
%
% \def\pseudostrut%
%   {\bgroup
%    \setnostrut
%    \normalstrut
%    \egroup}
%
% try:
%
% \startchemie
%   \chemie[ONE,Z0,SB15,MOV1,SB15,Z0][C,C]
% \stopchemie
%
% so:

\def\pseudostrut%
  {\noindent} % better: \dontleavehmode

\let\pseudobegstrut\pseudostrut

\let\pseudoendstrut\removeunwantedspaces

\def\resetteststrut%
  {\let\strutwidth\!!zeropoint
   \setstrut}

\ifx\setfontparameters\undefined
  \def\setfontparameters{\the\everybodyfont}
\fi

%D Handy: 

\def\baselinedistance{\the\lineheight}

%D We need \type{\normaloffinterlineskip} because the new
%D definition contains an assignment, and |<|don't ask me
%D why|>| this assignment gives troubles in for instance the
%D visual debugger.

%D The plain ones: 

\def\offinterlineskip
  {\baselineskip-1000\p@
   \lineskip\zeropoint
   \lineskiplimit\maxdimen}

\def\nointerlineskip
  {\prevdepth-1000\p@}

\let\normaloffinterlineskip=\offinterlineskip % knuth's original

%D My own one: 

\def\offinterlineskip%
  {\ifdim\baselineskip>\zeropoint
     \edef\oninterlineskip%
       {\baselineskip\the\baselineskip
        \lineskip\the\lineskip
        \lineskiplimit\the\lineskiplimit
        \let\noexpand\offinterlineskip\noexpand\normaloffinterlineskip}%
   \else
     \let\oninterlineskip\setnormalbaselines
   \fi
   \normaloffinterlineskip}

\let\oninterlineskip=\relax

\def\leaveoutervmode%
  {\ifvmode\ifinner\else
     \leavevmode
   \fi\fi}

% We stellen enkele penalties anders in dan Plain TEX:

\def\defaultwidowpenalty{2000} % was: 1000
\def\defaultclubpenalty {2000} % was:  800

\widowpenalty=\defaultwidowpenalty\relax
\clubpenalty =\defaultclubpenalty \relax

% Bovendien definieren we enkele extra \fill's:

\def\hfilll{\hskip\zeropoint\!!plus1filll\relax}
\def\vfilll{\vskip\zeropoint\!!plus1filll\relax}

% De onderstaande hulpmacro's moeten nog eens instelbaar worden
% gemaakt.

\def\tfskipsize{1em\relax}

\def\tfkernsize{1ex\relax}

\def\tfskip%
  {{\tf\hskip\tfskipsize}}

\def\tfkern%
  {{\tf\kern\tfkernsize}}

\newskip\linkssmaller
\newskip\rechtssmaller
\newskip\middensmaller

\def\dosinglesmaller#1%
  {\processaction
     [#1]
     [    \v!links=>\global\advance\linkssmaller  \@@sllinks,
         \v!midden=>\global\advance\middensmaller \@@slmidden,
         \v!rechts=>\global\advance\rechtssmaller \@@slrechts,
        \s!unknown=>\global\advance\middensmaller \commalistelement]}

\def\dosmaller[#1]%
  {\processaction
     [#1]
     [    \v!links=>\global\advance\linkssmaller  \@@sllinks,
         \v!midden=>\global\advance\middensmaller \@@slmidden,
         \v!rechts=>\global\advance\rechtssmaller \@@slrechts,
        \s!unknown=>{\herhaalmetcommando[#1]\dosinglesmaller}]}

\def\complexstartsmaller[#1]%
  {\par
   \bgroup
   \global\linkssmaller \zeropoint
   \global\rechtssmaller\zeropoint
   \global\middensmaller\zeropoint
   \processcommalistwithparameters[#1]\dosmaller
   \advance\leftskip  \linkssmaller
   \advance\rightskip \rechtssmaller
   \advance\leftskip  \middensmaller
   \advance\rightskip \middensmaller}

\def\simplestartsmaller%
  {\startsmaller[\v!midden]}

\definecomplexorsimple\startsmaller

\def\stopsmaller%
  {\par % else skips forgotten
   \egroup}

\def\stelsmallerin%
  {\dodoubleargument\getparameters[\??sl]}

\def\dodefinieerhbox[#1][#2]%
  {\setvalue{hbox#1}##1%
     {\hbox to #2{\begstrut##1\endstrut\hss}}}

\def\definieerhbox%
  {\dodoubleargument\dodefinieerhbox}

\def\lrcbox#1#2#%
  {\vbox#2\bgroup
   \let\\=\endgraf
   \forgetall#1\let\next=}

\def\lbox%
  {\lrcbox\raggedleft}

\def\rbox%
  {\lrcbox\raggedright}

\def\cbox%
  {\lrcbox\raggedcenter}

\def\dosetraggedvbox#1%
  {\processaction
     [#1]
     [  \v!links=>\let\raggedbox\lbox,
       \v!rechts=>\let\raggedbox\rbox,
       \v!midden=>\let\raggedbox\cbox,
          \v!nee=>\def\raggedbox{\vbox\bgroup\raggedright\let\next=},
      \s!default=>\let\raggedbox\vbox,
      \s!unknown=>\let\raggedbox\vbox]}

\def\dosetraggedhbox#1%
  {\processaction
     [#1]
     [  \v!links=>\let\raggedbox\regellinks,
       \v!rechts=>\let\raggedbox\regelrechts,
       \v!midden=>\let\raggedbox\regelmidden,
      \v!normaal=>\let\raggedbox\hbox,
      \s!default=>\let\raggedbox\hbox,
      \s!unknown=>\let\raggedbox\hbox]}

% \def\dosetraggedcommand#1% ook ruim,rechts en zo
%   {\processaction
%      [#1]
%      [  \v!links=>\def\raggedcommand{\raggedleft},
%        \v!rechts=>\def\raggedcommand{\raggedright},
%        \v!midden=>\def\raggedcommand{\raggedcenter},
%           \v!nee=>\def\raggedcommand{\raggedright},
%       \v!normaal=>\let\raggedcommand\relax,
%       \s!default=>\def\raggedcommand{\raggedcenter},
%       \s!unknown=>\let\raggedcommand\relax]}

\def\dosetraggedcommand#1% 
  {\expanded{\dodosetraggedcommand{#1}}}
 
% \def\dodosetraggedcommand#1% 
%   {\doifinsetelse{\v!ruim} {#1}{\!!doneatrue}{\!!doneafalse}%
%    \doifinsetelse{\v!breed}{#1}{\!!donebtrue}{\!!donebfalse}%
%    \let\raggedcommand\relax
%    \let\raggedtopcommand\empty
%    \let\raggedbottomcommand\empty
%    \!!donectrue
%    \ExpandFirstAfter\processallactionsinset
%      [#1]
%      [  \v!links=>\if!!donea      \def\raggedcommand{\veryraggedleft}%
%                   \else           \def\raggedcommand{\raggedleft}%
%                   \fi
%                   \!!donecfalse,                    % {\v!links,\v!midden}
%        \v!rechts=>\if!!donea      \def\raggedcommand{\veryraggedright}%
%                   \else           \def\raggedcommand{\raggedright}%
%                   \fi
%                   \!!donecfalse,                    % {\v!rechts,\v!midden}
%        \v!midden=>\if!!donec
%                     \if!!doneb      \def\raggedcommand{\raggedwidecenter}%
%                     \else\if!!donea \def\raggedcommand{\veryraggedcenter}%
%                     \else           \def\raggedcommand{\raggedcenter}%
%                     \fi\fi
%                     \!!donecfalse                   % {\v!midden,\v!midden}
%                   \else
%                     \let\raggedbottomcommand\vfilll % bonus, pretty strong 
%                     \let\raggedtopcommand   \vfilll % used with \framed for 
%                   \fi,                              % instance in tables
%          \v!hoog=>\let\raggedbottomcommand\vfilll,  % and since we lack a 
%          \v!laag=>\let\raggedtopcommand   \vfilll,  % proper keyword, but
%          \v!laho=>\let\raggedbottomcommand\vfilll   % we do support the 
%                   \let\raggedtopcommand   \vfilll,  % ugly laho (lohi)
%           \v!nee=>\def\raggedcommand{\raggedright},
%            \v!ja=>\let\raggedcommand\notragged,  % was \relax
%       \v!normaal=>\let\raggedcommand\notragged]} % was \relax
% 
% much faster and important since TABLE uses them a lot:

\def\dodosetraggedcommand#1%
  {\let\raggedcommand\relax
   \let\raggedtopcommand\empty
   \let\raggedbottomcommand\empty
   \doifsomething{#1}
     {\doifinsetelse{\v!ruim} {#1}\!!doneatrue\!!doneafalse
      \doifinsetelse{\v!breed}{#1}\!!donebtrue\!!donebfalse
      \!!donectrue
      \rawprocesscommalist[#1]\dododosetraggedcommand}}

\def\dododosetraggedcommand#1%
  {\executeifdefined{\@@ragged@@command\string#1}\relax}

\def\@@ragged@@command{@@raggedcommand}

\setvalue{\@@ragged@@command\v!links}%
  {\if!!donea \def\raggedcommand{\veryraggedleft}%
   \else      \def\raggedcommand{\raggedleft}%
   \fi
   \!!donecfalse}

\setvalue{\@@ragged@@command\v!rechts}%
  {\if!!donea \def\raggedcommand{\veryraggedright}%
   \else      \def\raggedcommand{\raggedright}%
   \fi
   \!!donecfalse}

\setvalue{\@@ragged@@command\v!midden}%
  {\if!!donec
     \if!!doneb      \def\raggedcommand{\raggedwidecenter}%
     \else\if!!donea \def\raggedcommand{\veryraggedcenter}%
     \else           \def\raggedcommand{\raggedcenter}%
     \fi\fi
     \!!donecfalse
   \else
     \let\raggedbottomcommand\vfilll % bonus, pretty strong
     \let\raggedtopcommand   \vfilll % used with \framed for
   \fi}                              % instance in tables

\setvalue{\@@ragged@@command\v!hoog}%
  {\let\raggedbottomcommand\vfilll}  % and since we lack a

\setvalue{\@@ragged@@command\v!laag}%
  {\let\raggedtopcommand\vfilll}     % proper keyword, but

\setvalue{\@@ragged@@command\v!laho}%
  {\let\raggedbottomcommand\vfilll   % we do support the
   \let\raggedtopcommand\vfilll}     % ugly laho (lohi)

\setvalue{\@@ragged@@command\v!nee}%
  {\def\raggedcommand{\raggedright}}

\setvalue{\@@ragged@@command\v!ja}%
  {\let\raggedcommand\notragged}

\setvalue{\@@ragged@@command\v!normaal}%
  {\let\raggedcommand\notragged}

% Nodig i.v.m. inspringen eerste alineas

\def\explicithmode%
  {\unhbox\voidb@x}

% Nodig voor gebruikers

\def\geentest{\donottest}

% Nog doen:
%
%  \goodbreak -> \allowbreak en \dosomebreak{..} in koppen
%
% bij koppen zowieso: \blanko[reset]

% Nog in commando verwerken:
%
% \voorkeur … la \blanko
%
% Om ongewenste witruimte te voorkomen kan met \dosomebreak{\break}
% een \penalty v¢¢r witruimte worden geplaatst.

\def\removelastskip% a redefinition of plain 
  {\ifvmode\ifdim\lastskip=\zeropoint\else\vskip-\lastskip\fi\fi}

\def\dosomebreak#1%
  {\scratchskip\lastskip
   \removelastskip
   %\type{#1}%
   #1\relax
   \ifdim\scratchskip=\zeropoint \else
     \vskip\scratchskip
   \fi}

% beter, vooral in \vbox; nog in \pagina toepassen s!

\def\doifoutervmode#1%
  {\ifvmode\ifinner\else#1\fi\fi}

\def\dosomebreak#1%
  {\doifoutervmode
     {\scratchskip\lastskip
      \removelastskip
      %\leavevmode\type{#1}%
      #1\relax
      \ifdim\scratchskip=\zeropoint % else interference with footnotes
      \else
        \vskip\scratchskip
      \fi}}

% Idem:
%
% \springin

%\def\noindentation% vervallen
%   {\EveryPar
%     {\ifdim\parindent=\zeropoint
%      \else
%        \bgroup
%        \setbox\scratchbox\lastbox
%        \egroup
%      \fi
%      \EveryPar{}}}

\newif\ifindentation \indentationtrue  % documenteren, naar buiten

\let\checkindentation=\relax

\def\donoindentation%
  {\ifdim\parindent=\zeropoint \else
     \bgroup \setbox\scratchbox\lastbox \egroup
   \fi}

\def\noindentation% made global
  {\ifinpagebody \else
     \global\indentationfalse
     \gdef\checkindentation%
       {\donoindentation
        \gdef\checkindentation{\global\indentationtrue}}%
   \fi}

\def\nonoindentation% bv bij floats
  {\ifinpagebody \else
     \global\indentationtrue
     \gdef\checkindentation{\global\indentationtrue}%
   \fi}

\def\indentation%
  {\ifvmode \ifdim\parindent=\zeropoint \else
     % was : \hskip\parindent 
     % can be: \indent  
     % but we test: 
     \noindent\hskip\parindent 
   \fi \fi}

% vergeten

%\def\forgeteverypar%
%  {\everypar\emptytoks}

\def\forgeteverypar%
  {\everypar{\the\neverypar}}

%\def\forgetparindent%
%  {\forgeteverypar
%   \indentfirstparagraphtrue % recently added
%   \stelinspringenin[\v!geen]}

%\def\forgetparskip%
%  {\stelwitruimtein[\v!geen]}

\def\forgetparindent
  {\forgeteverypar
   \indentfirstparagraphtrue % recently added
   \let\currentvoorwit\v!geen
   \voorwit\zeropoint
   \parindent\zeropoint\relax}

\def\forgetparskip%
  {\let\currentwitruimte\v!geen
   \tussenwit\zeropoint
   \parskip\zeropoint\relax}

\def\forgetbothskips%
  {\tolerance=1500
   \leftskip\zeropoint
   \rightskip\zeropoint\relax}

\def\forgetspacing%
  {\emergencystretch\zeropoint}

\def\forgetall%
  {\the\everyforgetall}

\appendtoks \forgetragged       \to \everyforgetall 
\appendtoks \forgetparskip      \to \everyforgetall  
\appendtoks \forgetparindent    \to \everyforgetall 
\appendtoks \forgetbothskips    \to \everyforgetall 
\appendtoks \forgetspacing      \to \everyforgetall % i.v.m. funny spacing in pagebody
\appendtoks \everypar\emptytoks \to \everyforgetall % indeed!

\def\localvbox#1#%
  {\vbox#1\bgroup
     \forgetparskip
     \setlocalhsize
     \hsize=\localhsize
     \forgetparindent
     \forgetbothskips
     \forgeteverypar
     \let\next=}

% ach ja, hoort niet hier

% \unexpanded\def\dostartattributes#1#2#3%
%   {\begingroup  % geen \bgroup, anders in mathmode lege \hbox
%    \doifdefinedelse{#1#2}
%      {\def\fontattribute{\getvalue{#1#2}}}
%      {\let\fontattribute=\empty}%
%    \doifdefinedelse{#1#3}
%      {\def\colorattribute{\getvalue{#1#3}}}
%      {\let\colorattribute=\empty}%
%    \startcolor[\colorattribute]%
%    \@EA\doconvertfont\@EA{\fontattribute}}
% 
% \unexpanded\def\dostopattributes%
%   {\stopcolor
%    \endgroup}
% 
% \unexpanded\def\doattributes#1#2#3#4%
%   {\dostartattributes{#1}{#2}{#3}{#4}\dostopattributes}

%D A hardly faster implementation follows. We cannot use 
%D \type {csname} testing since the first argument can be 
%D anything, even a raw fontswitch. No a real improvement 
%D (some 5 seconds on 260 seconds for the maps bibliography).  
 
\beginTEX 

\unexpanded\def\dostartattributes#1#2#3%
  {\begingroup  % geen \bgroup, anders in mathmode lege \hbox
   \@EA\ifx\csname#1#3\endcsname\relax
     \let\dostopattributes\endgroup
   \else
     \let\dostopattributes\@@dostopattributes
     \startcolor[\csname#1#3\endcsname]%
   \fi
   \@EA\ifx\csname#1#2\endcsname\relax
     \expandafter\gobbleoneargument
   \else
     \expandafter\doconvertfont
   \fi{\csname#1#2\endcsname}}

\endTEX

\beginETEX \ifcsname

\unexpanded\def\dostartattributes#1#2#3%
  {\begingroup  % geen \bgroup, anders in mathmode lege \hbox
   \ifcsname#1#3\endcsname
     \let\dostopattributes\@@dostopattributes
     \startcolor[\csname#1#3\endcsname]%
   \else                  
     \let\dostopattributes\endgroup
   \fi
   \ifcsname#1#2\endcsname
     \expandafter\doconvertfont
   \else
     \expandafter\gobbleoneargument
   \fi{\csname#1#2\endcsname}}

\endETEX

\unexpanded\def\@@dostopattributes%
  {\stopcolor
   \endgroup}

\unexpanded\def\doattributes#1#2#3#4%
  {\dostartattributes{#1}{#2}{#3}{#4}\dostopattributes}

% An even faster \ETEX\ version: 

\beginETEX

% \unexpanded\def\dostartattributes#1#2#3%
%   {\begingroup  % geen \bgroup, anders in mathmode lege \hbox
%    \ifcsname#1#3\endcsname
%      \let\dostopattributes\@@dostopattributes
%      \startcolor[\csname#1#3\endcsname]%
%    \else
%      \let\dostopattributes\endgroup
%    \fi
%    \ifcsname#1#2\endcsname
%      \@EAEAEA\doconvertfont\@EA\@EA\csname#1#2\endcsname
%    \fi}
% 
% \unexpanded\def\@@dostopattributes%
%   {\stopcolor
%    \endgroup}

\unexpanded\def\dostartattributes#1#2#3%
  {\begingroup  % geen \bgroup, anders in mathmode lege \hbox
   \ifincolor
     \ifcsname#1#3\endcsname
       \let\dostopattributes\@@dostopattributes
       \doglobalstartcolor[\csname#1#3\endcsname]%
     \else
       \let\dostopattributes\endgroup
     \fi
   \else
     \let\dostopattributes\endgroup
   \fi
   \ifcsname#1#2\endcsname
     \@EAEAEA\doconvertfont\@EA\@EA\csname#1#2\endcsname
   \fi}

\unexpanded\def\@@dostopattributes%
  {\doglobalstopcolor
   \endgroup}

%D Since this happens a lot, and sometimes large arguments 
%D are passed in \type {#4}, we just copy some code:

\unexpanded\def\doattributes#1#2#3#4%
  {\begingroup  % geen \bgroup, anders in mathmode lege \hbox
   \ifincolor
     \ifcsname#1#3\endcsname
       \let\dostopattributes\@@dostopattributes
       \doglobalstartcolor[\csname#1#3\endcsname]%
     \else
       \let\dostopattributes\endgroup
     \fi
   \else
     \let\dostopattributes\endgroup
   \fi
   \ifcsname#1#2\endcsname
     \@EAEAEA\doconvertfont\@EA\@EA\csname#1#2\endcsname
   \fi
   {#4}%
   \dostopattributes}

\endETEX

% Kan vaker worden toegepast en moet bovendien sneller!

\newskip\leftskipadaption

\def\doadaptleftskip#1%
  {\dosetleftskipadaption{#1}%
   \advance\leftskip by \leftskipadaption}

\beginTEX

\def\dosetleftskipadaption#1%
  {\leftskipadaption\zeropoint
   \processaction[#1] % \ExpandFirstAfter
     [\v!standaard=>\leftskipadaption=
                    \ifdim\voorwit=\zeropoint\@@sllinks\else\voorwit\fi,
             \v!ja=>\leftskipadaption=
                    \ifdim\voorwit=\zeropoint\@@sllinks\else\voorwit\fi,
            \v!nee=>,
        \s!unknown=>\leftskipadaption=#1]}

\endTEX

\beginETEX

% installation 

\setvalue{@lsa@\v!standaard}%
  {\ifdim\voorwit=\zeropoint\@@sllinks\else\voorwit\fi}

\setvalue{@lsa@\v!ja}%
  {\ifdim\voorwit=\zeropoint\@@sllinks\else\voorwit\fi}

\setvalue{@lsa@\v!nee}%
  {\zeropoint}

\setvalue{@lsa@\empty}%
  {\zeropoint}

% not safe for 2\parindent
%
% \def\dosetleftskipadaption#1%
%   {\leftskipadaption
%      \ifcsname @lsa@#1\endcsname
%        \csname @lsa@#1\endcsname
%      \else 
%        #1%
%      \fi
%    \relax}

\def\dosetleftskipadaption#1%
  {\edef\ascii{@lsa@#1}%
   \convertcommand\ascii\to\ascii
   \leftskipadaption
     \ifcsname\ascii\endcsname
       \csname\ascii\endcsname
     \else 
       #1%
     \fi
   \relax}


\endETEX

% Dit hoort eigenlijk thuis onder het kopje boodschappen cq,
% meldingen.

\let\mindermeldingen\dontcomplain

\definetwopasslist{\s!paragraph}

\newcounter\nofraggedparagraphs

\def\doparagraphreference% looks very much like domarginreference
  {\doglobal\increment\nofraggedparagraphs\relax
   \edef\writeparref%
     {\writeutilitycommand%
        {\twopassentry%
           {\s!paragraph}%
           {\nofraggedparagraphs}%
           {\noexpand\realfolio}}}%
   \writeparref}

% \def\setraggedparagraphmode#1#2%
%   {\ifinner
%      \ifdubbelzijdig
%        \gettwopassdata{\s!paragraph}%
%        \iftwopassdatafound
%          \ifodd\twopassdata#1\else#2\fi
%        \else
%          \ifodd\realfolio#1\else#2\fi
%        \fi
%        \doparagraphreference
%      \else
%        #2\relax
%      \fi
%    \else
%      #2\relax
%    \fi}

\def\setraggedparagraphmode#1#2% combineren met \ifrightpage
  {\ifinpagebody
     \ifdubbelzijdig
       \ifodd\realpageno\relax#1\else#2\fi
     \else
       #2\relax
     \fi
   \else\ifinner
     \ifdubbelzijdig
       \gettwopassdata{\s!paragraph}%
       \iftwopassdatafound
         \ifodd\twopassdata\relax#1\else#2\fi
       \else
         \ifodd\realpageno\relax#1\else#2\fi
       \fi
       \doparagraphreference
     \else
       #2\relax
     \fi
   \else
     #2\relax
   \fi\fi}

% \let\doifrightpageelse\setraggedparagraphmode

% in both (otr) modules !

% \def\doifrightpageelse#1#2%
%   {\ifdubbelzijdig
%      \gettwopassdata\s!paragraph
%      \iftwopassdatafound
%        \ifodd\twopassdata#1\else#2\fi
%      \else
%        \ifodd\realfolio#1\else#2\fi
%      \fi
%    \else
%      #1% was #2
%    \fi}
% 
% better :

\def\doifrightpageelse % watch out: other default ! ! !
  {\ifinpagebody
     \ifdubbelzijdig
       \ifodd\twopassdata\relax 
         \twopassdatafoundtrue \else \twopassdatafoundfalse 
       \fi
     \else
       \twopassdatafoundtrue
     \fi
   \else     
     \ifdubbelzijdig
       \gettwopassdata\s!paragraph
       \iftwopassdatafound
         \ifodd\twopassdata\relax 
           \twopassdatafoundtrue \else \twopassdatafoundfalse 
         \fi
       \else
         \ifodd\realpageno\relax
           \twopassdatafoundtrue \else \twopassdatafoundfalse 
         \fi
       \fi
     \else
       \twopassdatafoundtrue
     \fi
   \fi
   \iftwopassdatafound
     \@EA\firstoftwoarguments     
   \else
     \@EA\secondoftwoarguments     
   \fi}

\def\signalrightpage
  {\ifdubbelzijdig
     \doparagraphreference
   \fi}

% De onderstaande macro's zijn opgenomen in Plain TeX.
%
% \def\raggedright%
%   {\rightskip\z@ plus2em \spaceskip.3333em \xspaceskip.5em\relax}
%
% \def\ttraggedright%
%   {\tttf\rightskip\z@ plus2em\relax}
%
% \newif\ifr@ggedbottom
%
% \def\raggedbottom%
%   {\topskip 10\p@ plus60\p@ \r@ggedbottomtrue}
%
% \def\normalbottom%
%   {\topskip 10\p@ \r@ggedbottomfalse}
%
% en worden hieronder wat aangepast.

% the three boolean will become obsolete some day in favour 
% of \bottomraggedness

\chardef\bottomraggedness=0 % 0=ragged 1=normal/align 2=baseline

\def\bottomalignlimit{3\lineheight}

\newif\ifn@rmalbottom
\newif\ifr@ggedbottom
\newif\ifb@selinebottom

\def\normalbottom%
  {% \topskip 10pt
   \r@ggedbottomfalse} 

\def\raggedbottom%
  {\chardef\bottomraggedness=0
   \n@rmalbottomfalse
   \r@ggedbottomtrue
   \b@selinebottomfalse
   \settopskip}

\def\alignbottom%
  {\chardef\bottomraggedness=1
   \n@rmalbottomtrue
   \r@ggedbottomfalse
   \b@selinebottomfalse
   \settopskip}

\def\baselinebottom%
  {\chardef\bottomraggedness=2
   \n@rmalbottomfalse
   \r@ggedbottomfalse
   \b@selinebottomtrue
   \settopskip}

\let\normalbottom=\alignbottom % downward compatible

% so, the new one will be
% 
% \chardef\bottomraggedness=0 % 0=ragged 1=normal/align 2=baseline
% 
% \def\bottomalignlimit{3\lineheight} % will be settable 
% 
% \def\raggedbottom  {\chardef\bottomraggedness=0 \settopskip}
% \def\alignbottom   {\chardef\bottomraggedness=1 \settopskip}
% \def\baselinebottom{\chardef\bottomraggedness=2 \settopskip}
%
% \let\normalbottom  =\alignbottom

% \hyphenpenalty  = ( 2.5 * \hsize ) / \raggedness
% \tolerance     >= 1500 % was 200
% \raggedness     = 2 .. 6\korpsgrootte

\chardef\raggedstatus=0 % normal left center right 

\def\leftraggedness   {2\bodyfontsize}
\def\rightraggedness  {2\bodyfontsize}
\def\middleraggedness {6\bodyfontsize}

%D More hyphenation control, will be combined with align 
%D setup. 

\def\nohyphens%
  {\ifx\dohyphens\relax
     \edef\dohyphens%
       {\hyphenpenalty\the\hyphenpenalty
        \exhyphenpenalty\the\exhyphenpenalty\relax}%
   \fi
   \hyphenpenalty\@M
   \exhyphenpenalty\@M}

\let\dohyphens\relax

%D To prevent unwanted side effects, we also have to check 
%D for hyphens here: 

\def\setraggedness#1%
  {\ifnum\tolerance<1500\relax       % small values have
     \tolerance=1500\relax           % unwanted side effects
   \fi                               
   \spaceskip=2.5\hsize              % we misuse these registers
   \xspaceskip=#1\relax              % for temporary storage;
   \divide\spaceskip by \xspaceskip  % they are changed anyway
   \ifx\dohyphens\relax               
     \hyphenpenalty=\spaceskip       % \else no hyphens is active 
   \fi}                              

\let\updateraggedskips\relax

\def\setraggedskips#1#2#3#4#5#6#7% never change this name
  {\def\updateraggedskips%
     {\dosetraggedskips{#1}{#2}{#3}{#4}{#5}{#6}{#7}}%
   \updateraggedskips}

\def\dosetraggedskips#1#2#3#4#5#6#7%
  {\chardef\raggedstatus=#1\relax 
   \leftskip=1\leftskip\!!plus#2\relax   % zie: Tex By Topic 8.1.3
   \rightskip=1\rightskip\!!plus#3\relax % zie: Tex By Topic 8.1.3
   \spaceskip#4\relax
   \xspaceskip#5\relax
   \parfillskip\zeropoint\!!plus#6\relax
   \parindent#7\relax}

% \def\notragged%
%   {\setraggedskips{0}{0em}{0em}{0em}{0em}{1fil}{\parindent}}

\def\notragged
  {\chardef\raggedstatus=0
   \leftskip1\leftskip
   \rightskip1\rightskip
   \spaceskip\zeropoint
   \xspaceskip\zeropoint
   \parfillskip\zeropoint\!!plus1fil\relax
   \let\updateraggedskips\relax} % new 

\let\forgetragged\notragged

\def\raggedleft%
  {\setraggedness\leftraggedness
   \setraggedskips{1}{\leftraggedness}{0em}{.3333em}{.5em}{0em}{0em}}

\def\raggedcenter%
  {\setraggedness\middleraggedness
   \setraggedskips{2}{\middleraggedness}{\middleraggedness}{.3333em}{.5em}{0em}{0em}}

%D We used to have:
%D
%D \starttypen
%D \def\raggedright%
%D   {\setraggedness\rightraggedness
%D    \setraggedskips{3}{0em}{\rightraggedness}{.3333em}{.5em}{0em}{\parindent}}
%D \stoptypen
%D
%D However, the next alternative, suggested by Taco, is better.

\def\raggedright%
  {\setraggedness\rightraggedness
   \setraggedskips{3}{0em}{\rightraggedness}{.3333em}{.5em}{1fil}{\parindent}}

\def\veryraggedleft%
  {\setraggedskips{1}{1fil}{0em}{.3333em}{.5em}{0em}{0em}}

%D When we want the last line to have a natural width:
%D
%D \starttypen
%D \def\veryraggedleft%
%D   {\setraggedskips{1}{1fil}{0em}{.3333em}{.5em}{0em}{-1fil}}
%D \stoptypen
%D
%D but this one is not accepted by the macros.

\def\veryraggedcenter%
  {\setraggedskips{2}{1fil}{1fil}{.3333em}{.5em}{0em}{0em}}

\def\veryraggedright%
  {\setraggedskips{3}{0em}{1fil}{.3333em}{.5em}{0em}{\parindent}}

\def\ttraggedright%
  {\tttf
   \setraggedskips{3}{0em}{\rightraggedness}{0em}{0em}{0em}{\parindent}} % {\voorwit}}

%D A bonus one:

\def\raggedwidecenter%
  {\setraggedness\middleraggedness
   \setraggedskips{2}{.5fil}{.5fil}{.3333em}{.5em}{0em}{0em}}

\newif\if@@asragged \@@asraggedtrue % old method 

\def\dodosteluitlijnenin[#1]%
  {\doifinsetelse{\v!ruim} {#1}{\!!doneatrue}{\!!doneafalse}%
   \doifinsetelse{\v!breed}{#1}{\!!donebtrue}{\!!donebfalse}%
   \ExpandFirstAfter\processallactionsinset
     [#1]
     [   \v!regel=>\baselinebottom,
         \v!onder=>\raggedbottom,
        \v!hoogte=>\normalbottom,
       \v!breedte=>\notragged,
       \v!normaal=>\notragged,
            \v!ja=>\notragged,
           \v!nee=>\raggedright,
\if@@asragged\v!binnen\else\v!buiten\fi
                 =>\setraggedparagraphmode\raggedleft\raggedright,
\if@@asragged\v!buiten\else\v!binnen\fi
                 =>\setraggedparagraphmode\raggedright\raggedleft,
\if@@asragged\v!links\else\v!rechts\fi
                 =>\if!!donea\veryraggedleft  \else\raggedleft  \fi,
\if@@asragged\v!rechts\else\v!links\fi
                 =>\if!!donea\veryraggedright \else\raggedright \fi,
        \v!midden=>\if!!doneb\raggedwidecenter\else
                   \if!!donea\veryraggedcenter\else\raggedcenter\fi\fi,
       \v!hangend=>\enableprotruding,
   \v!niethangend=>\disableprotruding,
    \v!afgebroken=>\dohyphens,
\v!nietafgebroken=>\nohyphens,
         \v!nieuw=>\@@asraggedfalse, % so new will give you consistency
         \v!reset=>\notragged\normalbottom]}

\def\dosteluitlijnenin[#1]%
  {\expanded{\dodosteluitlijnenin[#1]}}

\def\steluitlijnenin%
  {\dosingleargument\dosteluitlijnenin}

\def\startuitlijnen%
  {\bgroup
   \steluitlijnenin}

\def\stopuitlijnen
  {\par
   \egroup}

%\def\regellinks#1%
%  {\noindent\leftline{{\strut#1}}}
%
%\def\regelrechts#1%
%  {\noindent\rightline{{#1\strut}}}
%
%\def\regelmidden#1%
%  {\noindent\centerline{{\strut#1}}}

% \def\doalignline#1#2%
%   {\dowithnextbox
%      {\noindent\hbox to \hsize{\strut#1\unhbox\nextbox#2}}
%      \hbox}
% 
% also supporting \\
%
% \def\doalignline#1#2%
%   {\dowithnextbox
%      {\noindent\hbox to \hsize
%         {\strut#1\unhbox\nextbox#2}}
%      \hbox\bgroup
%        \def\\{\egroup\par\doalignline#1#2\bgroup}\let\next=}

\def\doalignline#1#2%
  {\bgroup
   \def\\{\egroup\par\doalignline{#1}{#2}\bgroup}%
   \dowithnextbox
     {\noindent\hbox to \hsize{\strut#1\unhbox\nextbox#2}\egroup}
     \hbox}

% directe commando's

\def\regellinks {\doalignline \relax \hss  }
\def\regelrechts{\doalignline \hss   \relax}
\def\regelmidden{\doalignline \hss   \hss  }

\def\regelbegrensd#1{\limitatetext{#1}{\hsize}{\unknown}}

% indirecte commando's

\setvalue{regel\v!links }{\doalignline \relax \hss  }
\setvalue{regel\v!rechts}{\doalignline \hss   \relax}
\setvalue{regel\v!midden}{\doalignline \hss   \hss  }

\def\doregelplaats#1%
  {\getvalue{regel#1}}

%D Experimental: 

\def\doxalignline#1#2%
  {\bgroup
   \def\\{\egroup\par\doxalignline{#1}{#2}\bgroup}% inefficient
   \dowithnextbox
     {\noindent\hbox to \hsize
        {\strut\signalrightpage
         \doifrightpageelse{#1\unhbox\nextbox#2}{#2\unhbox\nextbox#1}}%
      \egroup}
     \hbox}

\setvalue{regel\v!binnen}{\doxalignline\relax\hss}
\setvalue{regel\v!buiten}{\doxalignline\hss\relax}

%D ... 

\def\dosteltolerantiein[#1]%
  {\doifinsetelse{\v!vertikaal}{#1}%
     {\ExpandFirstAfter\processallactionsinset
        [#1]
        [\v!zeerstreng=>\def\bottomtolerance{},
             \v!streng=>\def\bottomtolerance{.050},
             \v!soepel=>\def\bottomtolerance{.075},
         \v!zeersoepel=>\def\bottomtolerance{.100}]}%
     {\ExpandFirstAfter\processallactionsinset
        [#1]
        [       \v!rek=>\emergencystretch=\bodyfontsize,
             \v!spatie=>\spaceskip.5em\!!plus.25em\!!minus.25em\relax,
         \v!zeerstreng=>\tolerance=200,
             \v!streng=>\tolerance=1500,
             \v!soepel=>\tolerance=3000,
         \v!zeersoepel=>\tolerance=4500]}}

\def\steltolerantiein%
  {\dosingleargument\dosteltolerantiein}

\def\woordrechts%
  {\groupedcommand{\hfill\hbox}{\parfillskip\zeropoint}}

%D \macros
%D   {pushindentation,popindentation}
%D
%D The pushing and popping is done by:

\newbox\indentationboxA
\newbox\indentationboxB

\def\pushindentation%
  {\bgroup
   \ifhmode
     \unskip
     \setbox\indentationboxA=\lastbox       % get \strut if present
     \unskip
     \setbox\indentationboxB=\lastbox       % get \indent generated box
     \unskip
   \else
     \hskip\zeropoint                       % switch to horizontal mode
     \unskip
     \setbox\indentationboxA=\lastbox       % get \indent generated box
     \setbox\indentationboxB=\box\voidb@x
   \fi}

\def\popindentation%
  {\box\indentationboxB\box\indentationboxA % put back the boxes
   \egroup}

%D The only complication lays in \type{\strut}. In \PLAIN\
%D \TEX\ a \type{\strut} is defined as:
%D
%D \starttypen
%D \def\strut%
%D   {\relax\ifmmode\copy\strutbox\else\unhcopy\strutbox\fi}
%D \stoptypen
%D
%D But what is a \type{\strut}? Normally it's a rule of width
%D zero, but when made visual, it's a rule and a negative skip.
%D The mechanism for putting things in the margins described
%D here cannot handle this situation very well. One
%D characteristic of \type{\strut} is that the \type{\unhcopy}
%D results in entering horizontal mode, which in return leads
%D to some indentation.
%D
%D To serve our purpose a bit better, the macro \type{\strut}
%D can be redefined as:
%D
%D \starttypen
%D \def\strut%
%D   {\relax\ifmmode\else\hskip0pt\fi\copy\strutbox}
%D \stoptypen
%D
%D Or more compatible:
%D
%D \starttypen
%D \def\strut%
%D   {\relax\ifmmode
%D      \copy\strutbox
%D    \else
%D      \bgroup\setbox\strutbox=\normalhbox{\box\strutbox}\unhcopy\strutbox\egroup
%D    \fi}
%D \stoptypen
%D
%D In \CONTEXT\ however we save some processing time by putting
%D an extra \type{\hbox} around the \type{\strutbox}.

\def\definehspace
  {\dodoubleargument\dodefinehspace}

\def\dodefinehspace[#1][#2]%
  {\setvalue{\??hs#1}{#2}}

\unexpanded\def\hspace
  {\dosingleempty\dohspace}

\def\dohspace[#1]%
  {\ifhmode
     \removeunwantedspaces
     \hskip
     \iffirstargument
       \executeifdefined{\??hs#1}{#1}%
     \else
       \getvalue{\??hs\s!default}%
     \fi  
     \expandafter\ignorespaces
   \fi}  

\def\emspaceamount{\fontdimen6\font}
\def\spaceamount  {\fontdimen2\font}

\definehspace [\v!klein]   [.25\emspaceamount]
\definehspace [\v!middel]  [.5\emspaceamount]
\definehspace [\v!groot]   [1\emspaceamount]
\definehspace [\v!normaal] [1\spaceamount] 
\definehspace [\v!default] [\v!groot]

% Very nasty but needed for margin stuff inside colored 
% paragraphs. 

\let\normalvadjust\vadjust

\def\graphicvadjust % bad, those low level color calls here  
  {\dowithnextbox
     {\normalvadjust
        {\dostartgraphicgroup
         \ifx\maintextcolor\empty
           \stopcolormode
           \unvbox\nextbox
         \else
           \startcolormode\maintextcolor
           \unvbox\nextbox
           \stopcolormode
         \fi
         \dostopgraphicgroup}}%
     \vbox}

\stelwitruimtein
  [\v!geen]

\inspringen
  [\v!nooit]

\stelinspringenin
  [\v!geen]

\stelblankoin
  [\v!standaard,
   \v!groot]

\definieerblanko[\v!default] [\currentblanko]
\definieerblanko[\v!voor]    [\v!default]
\definieerblanko[\v!tussen]  [\v!default]
\definieerblanko[\v!na]      [\v!voor]

% doen?

\def\@@blankovoor  {\blanko[\v!voor]}   %
\def\@@blankotussen{\blanko[\v!tussen]} %  scheelt 5 tokens == >20 bytes
\def\@@blankona    {\blanko[\v!na]}     %

\stelinterliniein
  [\c!hoogte=.72,
   \c!diepte=.28,
   \c!boven=1.0,
   \c!onder=0.4,
   \c!afstand=1pt,
   \c!regel=2.8ex,
   \c!rek=0]

\stelsmallerin
  [\c!links=1.5em,
   \c!rechts=1.5em,
   \c!midden=1.5em]

\steltolerantiein
  [\v!horizontaal,\v!zeerstreng]

\steltolerantiein
  [\v!vertikaal,\v!streng]

\steluitlijnenin
  [\v!onder,
   \v!breedte]

\stelspatieringin
  [\v!opelkaar]

\protect \endinput 
