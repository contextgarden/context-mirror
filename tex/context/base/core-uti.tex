%D \module
%D   [       file=core-uti,
%D        version=1997.03.31,
%D          title=\CONTEXT\ Core Macros,
%D       subtitle=Utility File Handling,
%D         author=Hans Hagen,
%D           date=\currentdate,
%D      copyright={PRAGMA / Hans Hagen \& Ton Otten}]
%C
%C This module is part of the \CONTEXT\ macro||package and is
%C therefore copyrighted by \PRAGMA. See mreadme.pdf for 
%C details. 

\writestatus{loading}{Context Core Macros / Utility File Handling}

\unprotect 

% todo : safe lan etc too 
% todo : load all commands at once (tok) 

% Utility-file
%
% De onderstaande macro's ondersteunen het gebruik van de
% zogeheten utility-file. Alle extern onder te brengen
% informatie wordt opgeslagen in de file \jobname.tui, tenzij
% er selectief pagina's worden gezet. In dat geval wordt de
% file \jobname.tmp gebruikt. Informatie wordt ingelezen uit
% de file \jobname.tuo, welke door TeXUtil wordt aangemaakt.

\edef\utilityversion{1998.07.07} % was: 1996.03.15  % status variables
\edef\utilityversion{1998.12.20} % was: 1998.07.07  % index attributes

% Bepaalde commando's worden als string weggeschreven. Deze
% zijn aan het eind van deze file gedefinieerd.

% Om een opbouw van spaties te voorkomen (???) moet ^^M een
% andere betekenis krijgen:
%
% \catcode`\^^M=14 (comment)
%
% read file
%
% \catcode`\^^M=5  (end of line)

\newwrite\uti
\newif\ifutilitydone

\def\@@utilityerrormessage%
  {\showmessage{\m!systems}{8}{}%
   \global\let\@@utilityerrormessage=\relax}

\def\thisisutilityversion#1%
  {\doifnot{\utilityversion}{#1}%
     {\@@utilityerrormessage
      \resetutilities
      \endinput}}

\def\writeutility%
  {\write\uti}

\def\immediatewriteutility%
  {\immediate\write\uti}

\def\writeutilitycommand#1%
  {\write\uti{c \string#1}}

\def\immediatewriteutilitycommand#1%
  {\immediate\write\uti{c \string#1}}

\def\openutilities%
  {\immediate\openout\uti=\jobname.\f!inputextension
   \immediatewriteutilitycommand{\thisisutilityversion{\utilityversion}}}

\def\closeutilities%
  {%\savenofsubpages
   %\savenofpages
   \immediate\closeout\uti
   \reportutilityproblems
   % should be a message : 
   \let\immediatewriteutilitycommand\gobbleoneargument
   \let\immediatewriteutility\gobbleoneargument}

\def\abortutilitygeneration%
  {\immediatewriteutilitycommand{\utilitygenerationaborted}%
   \immediatewriteutility{q {quit}}}

\def\utilitygenerationaborted%
  {\showmessage{\m!systems}{21}{}%
   \global\let\utilitygenerationaborted=\endinput
   \gdef\reportutilityproblems{\showmessage{\m!systems}{22}{}}%
   \endinput}

\def\savecurrentvalue#1#2%
  {\immediatewriteutilitycommand{\initializevariable\string#1{#2}}}

\let\initializevariable\gdef

\def\disableinitializevariables%
  {\global\let\initializevariable\gobbletwoarguments}

\let\reportutilityproblems=\relax

\let\utilityresetlist=\empty

% the original
%
% \def\addutilityreset#1%
%   {\addtocommalist{\s!reset#1}\utilityresetlist}
%
% \def\resetutilities%
%   {\processcommacommand[\utilityresetlist]\getvalue}
%
% the more efficient 
%
% \def\addutilityreset#1%
%   {\addtocommalist{#1}\utilityresetlist}
%
% \def\doresetutility#1%
%   {\getvalue{\s!reset#1}}
%
% \def\resetutilities%
%   {\processcommacommand[\utilityresetlist]\doresetutility}
%
% the fastest, about two times, but who cares, since this 
% can be neglected 

\newtoks\utilityresetlist

\def\addutilityreset#1%
  {\@EA\appendtoks\csname\s!reset#1\endcsname\to\utilityresetlist}

\def\resetutilities%
  {\the\utilityresetlist}

% #1=type
% #2=file
% #3=melding

% #4=voor
% #5=na

% Er wordt gegroepeerd. Als binnen een lijst (bijvoorbeeld) de
% \leftskip is aangepast, maar nog geen \par is gegeven, dan
% geldt buiten de groep de oude \leftskip. Aan #5 kan dan
% ook \par worden meegegeven om de paragraaf af te sluiten.

\newif\ifdoinpututilities
\newif\ifunprotectutilities   % voor't geval er \v!xxxxxx's zijn

% no longer needed, since texutil is now multi platform
%
% \def\utilitycheckmessage%
%   {\showmessage{\m!systems}{12}{}%
%    \global\let\utilitycheckmessage=\relax}
%
% \def\saveutilityline#1 #2\txen% tricky maar ok, want achter \command
%   {\if     #1c% commands      % in \ascii staat een spatie; #1 kan
%      \write\scratchwrite{#2}% % \par in stringvorm zijn (eof)!
%    \else\if#1s% synoniems
%      \utilitycheckmessage
%    \else\if#1r% registers
%      \utilitycheckmessage
%    \fi\fi\fi}
%
% \def\checkutilityfile%
%   {\doiflocfileelse{\jobname.\f!outputextension}
%      {}
%      {\doiflocfileelse{\jobname.\f!inputextension}
%         {\bgroup
%          \showmessage{\m!systems}{11}{}%
%          \openout\scratchwrite=\jobname.\f!outputextension
%          \openlocin\scratchread{\jobname.\f!inputextension}%
%          \def\doprocessline%
%            {\ifeof\scratchread
%               \def\doprocessline{\closein\scratchread}%
%             \else
%               \read\scratchread to \ascii
%               \convertcommand\ascii\to\ascii
%               \expandafter\saveutilityline\ascii\txen
%             \fi
%             \doprocessline}%
%          \doprocessline
%          \closeout\scratchwrite
%          \egroup}
%         {}}}

\def\currentutilityfilename{\jobname}

\long\def\doutilities#1#2#3#4#5% % introduceren in utility file
  {\restorecatcodes
   \resetutilities
  %\message{#1}%
   \def\docommando##1%                 % more than one utility thing
     {\csname\s!set##1\endcsname}%     % can be handled in one pass, 
   \processcommacommand[#1]\docommando % for instance lists 
   \begingroup
   \def\currentutilityfilename{#2}%
   \footnotesenabledfalse
   \doinpututilitiestrue
   \global\utilitydonefalse
   \catcode`\\=\@@escape
   \catcode`\{=\@@begingroup
   \catcode`\}=\@@endgroup
   \catcode`\%=\@@comment\relax
   \pushendofline % geeft problemen zodra andere file wordt ingelezen
   \ifunprotectutilities % nog nodig ?
     \unprotect
   \fi
   \ifnum\catcode`\@=\@@active \else
     \catcode`\@=\@@letter % permits expanded commands with \@'s
   \fi
   \ifnum\catcode`\!=\@@active \else
     \catcode`\!=\@@letter % permits multilingual constants
   \fi
   #4%
   \the\everybeforeutilityread
   \readjobfile{#2.\f!outputextension}{}{}%
   \the\everyafterutilityread
   #5%
   \relax
   \ifunprotectutilities
     \protect
   \fi
   \popendofline
   \ifutilitydone\else
     \doifsomething{#3}
       {\showmessage{\m!systems}{9}{{#3}}%
        \ifvoorlopig
          \blanko
          \type{[\currentmessagetext]}%
          \blanko
        \fi}%
   \fi
   \disableinitializevariables
   \endgroup}

% Saving the sort vector: 

\def\savesortkeys%
  {\setbox\scratchbox=\hbox
     \bgroup
       \def\flushsortkey##1##2##3##4%
         {\convertargument{##1}{##2}{##3}{##4}\to\ascii
          \immediatewriteutility{k {\currentlanguage}{\currentencoding}\ascii}}%
       \let\definesortkey\flushsortkey
       \flushsortkeys
     \egroup
   \global\let\savesortkeys\relax}

\prependtoks \savesortkeys \to \everystarttext 

% Commando's ten behoeve van two-pass lists. In principe
% kan alles in een keer worden ingelezen. Omdat de macro's
% groeien is de kans groot dat het (main) geheugen door
% (de)allocatie volloopt. Vandaar dat we het toch maar niet
% doen.
%
% \definetwopasslist{\s!xxx}
%
% \gettwopassdata{\s!xxx}
% \getfrompassdata{\s!xxx}{n}       n=index (getal)
% \findtwopassdata{\s!xxx}{tag}     bijvoorbeeld {label:}
% \iftwopassdatafound
% \twopassdata
%
% \twopassentry{\s!xxx}{nr}{data}   nr alleen voor testdoeleinden
%
% also: 
%
% \definerawpasslist{\s!xxx}       
% \moverawpasslist\s!xxx\to\somemacro 

\let\alltwopasslists\empty % with    0,0 -> stepwise commalist
\let\allrawpasslists\empty % without 0,0 -> raw commalist 

\newif\iftwopassdatafound

\def\twopassentry#1%
  {\executeifdefined{@@#1\s!pass}\gobbletwoarguments}

%\def\appendtwopasselement#1#2#3%
%  {%\debuggerinfo{\m!systems}{twopass data #1 - #2 = #3}%
%   \@EA\ifx\csname#1:\s!list\endcsname\empty
%     \setxvalue{#1:\s!list}{#3}%
%   \else
%     \setxvalue{#1:\s!list}{\getvalue{#1:\s!list},#3}%
%   \fi}

\def\appendtwopasselement#1#2#3% can sometimes become a large list
  {%\debuggerinfo{\m!systems}{twopass data #1 - #2 = #3}%
   \expandafter\xdef\csname#1:\s!list\endcsname
     {\@EA\ifx\csname#1:\s!list\endcsname\empty \else
        \csname#1:\s!list\endcsname,\fi#3}}

%\def\dodefinetwopasslist#1%
%  {\doifundefined{#1:\s!list}
%     {%\debuggerinfo{\m!systems}{defining twopass class #1}%
%      \doglobal\addutilityreset{#1\s!pass}%
%      \setgvalue{\s!set#1\s!pass}%
%        {\global\letvalue{\s!set#1\s!pass}\gobbletwoarguments
%         \setgvalue{@@#1\s!pass}{\appendtwopasselement{#1}}}%
%      \setgvalue{\s!reset#1\s!pass}%
%        {\global\letvalue{@@#1\s!pass}\gobbletwoarguments}%
%      \getvalue{\s!reset#1\s!pass}}}

\def\dodefinetwopasslist#1%
  {\doifundefined{#1:\s!list}
     {%\debuggerinfo{\m!systems}{defining twopass class #1}%
      \doglobal\addutilityreset{#1\s!pass}%
      \setgvalue{\s!set  #1\s!pass}{\dosettwopasslist  {#1}}%
      \setgvalue{\s!reset#1\s!pass}{\doresettwopasslist{#1}}%
      \getvalue {\s!reset#1\s!pass}}}

\def\dosettwopasslist#1%
  {\global\letvalue{\s!set#1\s!pass}\gobbletwoarguments
   \setgvalue{@@#1\s!pass}{\appendtwopasselement{#1}}}

\def\doresettwopasslist#1%
  {\global\letvalue{@@#1\s!pass}\gobbletwoarguments}

\def\definetwopasslist#1%
  {\expanded{\dodefinetwopasslist{#1}}%
   \doglobal\addtocommalist{#1}\alltwopasslists}

\def\definerawpasslist#1%
  {\expanded{\dodefinetwopasslist{#1}}%
   \doglobal\addtocommalist{#1}\allrawpasslists}

\def\doloadtwopassdata#1%
  {\doifundefined{#1:\s!list}
     {\global\letvalue{#1:\s!list}\empty
      \doutilities{#1\s!pass}{\jobname}{}{}{}%
      \ifx\twopassdata\empty\else
        \appendtwopasselement{#1}{0}\twopassdata
      \fi}}

\def\loadtwopassdata%
  {\ifx\alltwopasslists\empty\else
     \def\twopassdata{0,0}% end condition 
     \processcommacommand[\alltwopasslists]\doloadtwopassdata
     \global\let\alltwopassdata\empty
   \fi
   \ifx\allrawpasslists\empty\else
     \let\twopassdata\empty
     \processcommacommand[\allrawpasslists]\doloadtwopassdata
     \global\let\allrawpassdata\empty
   \fi}

\def\moverawpasslist#1#2% erases the old one, like the others do
  {\loadtwopassdata
   \@EA\let\@EA#2\csname#1:\s!list\endcsname
   \@EA\let\csname#1:\s!list\endcsname\empty}

\let\twopassdata=\empty

%\def\dogettwopassdata[#1,#2]#3%
%  {\doifelse{#1}{0} % \ifcase truukje gaat fout
%     {\twopassdatafoundfalse
%      \let\twopassdata\empty}
%     {\twopassdatafoundtrue
%      \setxvalue{#3:\s!list}{#2}%
%      \edef\twopassdata{#1}}}

\def\notwopassdata{0}

% \def\dogettwopassdata[#1,#2]#3%
%   {\edef\twopassdata{#1}%
%    \ifx\twopassdata\notwopassdata
%      \twopassdatafoundfalse
%      \let\twopassdata\empty
%    \else   
%      \twopassdatafoundtrue
%      \setxvalue{#3:\s!list}{#2}%
%    \fi}
% 
% \def\gettwopassdata#1%
%   {\loadtwopassdata
%   %\edef\!!stringa{\csname#1:\s!list\endcsname}%
%   %\debuggerinfo{\m!systems}{twopass get #1 - \!!stringa}%
%   %\expandafter\dogettwopassdata\expandafter[\!!stringa]{#1}}
%    \expanded{\dogettwopassdata[\csname#1:\s!list\endcsname]}{#1}}
% 
% \def\findtwopassdata#1#2%
%   {\loadtwopassdata
%    \expanded{\dofindtwopassdata{#1}{#2}}}
% 
% \def\dofindtwopassdata#1#2%
%   {\edef\!!stringa{,\csname#1:\s!list\endcsname}%
%   %\debuggerinfo{\m!systems}{twopass find #2 - \!!stringa}%
%    \def\dodofindtwopassdata[##1,##2#2##3,##4]%
%      {\edef\twopassdata{##3}%
%       \ifx\twopassdata\empty
%         \twopassdatafoundfalse
%       \else
%         \twopassdatafoundtrue
%       \fi}%
%    \@EA\dodofindtwopassdata\@EA[\!!stringa,#2,#2,]}
%
% \def\getfirsttwopassdata#1%
%   {\loadtwopassdata
%    \edef\!!stringa{\getvalue{#1:\s!list}}%
%    \expandafter\dogetfirsttwopassdata\expandafter[\!!stringa]{#1}}
% 
% \def\dogetfirsttwopassdata[#1,#2]#3%
%   {\doifelse{#1}{0}
%      {\twopassdatafoundfalse
%       \let\twopassdata\empty}
%      {\twopassdatafoundtrue
%       \edef\twopassdata{#1}}}
% 
% \def\getlasttwopassdata#1%
%   {\loadtwopassdata
%    \edef\twopassdata{0}\twopassdatafoundfalse
%    \newcounter\noftwopassitems
%    \def\docommando##1%
%      {\doifnot{##1}{0}
%         {\increment\noftwopassitems
%          \edef\twopassdata{##1}\twopassdatafoundtrue}}%
%    \processcommacommand[\getvalue{#1:\s!list}]\docommando}
% 
% \def\getfromtwopassdata#1#2%
%   {\loadtwopassdata
%    \getfromcommacommand[\csname#1:\s!list\endcsname][#2]%
%    \doifelsenothing{\commalistelement}
%      {\twopassdatafoundfalse
%       \let\twopassdata\empty}
%      {\twopassdatafoundtrue
%       \let\twopassdata\commalistelement}}

% todo: store each entry in hash, an load all uti commands at once

\def\dogettwopassdata[#1,#2]#3%
  {\edef\twopassdata{#1}%
   \ifx\twopassdata\notwopassdata
     \twopassdatafoundfalse
     \let\twopassdata\empty
   \else
     \twopassdatafoundtrue
     \setxvalue{#3:\s!list}{#2}%
   \fi}

\def\gettwopassdata#1%
  {\loadtwopassdata
   \@EAEAEA\dogettwopassdata\@EA\@EA\@EA[\csname#1:\s!list\endcsname]{#1}}

\def\findtwopassdata#1#2%
  {\loadtwopassdata
   \expanded{\dofindtwopassdata{#1}{#2}}}

\def\dofindtwopassdata#1#2%
  {\def\dodofindtwopassdata[##1,##2#2##3,##4]{\edef\twopassdata{##3}}%
   \@EAEAEA\dodofindtwopassdata\@EA\@EA\@EA[\@EA\@EA\@EA,\csname#1:\s!list\endcsname,#2,#2,]%
   \ifx\twopassdata\empty
     \twopassdatafoundfalse
   \else
     \twopassdatafoundtrue
   \fi}

\def\getfirsttwopassdata#1%
  {\loadtwopassdata
   \@EAEAEA\dogetfirsttwopassdata\@EA\@EA\@EA[\csname#1:\s!list\endcsname]{#1}}

\def\dogetfirsttwopassdata[#1,#2]#3%
  {\edef\twopassdata{#1}%
   \ifx\twopassdata\notwopassdata
     \twopassdatafoundfalse
     \let\twopassdata\empty
   \else
     \twopassdatafoundtrue
   \fi}

\def\dogetlasttwopassdata#1%
  {\edef\nexttwopassdata{#1}%
   \ifx\nexttwopassdata\notwopassdata \else
     \let\twopassdata\nexttwopassdata
     \advance\scratchcounter 1
     \twopassdatafoundtrue
   \fi}

\def\getlasttwopassdata#1%
  {\loadtwopassdata
   \scratchcounter0
   \@EAEAEA\rawprocesscommalist\@EA\@EA\@EA[\csname#1:\s!list\endcsname]\dogetlasttwopassdata
   \edef\noftwopassitems{\the\scratchcounter}%
   \iftwopassdatafound\else
     \let\twopassdata\empty
   \fi}

\def\getfromtwopassdata#1#2%
  {\loadtwopassdata
   \@EAEAEA\getfromcommalist\@EA\@EA\@EA[\csname#1:\s!list\endcsname][#2]%
   \ifx\commalistelement\empty
     \twopassdatafoundfalse
     \let\twopassdata\empty
   \else
     \twopassdatafoundtrue
     \let\twopassdata\commalistelement
   \fi}

% Default-instellingen (verborgen)

\prependtoks \resetutilities \to \everyjob 

% left over 

\def\plaatsvolledig#1#2#3#4%   kop, ref, tit, do
  {#1[#2]{#3}#4\pagina[\v!ja]}

% Experiment 
%
%\installprogram{Hello World}

\def\installprogram#1%
  {\immediatewriteutility{e p {#1}}}

% \writeplugindata{texutil}{{alpha}}
% \writeplugindata{texutil}{{beta}}
% \writeplugindata{texutil}{{gamma}}
% \writeplugindata{texutil}{{delta}}
% 
% \loadplugindata {plugintest}
 
\def\immediatewriteplugindata#1#2%
  {\immediatewriteutility{p u {#1} #2}}

\def\writeplugindata#1#2%
  {\writeutility{p u {#1} #2}}

\def\loadplugindata#1%
  {\doutilities{#1}{\jobname}{}{}{}{}}

% \plugincommand{\command{}{}{}}
%
% this way we can catch undefined commands 

\long\def\plugincommand#1%
  {\doplugincommand#1\relax}

\long\def\doplugincommand#1%
  {\ifx#1\undefined
     \expandafter\noplugincommand
   \else
     \expandafter#1%
   \fi}

\long\def\noplugincommand#1\relax
  {}

% \addutilityreset{plugintest}
% 
% \def\resetplugintest{\let\plugintest\gobbletwoarguments}
% \def\setplugintest  {\let\plugintest\writestatus}
% 
% \installplugin
%   {plugintest}
%   {\let\plugintest\gobbletwoarguments}
%   {\let\plugintest\writestatus}

\long\def\installplugin#1#2#3%
  {\addutilityreset          {#1}%
   \long\setvalue{\s!reset#1}{#2}%
   \long\setvalue{\s!set  #1}{#3}}

\protect \endinput 
