%D \module
%D   [       file=luat-ini,
%D        version=2005.08.11,
%D          title=\CONTEXT\ Lua Macros,
%D       subtitle=Initialization,
%D         author=Hans Hagen,
%D           date=\currentdate,
%D      copyright={PRAGMA ADE \& \CONTEXT\ Development Team}]
%C
%C This module is part of the \CONTEXT\ macro||package and is
%C therefore copyrighted by \PRAGMA. See mreadme.pdf for
%C details.

\writestatus{loading}{ConTeXt Lua Macros / Initialization}

\unprotect

%D Loading lua code can be done using \type {startup.lua}. The following
%D method uses the \TEX\ input file locator of kpse. At least we need to
%D use that way of loading when we haven't yet define our own code, which
%D we keep outside the format. We will keep code outside \TEX\ files as
%D much as possible.

\ifdefined\setnaturalcatcodes \else \let\setnaturalcatcodes\relax \fi
\ifdefined\obeylualines       \else \let\obeylualines      \relax \fi
\ifdefined\obeyluatokens      \else \let\obeyluatokens     \relax \fi

%D A few more goodies:

\unexpanded\def\startlua    {\system_start_lua     } \let\stoplua    \relax % tex catcodes
\unexpanded\def\startluacode{\system_start_lua_code} \let\stopluacode\relax % lua catcodes

% It might makes sense to have a \type {\directelua} so that we can avoid
% the \type {\normalexpanded} around \type {\directlua}. Something to discuss
% in the team.

\def\system_start_lua
  {\begingroup
   \obeylualines
   \system_start_lua_indeed}

\def\system_start_lua_indeed#1\stoplua
  {\normalexpanded{\endgroup\noexpand\directlua\zerocount{#1}}}

\def\system_start_lua_code
  {\begingroup
   \obeylualines
   \obeyluatokens
   \system_start_lua_code_indeed}

\def\system_start_lua_code_indeed#1\stopluacode
  {\normalexpanded{\endgroup\noexpand\directlua\zerocount{#1}}}

%D Some delayed definitions:

\ifdefined\obeylines   \else \let\obeylines   \relax \fi
\ifdefined\obeyedline  \else \let\obeyedline  \relax \fi
\ifdefined\obeyspaces  \else \let\obeyspaces  \relax \fi
\ifdefined\obeyedspace \else \let\obeyedspace \relax \fi

\let\obeylualines\relax

\newtoks\everyluacode

\edef\lualetterbackslash{\string\\}
\edef\lualetterbar      {\string\|} \edef\lualetterdash     {\string\-}
\edef\lualetterlparent  {\string\(} \edef\lualetterrparent  {\string\)}
\edef\lualetterlbrace   {\string\{} \edef\lualetterrbrace   {\string\}}
\edef\lualettersquote   {\string\'} \edef\lualetterdquote   {\string\"}
\edef\lualettern        {\string\n} \edef\lualetterr        {\string\r}
\edef\lualetterf        {\string\f} \edef\lualettert        {\string\t}
\edef\lualettera        {\string\a} \edef\lualetterb        {\string\b}
\edef\lualetterv        {\string\v} \edef\lualetters        {\string\s}
\edef\lualetterone      {\string\1} \edef\lualettertwo      {\string\2}
\edef\lualetterthree    {\string\3} \edef\lualetterfour     {\string\4}
\edef\lualetterfive     {\string\5} \edef\lualettersix      {\string\6}
\edef\lualetterseven    {\string\7} \edef\lualettereight    {\string\8}
\edef\lualetternine     {\string\9} \edef\lualetterzero     {\string\0}

\appendtoks
   \let\\\lualetterbackslash
   \let\|\lualetterbar       \let\-\lualetterdash
   \let\(\lualetterlparent   \let\)\lualetterrparent
   \let\{\lualetterlbrace    \let\}\lualetterrbrace
   \let\'\lualettersquote    \let\"\lualetterdquote
   \let\n\lualettern         \let\r\lualetterr
   \let\f\lualetterf         \let\t\lualettert
   \let\a\lualettera         \let\b\lualetterb
   \let\v\lualetterv         \let\s\lualetters
   \let\1\lualetterone       \let\2\lualettertwo
   \let\3\lualetterthree     \let\4\lualetterfour
   \let\5\lualetterfive      \let\6\lualettersix
   \let\7\lualetterseven     \let\8\lualettereight
   \let\9\lualetternine      \let\0\lualetterzero
\to \everyluacode

\def\obeyluatokens
  {\setcatcodetable\luacatcodes
   \the\everyluacode}

%D \macros
%D   {definenamedlua}
%D
%D We provide an interface for defining instances:

\def\s!lua{lua} \def\v!code{code} \def\!!name{name} \def\s!data{data}

%D Beware: because \type {\expanded} is een convert command, the error
%D message will show \type{<inserted text>} as part of the message.

\def\system_start_named_lua_code#1%
  {\begingroup
   \obeylualines
   \obeyluatokens
   \csname\??lu:c:#1\endcsname}

\unexpanded\def\definenamedlua[#1]#2[#3]% no optional arg handling here yet
  {\ifcsname\??lu:c:#1\endcsname \else
     \scratchcounter\ctxlua{lua.registername("#1","#3")}%
     \normalexpanded{\edef\csname\??lu:c:#1\endcsname##1\csname\e!stop#1\v!code\endcsname}%
       {\endgroup\noexpand\directlua\the\scratchcounter{protect("#1\s!data")##1}}%
     \expandafter\def \csname\e!start#1\v!code\endcsname   {\system_start_named_lua_code{#1}}%
     \expandafter\edef\csname        #1\v!code\endcsname##1{\noexpand\directlua\the\scratchcounter{protect("#1\s!data")##1}}%
   \fi}

%D We predefine a few.

% \definenamedlua[module][module instance] % not needed

\definenamedlua[user]    [private user instance]
\definenamedlua[third]   [third party module instance]
\definenamedlua[isolated][isolated instance]

%D In practice this works out as follows:
%D
%D \startbuffer
%D \startluacode
%D context("LUA")
%D \stopluacode
%D
%D \startusercode
%D global.context("USER 1")
%D context("USER 2")
%D if characters then
%D     context("ACCESS")
%D else
%D     context("NO ACCESS")
%D end
%D \stopusercode
%D \stopbuffer
%D
%D \typebuffer

%D We need a way to pass strings safely to \LUA\ without the
%D need for tricky escaping. Compare:
%D
%D \starttyping
%D \ctxlua {something("anything tricky can go here")}
%D \ctxlua {something([\luastringsep[anything tricky can go here]\luastringsep])}
%D \stoptyping

\def\luastringsep{===} % this permits \typefile{self} otherwise nested b/e sep problems

\edef\!!bs{[\luastringsep[}
\edef\!!es{]\luastringsep]}

%D We have a the following available as primitive so there is no need
%D for it:
%D
%D \starttyping
%D \long\edef\luaescapestring#1{\!!bs#1\!!es}
%D \stoptyping

\def\setdocumentfilename       #1#2{\ctxlua{document.setfilename(#1,"#2")}}
\def\setdocumentargument       #1#2{\ctxlua{document.setargument("#1","#2")}}
\def\setdocumentargumentdefault#1#2{\ctxlua{document.setdefaultargument("#1","#2")}}
\def\getdocumentfilename         #1{\ctxlua{document.getfilename("#1")}}
\def\getdocumentargument         #1{\ctxlua{document.getargument("#1")}}
\def\getdocumentargumentdefault#1#2{\ctxlua{document.getargument("#1","#2")}}
\def\doifdocumentargumentelse    #1{\doifsomethingelse{\getdocumentargument{#1}}}
\def\doifdocumentargument        #1{\doifsomething    {\getdocumentargument{#1}}}
\def\doifnotdocumentargument     #1{\doifnothing      {\getdocumentargument{#1}}}
\def\doifdocumentfilenameelse    #1{\doifsomethingelse{\getdocumentfilename{#1}}}
\def\doifdocumentfilename        #1{\doifsomething    {\getdocumentfilename{#1}}}
\def\doifnotdocumentfilename     #1{\doifnothing      {\getdocumentfilename{#1}}}

\let\doifelsedocumentargument\doifdocumentargumentelse

%D A handy helper:

\def\luaexpanded#1{\luaescapestring\expandafter{\normalexpanded{#1}}}

%D Experimental:

\unexpanded\def\startluaparameterset[#1]%
  {\begingroup
   \obeylualines
   \obeyluatokens
   \system_start_lua_parameter_set{#1}}

\def\system_start_lua_parameter_set#1#2\stopluaparameterset
  {\ctxlua{parametersets["#1"]={#2}}%
   \endgroup}

\let\stopluaparameterset\relax

\def\luaparameterset#1#2{\ctxlua{parametersets["#1"]={#2} context("#1")}}

% todo: \mergeparameterset

% usage:
%
% \startluaparameterset [u3d:myset:display:1]
%     toolbar=false,
%     tree=true
% \stopluaparameterset
%
% option=u3d:myset:display:1
%
% or:
%
% option=\luaparameterset{u3d:myset:display:1}{toolbar=false,tree=true}

%D A Handy helper:

\def\luaconditional#1{\ifcase#1tru\else fals\fi e}

%D Goodie:
%D
%D \starttyping
%D \ctxluacode{context("%0.5f",1/3)}
%D \stoptyping

\unexpanded\def\ctxluacode
  {\begingroup
   \obeylualines
   \obeyluatokens
   \catcode\leftbraceasciicode \plusone
   \catcode\rightbraceasciicode\plustwo
   \afterassignment\system_lua_code
   \scratchtoks=}

% Hm, are we sure that the \* commands work out okay here? We could probably
% use \setcatcodetable\luacatcodes instead of \obeyluatokens now.

\def\system_lua_code
  {\normalexpanded{\endgroup\noexpand\directlua\zerocount\expandafter{\the\scratchtoks}}}

\protect \endinput
