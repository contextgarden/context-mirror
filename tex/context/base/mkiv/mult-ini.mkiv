%D \module
%D   [       file=mult-ini,
%D        version=2008.10.22, % 1996.06.01,
%D          title=\CONTEXT\ Multilingual Macros,
%D       subtitle=Initialization,
%D         author=Hans Hagen,
%D           date=\currentdate,
%D      copyright={PRAGMA ADE \& \CONTEXT\ Development Team}]
%C
%C This module is part of the \CONTEXT\ macro||package and is
%C therefore copyrighted by \PRAGMA. See mreadme.pdf for
%C details.

%D This module is a stripped down version of \type {mult-ini.tex},
%D which we keep around as \type {mult-kep.tex} for sentimental
%D reasons. There you will find some more historic information.

\writestatus{loading}{ConTeXt Multilingual Macros / Initialization}

\unprotect

\registerctxluafile{mult-ini}{1.001}

%D \macros
%D   [constanten,variabelen,commands]
%D   {v!,c!,k!,s!,e!,m!,l!,r!,f!,p!,x!,y!}
%D
%D In the system modules we introduced some prefixed constants,
%D variables (both macros) and registers. Apart from a
%D tremendous saving in terms of memory and a gain in speed we
%D use from now on prefixes when possible for just another
%D reason: consistency and multi||linguality. Systematically
%D using prefixed macros enables us to implement a
%D multi||lingual user interface. Redefining these next set of
%D prefixes therefore can have desastrous results.
%D
%D \startlinecorrection
%D \starttable[|c|c|c|]
%D \HL
%D \NC \bf prefix        \NC \bf meaning \NC \bf application     \NC\SR
%D \HL
%D \NC \type{\c!prefix!} \NC  c!         \NC constant (direct)   \NC\FR
%D \NC \type{\k!prefix!} \NC  k!         \NC constant (indirect) \NC\FR
%D \NC \type{\e!prefix!} \NC  e!         \NC element             \NC\MR
%D \NC \type{\f!prefix!} \NC  f!         \NC file                \NC\MR
%D \NC \type{\m!prefix!} \NC  m!         \NC age                 \NC\MR
%D \NC \type{\s!prefix!} \NC  s!         \NC system              \NC\MR
%D \NC \type{\v!prefix!} \NC  v!         \NC variable            \NC\MR
%D \HL
%D \stoptable
%D \stoplinecorrection
%D
%D In the single||lingual version we used \type{!}, \type{!!},
%D \type{!!!} and \type{!!!!}. In the meantime some of these
%D are obsolete (we had some 12 originally).

\def\c!prefix!{c!}
\def\k!prefix!{k!}
\def\e!prefix!{e!}
\def\f!prefix!{f!} % for the moment we keep this one
\def\m!prefix!{m!}
\def\s!prefix!{s!}
\def\v!prefix!{v!}

%D \macros
%D   [constants,variables,commands]
%D   {@@,??}
%D
%D Variables generated by the system can be recognized on their
%D prefix \type{@@}. They are composed of a command (class)
%D specific tag, which can be recognized on \type{??}, and a
%D system constant, which has the prefix \type{c!}. We'll se
%D some more of this.

\def\??prefix  {??}
\def\@@prefix  {@@}

%D Just to be complete we repeat some of the already defined
%D system constants here. Maybe their prefix \type{\s!} now
%D falls into place.

\def\s!next    {next}         \def\s!default {default}
\def\s!dummy   {dummy}        \def\s!unknown {unknown}

\def\s!do      {do}           \def\s!dodo    {dodo}

\def\s!complex {complex}      \def\s!start   {start}
\def\s!simple  {simple}       \def\s!stop    {stop}

\def\s!true    {true}
\def\s!false   {false}

%D The word \type{height} takes 6~token memory cells. The
%D control sequence \type{\height} on the other hand uses only
%D one. Knowing this, we can improve the performance of \TEX,
%D both is terms of speed and memory usage, by using control
%D sequences instead of the words written in full.
%D
%D Where in the \ASCII\ file the second lines takes nine extra
%D characters, \TEX\ saves us 13~tokens.
%D
%D \starttyping
%D \hrule width 10pt height 2pt depth 1pt
%D \hrule \s!width 10pt \s!height 2pt \s!depth 1pt
%D \stoptyping
%D
%D One condition is that we have defined \type {\s!height},
%D \type {\s!width} and \type {\s!depth} as respectively
%D \type {height}, \type {width} and \type {depth}. Using this
%D scheme therefore only makes sense when a token sequence is
%D used more than once. Savings like this should of course be
%D implemented in english, just because \TEX\ is english.

\def\s!width {width}      \let\!!width \s!width  % obsolete
\def\s!height{height}     \let\!!height\s!height % obsolete
\def\s!depth {depth}      \let\!!depth \s!depth  % obsolete
\def\s!spread{spread}     \let\!!spread\s!spread % obsolete
\def\s!plus  {plus}       \let\!!plus  \s!plus   % obsolete
\def\s!minus {minus}      \let\!!minus \s!minus  % obsolete
\def\s!fil   {fil}
\def\s!fill  {fill}       \let\!!fill  \s!fill   % obsolete
\def\s!filll {filll}
\def\s!to    {to}         \let\!!to    \s!to     % obsolete
\def\s!attr  {attr}

\def\s!bottom{bottom}
\def\s!top   {top}
\def\s!both  {both}

%D Kind of special:

\edef\!!TLT{\detokenize{TLT}}
\edef\!!TRT{\detokenize{TRT}}

%D \macros
%D   {defineinterfaceconstant,
%D    defineinterfacevariable,
%D    defineinterfaceelement,
%D    definesystemvariable,
%D    definesystemconstant,
%D    definemessageconstant,
%D    definefileconstant}
%D
%D The first part of this module is dedicated to dealing with
%D multi||lingual constants and variables. When \CONTEXT\ grew
%D bigger and bigger in terms of bytes and used string space,
%D we switched to predefined constants. At the cost of more
%D hash table entries, the macros not only becase more compact,
%D they became much faster too. Maybe an even bigger advantage
%D was that mispelling could no longer lead to problems. Even a
%D multi||lingual interface became possible.
%D
%D Constants --- we'll introduce the concept of variables later
%D on --- are preceded by a type specific prefix, followed by a
%D \type{!}. To force consistency, we provide a few commands
%D for defining such constants.
%D
%D \starttyping
%D \defineinterfaceconstant {name} {meaning}
%D \defineinterfacevariable {name} {meaning}
%D \defineinterfaceelement  {name} {meaning}
%D \stoptyping
%D
%D Which is the same as:
%D
%D \starttyping
%D \def\c!name{meaning}
%D \def\v!name{meaning}
%D \def\e!name{meaning}
%D \stoptyping

\unexpanded\def\defineinterfaceconstant #1#2{\expandafter\def\csname\c!prefix!#1\endcsname{#2}}
\unexpanded\def\defineinterfacevariable #1#2{\expandafter\def\csname\v!prefix!#1\endcsname{#2}}
\unexpanded\def\defineinterfaceelement  #1#2{\expandafter\def\csname\e!prefix!#1\endcsname{#2}}

%D Next come some interface independant constants:
%D
%D \starttyping
%D \definefileconstant      {name} {meaning}
%D \stoptyping

\unexpanded\def\definefileconstant      #1#2{\expandafter\def\csname\f!prefix!#1\endcsname{#2}}

%D And finaly we have the one argument, space saving constants
%D
%D \starttyping
%D \definesystemconstant  {name}
%D \definemessageconstant {name}
%D \stoptyping

\unexpanded\def\definesystemconstant  #1{\expandafter\def\csname\s!prefix!#1\endcsname{#1}}
\unexpanded\def\definemessageconstant #1{\expandafter\def\csname\m!prefix!#1\endcsname{#1}}

%D In a parameter driven system, some parameters are shared
%D by more system components. In \CONTEXT\ we can distinguish
%D parameters by a unique prefix. Such a prefix is defined
%D with:
%D
%D \starttyping
%D \definesystemvariable {name}
%D \stoptyping

\unexpanded\def\definesystemvariable#1{\expandafter\edef\csname\??prefix#1\endcsname{\@@prefix#1}}

\definesystemvariable{ms}

%D \macros
%D   {selectinterface,
%D    defaultinterface, currentinterface, currentresponses}
%D
%D With \type{\selectinterface} we specify the language we are
%D going to use. The system asks for the language wanted, and
%D defaults to \type{\currentinterface} when we just give
%D \type{enter}. By default the message system uses the
%D current interface language, but \type{\currentresponses}
%D can specify another language too.
%D
%D Because we want to generate formats directly too, we do
%D not ask for interface specifications when these are already
%D defined (like in cont-nl.tex and alike).

\ifdefined\defaultinterface

  \def\selectinterface
    {\writestatus{interface}{defining \currentinterface\space interface}%
     \writeline
     \writestatus{interface}{using    \currentresponses\space messages}%
     \writeline
     \let\selectinterface\relax}

\else

  \def\defaultinterface{english}

  \def\selectinterface
    {\def\selectinterface##1##2%
       {\bgroup
        \endlinechar\minusone
        \global\read16 to ##1
        \egroup
        \doifnothing\currentinterface{\let##1=##2}%
        \doifundefined{\s!prefix!##1}{\let##1=##2}}%
     \selectinterface\currentinterface\defaultinterface
     \writestatus{interface}{defining \currentinterface\space interface}%
     \writeline
     \selectinterface\currentresponses\currentinterface
     \writestatus{interface}{using \currentresponses\space messages}%
     \writeline
     \let\selectinterface\relax}

\fi

\ifdefined\currentinterface \else \let\currentinterface\defaultinterface \fi
\ifdefined\currentresponses \else \let\currentresponses\defaultinterface \fi

%D \macros
%D   {startinterface}
%D
%D Sometimes we want to define things only for specific
%D interface languages. This can be done by means of the
%D selector:
%D
%D \starttyping
%D \startinterface language
%D
%D language specific definitions & commands
%D
%D \stopinterface
%D \stoptyping

\unexpanded\def\startinterface #1
  {\doifnot{#1}{all}{\doifnotinset\currentinterface{#1}{\gobbleuntil\stopinterface}}}

\let\stopinterface\relax

%D \macros
%D   {startmessages,
%D    getmessage,
%D    showmessage,
%D    makemessage}
%D
%D A package as large as \CONTEXT\ can hardly function without
%D a decent message mechanism. Due to its multi||lingual
%D interface, the message subsystem has to be multi||lingual
%D too. A major drawback of this feature is that we have to
%D code messages. As a result, the source becomes less self
%D documented. On the other hand, consistency will improve.
%D
%D Because the overhead in terms of entries in the (already
%D exhausted) hash table has to be minimal, messages are packed
%D in libraries. We can extract a message from such a library
%D in three ways:
%D
%D \starttyping
%D \getmessage  {library} {tag}
%D \showmessage {library} {tag} {data}
%D \makemessage {library} {tag} {data}
%D \stoptyping
%D
%D The first command gets the message \type{tag} from the
%D \type{library} specified. The other commands take an extra
%D argument: a list of items to be inserted in the message
%D text. While \type{\showmessage} shows the message at the
%D terminal, the other commands generate the message as text.
%D Before we explain the \type{data} argument, we give an
%D example of a library.
%D
%D \starttyping
%D \startmessages  english  library: alfa
%D   title: something
%D       1: first message
%D       2: second (--) message --
%D \stopmessages
%D \stoptyping
%D
%D The first message is a simple one and can be shown with:
%D
%D \starttyping
%D \showmessage {alfa} {1} {}
%D \stoptyping
%D
%D The second message on the other hand needs some extra data:
%D
%D \starttyping
%D \showmessage {alfa} {2} {and last,to you}
%D \stoptyping
%D
%D This message is shown as:
%D
%D \starttyping
%D something : second (and last) message to you
%D \stoptyping
%D
%D As we can see, the title entry is shown with the message.
%D The data fields are comma separated and are specified in the
%D message text by \type{--}.
%D
%D It is not required to define all messages in a library at
%D once. We can add messages to a library in the following way:
%D
%D \starttyping
%D \startmessages  english  library: alfa
%D      10: tenth message
%D \stopmessages
%D \stoptyping
%D
%D Because such definitions can take place in different
%D modules, the system gives a warning when a tag occurs more
%D than once. The first occurrence takes preference over later
%D ones, so we had better use a save offset, as shown in the
%D example. As we can see, the title field is specified only
%D the first time!
%D
%D Because we want to check for duplicate tags, the macros
%D are a bit more complicated than neccessary. The \NEWLINE\
%D token is used as message separator.
%D
%D For internal purposes one can use \type {\setmessagetext},
%D which puts the message text asked for in \type
%D {\currentmessagetext}.

%D These will become obsolete:

\unexpanded\def\startmessages #1 library: #2 %
  {\bgroup
   \ifcsname\m!prefix!#2\endcsname\else\setgvalue{\m!prefix!#2}{#2}\fi
   \catcode\endoflineasciicode\activecatcode
   \doifelseinset{#1}{\currentresponses,all}\mult_messages_start_yes\mult_messages_start_nop{#2}}

\def\mult_messages_start_yes#1#2\stopmessages
  {\clf_setinterfacemessages{#1}{#2}%
   \egroup}

\def\mult_messages_start_nop#1#2\stopmessages
  {\egroup}

\let\stopmessages\relax

\unexpanded\def\setinterfacemessage#1#2#3%
  {\ifcsname\m!prefix!#1\endcsname\else\setgvalue{\m!prefix!#1}{#1}\fi
   \clf_setinterfacemessage{#1}{#2}{#3}}

\unexpanded\def\setmessagetext   #1#2{\edef\currentmessagetext{\clf_getmessage{#1}{#2}}}
\unexpanded\def\getmessage       #1#2{\clf_getmessage{#1}{#2}}
\unexpanded\def\doifelsemessage  #1#2{\clf_doifelsemessage{#1}{#2}}
\unexpanded\def\showmessage    #1#2#3{\clf_showmessage{#1}{#2}{#3}}
\unexpanded\def\writestatus      #1#2{\clf_writestatus{#1}{#2}}
\unexpanded\def\message              {\clf_message}

\let\doifmessageelse\doifelsemessage

%D \macros
%D   {ifshowwarnings, ifshowmessages}
%D
%D Sometimes displaying message can slow down processing
%D considerably. We therefore introduce warnings. Users can
%D turn of warnings and messages by saying:
%D
%D \starttyping
%D \showwarningstrue
%D \showmessagestrue
%D \stoptyping
%D
%D Turning off messages also turns off warnings, which is
%D quote logical because they are less important.

% not yet mkiv

\newif\ifshowwarnings \showwarningstrue
\newif\ifshowmessages \showmessagestrue

\let\normalshowmessage\showmessage

\unexpanded\def\showwarning
  {\ifshowwarnings
     \expandafter\showmessage
   \else
     \expandafter\gobblethreearguments
   \fi}

\unexpanded\def\showmessage
  {\ifshowmessages
     \expandafter\normalshowmessage
   \else
     \expandafter\gobblethreearguments
   \fi}

%D \macros
%D   {dosetvalue,dosetevalue,dosetgvalue,dosetxvalue,docopyvalue,doresetvalue} % dogetvalue
%D
%D We already defined these auxiliary macros in the system
%D modules. Starting with this module however, we have to take
%D multi||linguality a bit more serious.

%D In due time, when we exclusively use the parameter handler code, we can drop
%D the backmapping (\type{\c!k...}) and make \type {\c!c...} similar to
%D \type {\v!...}. In that case we can simply the following setters.

\unexpanded\def\doletvalue     #1#2{\expandafter\let \csname#1\ifcsname\k!prefix!#2\endcsname\csname\k!prefix!#2\endcsname\else#2\fi\endcsname}
\unexpanded\def\dosetvalue     #1#2{\expandafter\def \csname#1\ifcsname\k!prefix!#2\endcsname\csname\k!prefix!#2\endcsname\else#2\fi\endcsname}
\unexpanded\def\dosetevalue    #1#2{\expandafter\edef\csname#1\ifcsname\k!prefix!#2\endcsname\csname\k!prefix!#2\endcsname\else#2\fi\endcsname}
\unexpanded\def\dosetgvalue    #1#2{\expandafter\gdef\csname#1\ifcsname\k!prefix!#2\endcsname\csname\k!prefix!#2\endcsname\else#2\fi\endcsname}
\unexpanded\def\dosetxvalue    #1#2{\expandafter\xdef\csname#1\ifcsname\k!prefix!#2\endcsname\csname\k!prefix!#2\endcsname\else#2\fi\endcsname}
\unexpanded\def\doresetvalue   #1#2{\expandafter\let \csname#1\ifcsname\k!prefix!#2\endcsname\csname\k!prefix!#2\endcsname\else#2\fi\endcsname\empty}
\unexpanded\def\doignorevalue#1#2#3{\expandafter\let \csname#1\ifcsname\k!prefix!#2\endcsname\csname\k!prefix!#2\endcsname\else#2\fi\endcsname\empty}

\unexpanded\def\docopyvalue#1#2#3%
  {\ifcsname\k!prefix!#3\endcsname
     \expandafter\def\csname#1\csname\k!prefix!#3\endcsname\expandafter\endcsname\expandafter
       {\csname#2\csname\k!prefix!#3\endcsname\endcsname}%
   \else
     \expandafter\def\csname#1#3\expandafter\endcsname\expandafter
       {\csname#2#3\endcsname}%
   \fi}

\startinterface english

    \unexpanded\def\doletvalue     #1#2{\expandafter \let\csname#1#2\endcsname}
    \unexpanded\def\dosetvalue     #1#2{\expandafter \def\csname#1#2\endcsname}
    \unexpanded\def\dosetevalue    #1#2{\expandafter\edef\csname#1#2\endcsname}
    \unexpanded\def\dosetgvalue    #1#2{\expandafter\gdef\csname#1#2\endcsname}
    \unexpanded\def\dosetxvalue    #1#2{\expandafter\xdef\csname#1#2\endcsname}
    \unexpanded\def\doresetvalue   #1#2{\expandafter \let\csname#1#2\endcsname\empty}
    \unexpanded\def\doignorevalue#1#2#3{\expandafter \let\csname#1#2\endcsname\empty}

    \unexpanded\def\docopyvalue#1#2#3%
      {\expandafter\def\csname#1#3\expandafter\endcsname\expandafter
         {\csname#2#3\endcsname}}

\stopinterface

%D We can now redefine some messages that will be
%D introduced in the multi||lingual system module.

\unexpanded\def\showassignerror  #1#2{\showmessage\m!check1{#1,#2}\waitonfatalerror}
\unexpanded\def\showargumenterror#1#2{\showmessage\m!check2{#1,#2}\waitonfatalerror}
\unexpanded\def\showdefinederror #1#2{\showmessage\m!check3{#1,#2}\waitonfatalerror}

%D \CONTEXT\ is a parameter driven package. This means that
%D users instruct the system by means of variables, values and
%D keywords. These instructions take the form:
%D
%D \starttyping
%D \setupsomething[some variable=some value, another one=a keyword]
%D \stoptyping
%D
%D or by keyword only:
%D
%D \starttyping
%D \dosomething[this way,that way,no way]
%D \stoptyping
%D
%D Because the same variables can occur in more than one setup
%D command, we have to be able to distinguish them. This is
%D achieved by assigning them a unique prefix.
%D
%D Imagine a setup command for boxed text, that enables us to
%D specify the height and width of the box. Behide the scenes
%D the command
%D
%D \starttyping
%D \setupbox [width=12cm, height=3cm]
%D \stoptyping
%D
%D results in something like
%D
%D \starttyping
%D \<box><width>   {12cm}
%D \<box><height>  {3cm}
%D \stoptyping
%D
%D while a similar command for specifying the page dimensions
%D of an \cap{A4} page results in:
%D
%D \starttyping
%D \<page><width>  {21.0cm}
%D \<page><height> {27.9cm}
%D \stoptyping
%D
%D The prefixes \type{<box>} and \type{<page>} are hidden from
%D users and can therefore be language independant. Variables
%D on the other hand, differ for each language:
%D
%D \starttyping
%D \<box><color>   {<blue>}
%D \<box><kleur>   {<blauw>}
%D \<box><couleur> {<blue>}
%D \stoptyping
%D
%D In this example we can see that the assigned values or
%D keywords are language dependant too. This will be a
%D complication when defining multi||lingual setup files.
%D
%D A third phenomena is that variables and values can have a
%D similar meaning.
%D
%D \starttyping
%D \<pagenumber><location> {<left>}
%D \<skip><left>           {12cm}
%D \stoptyping
%D
%D A (minor) complication is that where in english we use
%D \type{<left>}, in dutch we find both \type{<links>} and
%D \type{<linker>}. This means that when we use some sort of
%D translation table, we have to distinguish between the
%D variables at the left side and the fixed values at the
%D right.
%D
%D The same goes for commands that are composed of different
%D user supplied and/or language specific elements. In english
%D we can use:
%D
%D \starttyping
%D \<empty><figure>
%D \<empty><intermezzo>
%D \stoptyping
%D
%D But in dutch we have the following:
%D
%D \starttyping
%D \<lege><figuur>
%D \<leeg><intermezzo>
%D \stoptyping
%D
%D These subtle differences automatically lead to a solution
%D where variables, values, elements and other components have
%D a similar logical name (used in macro's) but a different
%D meaning (supplied by the user).
%D
%D Our solution is one in which the whole system is programmed
%D in terms of identifiers with language specific meanings. In
%D such an implementation, each fixed variable is available as:
%D
%D \starttyping
%D \<prefix><variable>
%D \stoptyping
%D
%D This means that for instance:
%D
%D \starttyping
%D \setupbox[width=12cm]
%D \stoptyping
%D
%D expands to something like:
%D
%D \starttyping
%D \def\boxwidth{12cm}
%D \stoptyping
%D
%D because we don't want to recode the source, a setup command
%D in another language has to expand to this variable, so:
%D
%D \starttyping
%D \setupblock[width=12cm]
%D \stoptyping
%D
%D has to result in the definition of \type{\boxwidth} too.
%D This method enables us to build compact, fast and readable
%D code.
%D
%D An alternative method, which we considered using, uses a
%D more indirect way. In this case, both calls generate a
%D different variable:
%D
%D \starttyping
%D \def\boxwidth   {12cm}
%D \def\boxbreedte {12cm}
%D \stoptyping
%D
%D And because we don't want to recode those megabytes of
%D already developed code, this variable has to be called with
%D something like:
%D
%D \starttyping
%D \valueof\box\width
%D \stoptyping
%D
%D where \type{\valueof} takes care of the translation of
%D \type{width} or \type{breedte} to \type{width} and
%D combining this with \type{box} to \type{\boxwidth}.
%D
%D One advantage of this other scheme is that, within certain
%D limits, we can implement an interface that can be switched
%D to another language at will, while the current approach
%D fixes the interface at startup. There are, by the way,
%D other reasons too for not choosing this scheme. Switching
%D user generated commands is for instance impossible and a
%D dual interface would therefore give a strange mix of
%D languages.
%D
%D Now let's work out the first scheme. Although the left hand
%D of the assignment is a variable from the users point of
%D view, it is a constant in terms of the system. Both
%D \type{width} and \type{breedte} expand to \type{width}
%D because in the source we only encounter \type{width}. Such
%D system constants are presented as
%D
%D \starttyping
%D \c!width
%D \stoptyping
%D
%D This constant is always equivalent to \type{width}. As we
%D can see, we use \type{c!} to mark this one as constant. Its
%D dutch counterpart is:
%D
%D \starttyping
%D breedte
%D \stoptyping
%D
%D When we interpret a setup command each variable is
%D translated to it's \type{c!} counterpart. This means that
%D \type{breedte} and \type{width} expand to \type{breedte}
%D and \type{\c!width} which both expand to \type{width}. That
%D way user variables become system constants.
%D
%D The interpretation is done by means of a general setup
%D command \type{\getparameters} that we introduced in the
%D system module. Let us define some simple setup command:
%D
%D \starttyping
%D \unexpanded\def\setupbox[#1]%
%D   {\getparameters[\??bx][#1]}
%D \stoptyping
%D
%D This command can be used as:
%D
%D \starttyping
%D \setupbox [width=3cm, height=1cm]
%D \stoptyping
%D
%D Afterwards we have two variables \type{\@@bxwidth} and
%D \type{\@@bxheight} which have the values \type{3cm} and
%D \type{1cm} assigned. These variables are a combinatiom of
%D the setup prefix \type{\??bx}, which expands to \type{@@bx}
%D and the translated user supplied variables \type{width} and
%D  \type{height} or \type{breedte} and \type{hoogte},
%D depending on the actual language. In dutch we just say:
%D
%D \starttyping
%D \stelblokin [breedte=3cm,hoogte=1cm]
%D \stoptyping
%D
%D and get ourselves \type{\@@bxwidth} and \type{\@@bxheight}
%D too. In the source of \CONTEXT, we can recognize constants
%D and variables on their leading \type{c!}, \type{v!} etc.,
%D prefixes on \type{??} and composed variables on \type{@@}.
%D
%D We already saw that user supplied keywords need some
%D special treatment too. This time we don't translate the
%D keyword, but instead use in the source a variable which
%D meaning depends on the interface language.
%D
%D \starttyping
%D \v!left
%D \stoptyping
%D
%D Which can be used in macro's like:
%D
%D \starttyping
%D \processaction
%D   [\@@bxlocation]
%D   [  \v!left=>\dosomethingontheleft,
%D    \v!middle=>\dosomthinginthemiddle,
%D     \v!right=>\dosomethingontheright]
%D \stoptyping
%D
%D Because variables like \type{\@@bxlocation} can have a lot
%D of meanings, including tricky expandable tokens, we cannot
%D translate this meaning when we compare. This means that
%D \type{\@@bxlocation} can be \type{left} of \type{links} of
%D whatever meaning suits the language. But because
%D \type{\v!left} also has a meaning that suits the language,
%D we are able to compare.
%D
%D Although we know it sounds confusing we want to state two
%D important characteristics of the interface as described:
%D
%D \startnarrower \em
%D user variables become system constants
%D \stopnarrower
%D
%D and
%D
%D \startnarrower \em
%D user constants (keywords) become system variables
%D \stopnarrower

%D The \type {\c!internal} is a left over from the time that
%D the user interface documents were not using a specification
%D alongside a keyword specification but used a shared file in
%D which case we need to go in both directions.

% temporary mkiv hack (we can best just store the whole table in memory)

\unexpanded\def\setinterfaceconstant#1#2%
  {\clf_setinterfaceconstant{#1}{#2}%
   \expandafter\def\csname\c!prefix!#1\endcsname{#1}}

\unexpanded\def\setinterfacevariable#1#2%
  {\clf_setinterfacevariable{#1}{#2}%
   \expandafter\def\csname\v!prefix!#1\endcsname{#2}}

%D \macros
%D   {defineinterfaceconstant}
%D
%D Next we redefine a previously defined macro to take care of
%D interface translation too. It's a bit redundant, because
%D in these situations we could use the c||version, but for
%D documentation purposes the x||alternative comes in handy.

\unexpanded\def\defineinterfaceconstant#1#2%
  {\expandafter\def\csname\c!prefix!#1\endcsname{#2}}

%D \macros
%D   {startelements}
%D
%D Due to the object oriented nature of \CONTEXT, we also need
%D to define the elements that are used to build commands.
%D
%D Such elements sometimes are the same in diferent
%D languages, but mostly they differ. Things can get even
%D confusing when we look at for instance the setup commands.
%D In english we say \type{\setup<something>}, but in dutch we
%D have: \type{\stel<iets>in}. Such split elements are no
%D problem, because we just define two elements. When no second
%D part is needed, we use a \type{-}:

\unexpanded\def\setinterfaceelement#1#2%
  {\clf_setinterfaceelement{#1}{#2}%
   \ifcsname\e!prefix!#1\endcsname
     \doifnotvalue{\e!prefix!#1}{#2}{\setvalue{\e!prefix!#1}{#2}}%
   \else
     \setvalue{\e!prefix!#1}{#2}%
   \fi}

\unexpanded\def\setinterfacecommand#1#2%
  {\doifnot{#1}{#2}% todo: let when already defined
     {\expandafter\def\csname#2\expandafter\endcsname\expandafter{\csname#1\endcsname}}}

%D We just ignore these:

\unexpanded\def\startvariables{\gobbleuntil\stopvariables} \let\stopvariables\relax
\unexpanded\def\startconstants{\gobbleuntil\stopconstants} \let\stopconstants\relax
\unexpanded\def\startelements {\gobbleuntil\stopelements } \let\stopelements \relax
\unexpanded\def\startcommands {\gobbleuntil\stopcommands } \let\stopcommands \relax

%D For at the \LUA\ end (experiment):

% \def\do@sicon#1#2{\expandafter\gdef\csname\c!prefix!#1\endcsname{#1}%
%                   \expandafter\gdef\csname\k!prefix!#2\endcsname{#1}} % backmapping from non english
% \def\do@sivar#1#2{\expandafter\gdef\csname\v!prefix!#1\endcsname{#2}}
% \def\do@siele#1#2{\expandafter\gdef\csname\e!prefix!#1\endcsname{#2}}
% \def\do@sicom#1#2{\expandafter\gdef\csname#2\expandafter\endcsname\expandafter{\csname#1\endcsname}}
%
% \startinterface english
%
%     \def\do@sicon#1#2{\expandafter\gdef\csname\c!prefix!#1\endcsname{#1}}
%
% \stopinterface

\def\ui_c#1#2{\expandafter\gdef\csname\c!prefix!#1\endcsname{#1}%
                \expandafter\gdef\csname\k!prefix!#2\endcsname{#1}} % backmapping from non english
\def\ui_s  #1{\expandafter\gdef\csname\c!prefix!#1\endcsname{#1}%
                \expandafter\gdef\csname\k!prefix!#1\endcsname{#1}} % backmapping from non english
\def\ui_v#1#2{\expandafter\gdef\csname\v!prefix!#1\endcsname{#2}}
\def\ui_e#1#2{\expandafter\gdef\csname\e!prefix!#1\endcsname{#2}}
\def\ui_m#1#2{\expandafter\gdef\csname#2\expandafter\endcsname\expandafter{\csname#1\endcsname}}

\startinterface english

    \def\ui_c#1#2{\expandafter\gdef\csname\c!prefix!#1\endcsname{#1}}
    \def\ui_s  #1{\expandafter\gdef\csname\c!prefix!#1\endcsname{#1}}

\stopinterface

%D So much for the basic multi||lingual interface commands. The
%D macro's can be enhanced with more testing facilities, but
%D for the moment they suffice.

\ifdefined\zwnj \else \edef\zwnj{\directlua{utf.char(\number"200C)}} \fi % needed for cont-pe % maybe to char-utf.mkiv
\ifdefined\zwj  \else \edef\zwj {\directlua{utf.char(\number"200D)}} \fi % needed for cont-pe % maybe to char-utf.mkiv

%D Out of convenience we define the banners here. This might move
%D to the \LUA\ end.

\def\contextbanner
  {ConTeXt \space
   ver: \contextversion \space \contextmark \space \contextkind \space \space
   fmt: \formatversion \space \space
   int: \currentinterface/\currentresponses}

\unexpanded\def\showcontextbanner
  {\writeline\writebanner{\contextbanner}\writeline}

\edef\formatversion
  {\the\normalyear .\the\normalmonth.\the\normalday}

\ifx\contextversion\undefined
    \def\contextversion      {unknown}
    \def\contextversionnumber{0}
\else
   %\def\contextversionnumber#1.#2.#3 #4:#5\relax{#1\ifnum#2<10 0\fi#2\ifnum#3<10 0\fi#3 #4:#5}
	\def\contextversionnumber#1.#2.#3 #4:#5\relax{#1\ifnum#2<10 0\fi\purenumber{#2}\ifnum#3<10 0\fi\purenumber{#3} #4:#5}
    \edef\contextversionnumber{\expandafter\contextversionnumber\contextversion\relax\space\contextmark}
\fi

\ifx\undefined\everydump
  \newtoks\everydump
  \def\dump{\the\everydump\normaldump}
\fi

\appendtoks \showcontextbanner \to \everydump

\protect \endinput
