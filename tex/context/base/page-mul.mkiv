%D \module
%D   [       file=page-mul, % was: core-mul
%D        version=1998.03.15,
%D          title=\CONTEXT\ Page Macros,
%D       subtitle=Multi Column Output,
%D         author=Hans Hagen,
%D           date=\currentdate,
%D      copyright={PRAGMA ADE \& \CONTEXT\ Development Team}]
%C
%C This module is part of the \CONTEXT\ macro||package and is
%C therefore copyrighted by \PRAGMA. See mreadme.pdf for
%C details.

% !!! there are some issues with hsize an vsize as well as flushing
% !!! floats but this module will be redone anyway

\writestatus{loading}{ConTeXt Page Macros / Simple Multi Column}

%D This module is mostly a copy from the original multi column
%D routine as implemented in \type {core-mul}. When the main
%D OTR macro's were isolated in modules and column sets were
%D introduced, this module became part of the OTR modules. As
%D a result this module is no longer generic. It also needs
%D an overhaul.

\unprotect

\unexpanded\def\page_mul_command_side_float_output
  {\page_otr_construct_and_shipout\unvbox\normalpagebox}

\unexpanded\def\page_mul_command_flush_side_floats
  {\page_sides_forget_floats}

\unexpanded\def\page_mul_command_synchronize_side_floats
  {\page_sides_forget_floats}

\unexpanded\def\page_mul_command_next_page
  {\page_otr_eject_page}

\unexpanded\def\page_mul_command_next_page_and_inserts
  {\page_otr_eject_page_and_flush_inserts}

% check \count<insert> multiplications

%D The following macro's implement a multi||column output routine. The original
%D implementation was based on Donald Knuth's implementation, which was adapted by
%D Craig Platt to support balancing of the last page. I gradually adapted Platt's
%D version to our needs but under certain circumstances things still went wrong. I
%D considered all calls to Platt's \type{\balancingerror} as undesirable.
%D
%D This completely new implementation can handle enough situations for everyday
%D documents, but is still far from perfect. While at the moment the routine doesn't
%D support all kind of floats, it does support:
%D
%D \startitemize[packed]
%D \item  an unlimitted number of columns
%D \item  ragged or not ragged bottoms
%D \item  optional balancing without \type{\balancingerrors}
%D \item  different \type{\baselineskips}, \type{\spacing}, \type {\topskip} and
%D        \type {\maxdepth}
%D \item  left- and right indentation, e.g. within lists
%D \item  moving columns floats to the next column or page
%D \item  handling of floats that are to wide for a columns
%D \stopitemize
%D
%D One could wonder why single and multi||columns modes are still separated. One
%D reason for this is that \TeX\ is not suited well for handling multi||columns. As
%D a result, the single columns routines are more robust. Handling one column as a
%D special case of multi||columns is posible but at the cost of worse float
%D handling, worse page breaking, worse etc. Complicated multi||column page handling
%D should be done in \cap{DTP}||systems anyway.
%D
%D There are three commands provided for entering and leaving multi||column mode and
%D for going to the next column:
%D
%D \interface \type{\beginmulticolumns} \\ \\
%D \interface \type{\endmulticolumns}   \\ \\
%D \interface \type{\ejectcolumn}       \\ \\

\def\finalcolumntextwidth   {\makeupwidth}
\def\finalcolumntextheight  {\textheight}
\def\columntextwidth        {\makeupwidth}
\def\columntextheight       {\textheight}
\def\usercolumnwidth        {\textwidth}
\def\columntextoffset       {\!!zeropoint}

\def\fixedcolumnheight      {\textheight}
\def\betweencolumns         {\hskip\bodyfontsize}

\let\setcolumnfloats        \relax % in CONTEXT used for floats
\let\flushcolumnfloats      \relax % in CONTEXT used for floats
\let\flushcolumnfloat       \relax % in CONTEXT used for floats
\let\finishcolumnbox        \relax % in CONTEXT used for backgrounds

%D Both macros are redefined in \CONTEXT\ when backgrounds are applied to
%D columns. The final values are used when flushing the columns.

%D It's more convenient to use \type {\columnwidth} instead of messing around
%D with boxes each time.

\newdimen\columnwidth
\newdimen\gutterwidth

\def\determinecolumnwidth
  {\bgroup
   \setbox\scratchbox\hbox
     {\page_mul_command_set_hsize
      \global\columnwidth\usercolumnwidth
      \global\gutterwidth\intercolumnwidth}%
   \egroup}

%D Going to a new columns is done by means of a \type {\ejectcolumn}. The
%D following definition does not always work.

\def\ejectcolumn
  {\goodbreak
   \showmessage\m!columns2\empty}

\def\balancingerror
  {\showmessage\m!columns3\empty
   \page_otr_construct_and_shipout\unvbox\normalpagebox}

\def\page_mul_place_float_top   {\showmessage\m!columns4\empty\page_one_place_float_here}
\def\page_mul_place_float_bottom{\showmessage\m!columns5\empty\page_one_place_float_here}
\def\page_mul_place_float_here  {\page_one_place_float_here}
\def\page_mul_place_float_force {\page_one_place_float_force}

%D The local column width is available in the dimension register \type
%D {\localcolumnwidth}, which is calculated as:

\unexpanded\def\page_mul_command_set_hsize % beware, this one is available for use in macros
  {\setbox\scratchbox\hbox{\parindent\zeropoint\betweencolumns}%
   \intercolumnwidth\wd\scratchbox
   \localcolumnwidth\columntextwidth
   \advance\localcolumnwidth -\leftskip
   \advance\localcolumnwidth -\rightskip
   % new
   \advance\localcolumnwidth -\colleftskip
   \advance\localcolumnwidth -\colrightskip
   %
   \advance\localcolumnwidth -\nofcolumns\intercolumnwidth
   \advance\localcolumnwidth  \intercolumnwidth
   \divide \localcolumnwidth  \nofcolumns
   \scratchdimen\columntextoffset
   \multiply\scratchdimen \plustwo
   \advance\localcolumnwidth -\scratchdimen
   \usercolumnwidth\localcolumnwidth
   \hsize\localcolumnwidth} % we don't do it \global

%D Torture test:
%D
%D \startbuffer
%D \startbuffer[b]
%D \startcolumns
%D   \input tufte
%D \stopcolumns
%D \stopbuffer
%D \typebuffer[b] \getbuffer[b]
%D
%D \startbuffer[b]
%D \startnarrower
%D   \input tufte
%D \stopnarrower
%D \stopbuffer
%D \typebuffer[b] \getbuffer[b]
%D
%D \startbuffer[b]
%D \startcolumns \startnarrower
%D   \input tufte
%D \stopnarrower \stopcolumns
%D \stopbuffer
%D \typebuffer[b] \getbuffer[b]
%D
%D \startbuffer[b]
%D \startnarrower \startcolumns
%D   \input tufte
%D \stopcolumns \stopnarrower
%D \stopbuffer
%D \typebuffer[b] \getbuffer[b]
%D
%D \startbuffer[b]
%D \startcolumns \startnarrower[left]
%D   \input tufte
%D \stopnarrower \stopcolumns
%D \stopbuffer
%D \typebuffer[b] \getbuffer[b]
%D
%D \startbuffer[b]
%D \startnarrower[left] \startcolumns
%D   \input tufte
%D \stopcolumns \stopnarrower
%D \stopbuffer
%D \typebuffer[b] \getbuffer[b]
%D
%D \startbuffer[b]
%D \startnarrower \startcolumns \startnarrower
%D   \input tufte
%D \stopnarrower\stopcolumns \stopnarrower
%D \stopbuffer
%D \typebuffer[b] \getbuffer[b]
%D
%D \startbuffer[b]
%D \startnarrower[left] \startcolumns \startnarrower
%D   \input tufte
%D \stopnarrower\stopcolumns \stopnarrower
%D \stopbuffer
%D \typebuffer[b] \getbuffer[b]
%D \stopbuffer
%D
%D \start
%D \def\postprocesscolumnline#1{\ruledhbox{\strut\box#1}\hss}
%D \getbuffer
%D \stop

%D One should be aware that when font related dimensions are used in typesetting the
%D in||between material, these dimensions are influenced by bodyfont switches inside
%D multi||column mode.

\newdimen\mcscratchdimen
\newcount\nofcolumnlines

\setnewconstant\multicolumnlinemethod\plusone % 0: overshoot (old default), 1: tight

\def\getmulticolumnlines
  {\mcscratchdimen-\columntextoffset
   \multiply\mcscratchdimen \plustwo
   \advance\mcscratchdimen \columntextheight
   \ifdim\precolumnboxheight>\zeropoint
      \advance\mcscratchdimen -\precolumnboxheight
   \fi
   \settotalinsertionheight
   \advance\mcscratchdimen -\totalinsertionheight
   \ifcase\multicolumnlinemethod \getnoflines\mcscratchdimen
   \or                           \getrawnoflines\mcscratchdimen
   \else                         \getrawnoflines\mcscratchdimen
   \fi
   % added 30/7/2004
   \ifnum\layoutlines>\zerocount \ifnum\noflines>\layoutlines
     \noflines\layoutlines
   \fi \fi
   \nofcolumnlines\noflines}

\def\multicolumnovershootratio{.5} % {\ifgridsnapping0\else.5\fi}

\unexpanded\def\page_mul_command_set_vsize
  {\page_one_command_set_vsize % indeed?
   \getmulticolumnlines
   \mcscratchdimen\nofcolumnlines\openlineheight
   \advance\mcscratchdimen \multicolumnovershootratio\openlineheight % collect enough data
   \global\vsize\nofcolumns\mcscratchdimen
   \global\pagegoal\vsize} % let's do it only here

%D It really starts here. After some checks and initializations we change the output
%D routine to continous multi||column mode. This mode handles columns that fill the
%D current and next full pages. The method used is (more or less) multiplying \type
%D {\vsize} and dividing \type {\hsize} by \type {\nofcolumns}. More on this can be
%D found in the \TeX book. We save the top of the current page in box
%D \type{\precolumnbox}.
%D
%D We manipulate \type {\topskip} a bit, just to be shure that is has no
%D flexibility. This has te be done every time a font switch takles place, because
%D \type{\topskip} can depend on this.

\newconstant\c_page_mul_routine

\setnewconstant\c_page_mul_routine_regular    \zerocount
\setnewconstant\c_page_mul_routine_intercept  \plusone
\setnewconstant\c_page_mul_routine_continuous \plustwo
\setnewconstant\c_page_mul_routine_balanced   \plusthree
\setnewconstant\c_page_mul_routine_error      \plusfour

\unexpanded\def\page_mul_command_routine
  {\ifcase\c_page_mul_routine
     \page_one_command_routine
   \or
     \interceptmulticolumnsout
   \or
     \continuousmulticolumnsout
   \or
     \balancedmulticolumnsout
   \or
     \balancingerror
   \fi}

\def\interceptmulticolumnsout
  {\global\setbox\precolumnbox\vbox
     {\page_otr_command_flush_top_insertions\unvbox\normalpagebox}}

\def\beginmulticolumns
  {\par
   \flushnotes
   \xdef\precolumndepth{\the\prevdepth}%
   \begingroup
   % new
   \leftskip1\leftskip
   \rightskip1\rightskip
   \edef\colleftskip {\the\leftskip}%
   \edef\colrightskip{\the\rightskip}%
   \leftskip\zeropoint
   \rightskip\zeropoint
   %
  %\setcolumntextwidth\relax
  %\setcolumntextheight\relax
   \widowpenalty\zerocount % is gewoon beter
   \clubpenalty \zerocount % zeker bij grids
   \page_floats_column_push_saved
   \dimen0\dimexpr\pagetotal+\parskip+\openlineheight\relax
   \ifdim\dimen0<\pagegoal
     \allowbreak
   \else
     \break % Sometimes fails
   \fi
   \appendtoks\topskip1\topskip\to\everybodyfont
   \the\everybodyfont % ugly here
   \saveinterlinespace % ugly here
   \initializecolumns\nofcolumns
   \hangafter\zerocount
   \hangindent\zeropoint
   \everypar\emptytoks
   \ifdim\pagetotal=\zeropoint \else
     \verticalstrut
     \vskip-\struttotal
   \fi
   \global\savedpagetotal\pagetotal
   \setupoutputroutine[\s!multicolumn]%
   \c_page_mul_routine\c_page_mul_routine_intercept
   \page_otr_trigger_output_routine % no \holdinginserts=1, can make footnote disappear !
   \global\precolumnboxheight\ht\precolumnbox
   \c_page_mul_routine\c_page_mul_routine_continuous
   \setcolumnfloats
   \dohandleallcolumns{\global\setbox\currenttopcolumnbox\emptybox}%
   \checkbegincolumnfootnotes
   \page_otr_command_set_hsize
   \page_otr_command_set_vsize}

%D When we leave the multi||column mode, we have to process the not yet shipped out
%D part of the columns. When we don't balance, we simply force a continuous output,
%D but a balanced output is more tricky.
%D
%D First we try to fill up the page and when all or something is left we try to
%D balance things. This is another useful adaption of the ancesters of these
%D macro's. It takes some reasoning to find out what happens and maybe I'm making
%D some mistake, but it works.
%D
%D Voiding box \type {\precolumnbox} is sometimes necessary, e.g. when there is no
%D text given between \type {\begin..} and \type {\end..}. The \type {\par} is
%D needed!

\setnewconstant\multicolumnendsyncmethod\plusone % 1: old sync 2: new sync (cont-loc/project) / may fail ! ! ! !

\def\endmulticolumns
  {%\par
   \ifnum\multicolumnendsyncmethod=\plustwo
     \synchronizeoutput
   \else
     % don't combine these
     \vskip\lineheight
     \vskip-\lineheight % take footnotes into account
   \fi
   \doflushcolumnfloat  % added recently
  %\doflushcolumnfloats % no, since it results in wrong top floats
   \flushnotes          % before start of columns
   \par
   \ifbalancecolumns
     \ifnum\multicolumnendsyncmethod=\plusone
       \c_page_mul_routine\c_page_mul_routine_continuous
       \goodbreak
     \fi
     \c_page_mul_routine\c_page_mul_routine_balanced
   \else
     \goodbreak
   \fi
   % still the multi column routine
   \page_otr_trigger_output_routine % the prevdepth is important, try e.g. toclist in
   \prevdepth\zeropoint % columns before some noncolumned text text
   %
   \c_page_mul_routine\c_page_mul_routine_regular
%    \page_otf_set_engine_output_routine{\singlecolumnout}%
%    \page_otf_set_engine_output_routine{\page_otr_triggered_output_routine}%
   %
   \ifvoid\precolumnbox\else
     \unvbox\precolumnbox
   \fi
   \global\precolumnboxheight\zeropoint
   \endgroup % here
   \nofcolumns\plusone
   \page_otr_command_set_vsize % the outer vsize (NEEDS CHECKING)
   \synchronizeoutput % new may 2004 / we need to: \pagegoal\vsize
   \checkendcolumnfootnotes
   \dosomebreak\allowbreak
   \page_floats_column_pop_saved}

%D Because some initializations happen three times, we defined a macro for
%D them. Erasing \type{\everypar} is needed because we don't want anything
%D to interfere.

\def\setmulticolumnsout
  {\everypar\emptytoks
   \dontcomplain
   \settopskip
   \setmaxdepth
   \topskip1\topskip
   \splittopskip\topskip
   \splitmaxdepth\maxdepth
   \boxmaxdepth\maxdepth % dangerous
   \emergencystretch\zeropoint\relax} % sometimes needed !

%D Flushing the page comes to pasting the columns together and appending the result
%D to box \type {\precolumnbox}, if not void. I've seen a lot of implementations in
%D which some skip was put between normal text and multi||column text. When we don't
%D want this, the baselines can be messed up. I hope the seemingly complicated
%D calculation of a correction \type {\kern} is adequate to overcome this. Although
%D not watertight, spacing is taken into account and even multiple mode changes on
%D one page go well. But cross your fingers and don't blame me.
%D
%D One of the complications of flushing out the boxes is that \type {\precolumnbox}
%D needs to be \type {\unvbox}'ed, otherwise there is too less flexibility in the
%D page when using \type {\raggedbottom}. It took a lot of time before these kind of
%D problems were overcome. Using \type {\unvbox} at the wrong moment can generate
%D \type {\balancingerror}'s.
%D
%D One can use the macros \type {\maxcolumnheight} and \type {\maxcolumndepth} when
%D generating material between columns as well as postprocessing column lines.

\let\maxcolumnheight=\zeropoint
\let\maxcolumndepth =\zeropoint

\newbox\columnpagebox

\def\setmaxcolumndimensions
  {\let\maxcolumnheight\!!zeropoint
   \let\maxcolumndepth \!!zeropoint
   \dohandleallcolumns
     {\ifdim\ht\currentcolumnbox>\maxcolumnheight
        \edef\maxcolumnheight{\the\ht\currentcolumnbox}%
      \fi
      \ifdim\dp\currentcolumnbox>\maxcolumndepth
        \edef\maxcolumndepth{\the\dp\currentcolumnbox}%
      \fi}}

\setnewconstant\multicolumntopflushmethod\plusone % 0: no correction, 1: correction when topstuff, 2: correction, 3: correction++
\setnewconstant\multicolumntopalignmethod\plustwo % 0: nothing, 1: force grid, 2: follow grid

\def\flushprecolumnboxnogrid
  {\unvbox\precolumnbox}

\def\flushprecolumnboxongrid
  {\scratchdimen\savedpagetotal
   \advance\scratchdimen -\ht\precolumnbox
   \advance\scratchdimen -\dp\precolumnbox
   \advance\scratchdimen -\topskip
   \box\precolumnbox
   \kern\scratchdimen}

\newconditional\someprecolumncontent

\def\flushcolumnedpage#1%
  {\bgroup
   \ifvoid\precolumnbox
     \setfalse\someprecolumncontent % will be set elsewhere
   \else
     \settrue\someprecolumncontent
     \mkprocessboxcontents\precolumnbox
   \fi
   \forgetall
   \setmulticolumnsout
   \setmaxcolumndimensions
   \dohandleallcolumns
     {\mkprocesscolumncontents\currentcolumnbox}%
   \dohandleallcolumns
     {\page_marks_synchronize_column\plusone\nofcolumns\mofcolumns\currentcolumnbox}%
   \postprocesscolumns
   \dohandleallcolumns
     {\global\setbox\currentcolumnbox\hbox to \localcolumnwidth
        {\box\currentcolumnbox}%
      \wd\currentcolumnbox\localcolumnwidth
      \ifheightencolumns
        \ht\currentcolumnbox\fixedcolumnheight
      \fi}%
   \setmaxcolumndimensions
   \overlaycolumnfootnotes
   \setbox\columnpagebox\vbox
     {\hbox to \finalcolumntextwidth
        {\hskip\colleftskip\relax % new, \relax needed
         \ifreversecolumns
           \@EA\dohandlerevcolumns
         \else
           \@EA\dohandleallcolumns
         \fi
           {\finishcolumnbox
              {\setbox\scratchbox\hbox
                 {\ifx\finishcolumnbox\relax\else\strut\fi
                  \strut\box\currentcolumnbox}%
               \anch_mark_column_box\scratchbox
               \box\scratchbox}%
            \hfil}%
         \unskip
         \hskip\colrightskip}}% new
   \scratchdimen\zeropoint
   \dohandleallcolumns
     {\ifdim-\ht\currenttopcolumnbox<\scratchdimen
        \scratchdimen-\ht\currenttopcolumnbox
      \fi
      \global\setbox\currenttopcolumnbox\emptybox}%
   \advance\scratchdimen \ht\columnpagebox
   \setbox\scratchbox\hbox to \columntextwidth
     {\vrule
        \!!width\zeropoint
        \!!height\scratchdimen
        \!!depth\dp\columnpagebox
      \dostepwiserecurse2\nofcolumns1{\hfil\betweencolumns}\hfil}%
   \setbox\columnpagebox\hbox
     {\box\columnpagebox
      \hskip-\columntextwidth
      \box\scratchbox}%
   \postprocesscolumnpagebox % new, acts upon \box\columnpagebox
   \ifconditional\someprecolumncontent
     \settrue\someprecolumncontent
     % next some incredible crappy code
     \ifcase\multicolumntopalignmethod
       \flushprecolumnboxnogrid % not on grid
     \or
       \flushprecolumnboxongrid % force on grid
     \else\ifgridsnapping % somehow this junk fails in pascal
       \flushprecolumnboxongrid % obey grid settings, force on grid
     \else
       \flushprecolumnboxnogrid % ignore grid settings, not on grid
     \fi \fi
   \fi
   \global\precolumnboxheight\zeropoint
   \page_otr_command_set_vsize
   \dosomebreak\nobreak % hm, only needed when topstuff
   \ifgridsnapping
   \else
     \ifcase\multicolumntopflushmethod
       % sometimes method 1 goes wrong, so we need a way out; best sort this out
       % when we run into it again
     \or
       % \input tufte \startcolumns \showbaselines \input tufte \stopcolumns \input tufte
       \ifconditional\someprecolumncontent
        %          \scratchdimen\topskip
        %          \advance\scratchdimen -\openstrutheight
        %          \nointerlineskip
        %          \vskip-\scratchdimen
         \nointerlineskip
         \vskip\dimexpr\openstrutheight-\topskip\relax
       \fi
     \or
        %        \scratchdimen\topskip
        %        \advance\scratchdimen -\openstrutheight
        %        \nointerlineskip
        %        \vskip-\scratchdimen
       \nointerlineskip
       \vskip\dimexpr\openstrutheight-\topskip\relax
     \or
       % untested but maybe handy
        %        \scratchdimen\topskip
        %        \advance\scratchdimen -\openstrutheight
        %        \nointerlineskip
        %        \vskip-\scratchdimen
        %        \vskip-\lineheight
        %        \vbox{\strut}%
       \nointerlineskip
       \vskip\dimexpr\openstrutheight-\topskip-\lineheight\relax
       \vbox{\strut}%
     \fi
   \fi
   \prevdepth\openstrutdepth
   \nointerlineskip
   \dp\columnpagebox\zeropoint
   \global\finalcolumnheights\ht\columnpagebox
   \getnoflines\finalcolumnheights
   \global\finalcolumnlines\noflines
   \ifcase#1\else
     % messy correction, we need to rewrite this module (newcolumns)
     \setbox\columnpagebox\vbox
       {\offinterlineskip
        \scratchdimen\ht\columnpagebox
        \advance\scratchdimen\dp\columnpagebox % we probably lost that one already
        \box\columnpagebox
        \vskip-\scratchdimen}%
     \scratchdimen\noflines\openlineheight
     \advance\scratchdimen-\openstrutdepth
     \ifgridsnapping
        % quick hack (at least it works with itemize)
     \else
       \advance\scratchdimen-\openlineheight
       \advance\scratchdimen\topskip
     \fi
     \ht\columnpagebox\scratchdimen
     \dp\columnpagebox\openstrutdepth
     % end of mess
   \fi
   \box\columnpagebox
   \egroup}

%D In case one didn't notice, finaly \type{\finishcolumnbox} is applied to
%D all boxes. One can use these hooks for special purposes.
%D
%D Once upon a time I wanted to manipulate the individual lines in a column.
%D This feature is demonstrated in the two examples below.
%D
%D \startbuffer
%D \def\postprocesscolumnline#1% or \postprocesscolumnbox
%D   {\ruledhbox{\box#1}\hss}
%D
%D \startcolumns[n=4]
%D \dorecurse{25}{line: \recurselevel\par}
%D \stopcolumns
%D \stopbuffer
%D
%D \typebuffer
%D
%D Here we show the natural width of the lines:
%D
%D {\getbuffer}
%D
%D The next example does a bit more advanced manipulation:
%D
%D \startbuffer
%D \def\postprocesscolumnline#1%
%D   {\ifodd\currentcolumn
%D      \hfill\unhbox#1\relax
%D    \else
%D      \relax\unhbox#1\hfill
%D    \fi}
%D
%D \startcolumns[n=4]
%D \dorecurse{25}{line \recurselevel\par}
%D \stopcolumns
%D \stopbuffer
%D
%D \typebuffer
%D
%D Here we also see an application of \type{\currentcolumn}:
%D
%D {\getbuffer}
%D
%D This feature is implemented using the reshape macros
%D presented in \type{supp-box}.

\def\postprocesscolumns
  {\ifx\postprocesscolumnline\undefined \else
     \dohandleallcolumns
       {\global\setbox\currentcolumnbox\vtop
          {\beginofshapebox
           \unvbox\currentcolumnbox
           \unskip\unskip
           \endofshapebox
           \reshapebox
             {\dimen0\ht\shapebox
              \dimen2\dp\shapebox
              \setbox\shapebox\hbox to \hsize
                {\postprocesscolumnline\shapebox}%
              \ht\shapebox\dimen0
              \dp\shapebox\dimen2
              \box\shapebox}%
           \flushshapebox
           \everypar\emptytoks
           \parskip\zeropoint % = \forgetall
           \verticalstrut
           \vskip-\struttotal
           \vfil}}%
   \fi
   \ifx\postprocesscolumnbox\undefined \else
     \dohandleallcolumns
       {\global\setbox\currentcolumnbox\hbox
          {\postprocesscolumnbox\currentcolumnbox}}
   \fi}

%D We default to doing nothing!

\let\postprocesscolumnline   =\undefined
\let\postprocesscolumnbox    =\undefined
\let\postprocesscolumnpagebox=\relax

%D \macros
%D   {reversecolumnstrue}
%D
%D We can force the macro that takes care of combining the columns, to
%D flush them in the revere order. Of course, by default we don't reverse.

\newif\ifreversecolumns

%D Here comes the simple splitting routine. It's a bit longer than expected because
%D of ragging bottoms or not. This part can be a bit shorter but I suppose that I
%D will forget what happens. The splitting takes some already present material
%D (think of floats) into account!
%D
%D First we present some auxiliary routines. Any material, like for instance floats,
%D that is already present in the boxes is preserved.

\def\splitcolumn#1from \box#2to \dimen#3 top \box#4%
  {\bgroup
   \ifdim\ht#4>\zeropoint
     \dimen0\dimen#3\relax
     \dimen2\dimen0
     \advance\dimen0 -\ht#4%
     \columnfootnotecorrection{#1}{\dimen0}%
     \setbox0\vsplit#2 to \dimen0
     \global\setbox#1\vbox to \dimen2
       {\ifgridsnapping
          \dimen0-\openstrutheight
          \advance\dimen0 \topskip
          \vskip\dimen0\copy#4\vskip-\dimen0
        \else
          \unvcopy#4%
        \fi
        \fuzzysnappedbox\unvbox0
        \fakecolumnfootnotes{#1}}%
   \else
     \ifcase\c_strc_notes_page_location
       \global\setbox#1\vsplit#2 to \dimen#3%
       \global\setbox#1\vbox
         {\fuzzysnappedbox\unvbox{#1}}% % or \box ?
     \else
       \columnfootnotecorrection{#1}{\dimen#3}%
       \setbox0\vsplit#2 to \dimen#3%
       \global\setbox#1\vbox to \dimen#3%
         {\fuzzysnappedbox\unvbox0
          \fakecolumnfootnotes{#1}}%
     \fi
   \fi
   \egroup}

\def\splitcurrentcolumn from \box#1to \dimen#2%
  {\splitcolumn\currentcolumnbox from \box#1 to \dimen#2 top \box\currenttopcolumnbox}

\def\splitfirstcolumn from \box#1to \dimen#2%
  {\splitcolumn\firstcolumnbox from \box#1 to \dimen#2 top \box\firsttopcolumnbox}

\def\splitlastcolumn from \box#1to \dimen#2%
  {\global\setbox\lastcolumnbox\vbox
     {\unvcopy\lasttopcolumnbox
      \fuzzysnappedbox\unvbox{#1}%
      \fakecolumnfootnotes\lastcolumnbox}}

%D NEW: still to be documented.

\def\fakecolumnfootnotes#1%
  {\relax
   \ifcase\c_strc_notes_page_location\else
     \ifnum#1=\lastcolumnbox
       \fakenotes
     \fi
   \fi}

\def\columnfootnotecorrection#1#2%
  {\relax
   \ifcase\c_strc_notes_page_location
     % page notes
   \or
     \ifnum#1=\firstcolumnbox\relax
       \calculatetotalclevernoteheight
       \advance#2 -\totalnoteheight
     \fi
   \else
     \ifnum#1=\lastcolumnbox\relax
       \calculatetotalclevernoteheight
       \advance#2 -\totalnoteheight
     \fi
   \fi}

\def\overlaycolumnfootnotes
  {\relax
   \ifcase\c_strc_notes_page_location
     % page
   \or
     \checknotepresence \ifnotespresent \page_mul_notes_flush_first_column \fi
   \or
     \checknotepresence \ifnotespresent \page_mul_notes_flush_last_column \fi
   \fi}

\newbox\b_page_mul_notes

\def\page_mul_notes_flush_first_column
  {\begingroup
   \setbox\b_page_mul_notes\vbox{\placenoteinserts}%
   \ifzeropt\ht\b_page_mul_notes
     % can't happen as we already checked
   \else
     \getmulticolumnlines
     \advance\nofcolumnlines \minustwo
     \scratchdimen\dimexpr\nofcolumnlines\lineheight+\topskip\relax
     \setbox\b_page_mul_notes\hbox{\lower\scratchdimen\box\b_page_mul_notes}%
     \ht\b_page_mul_notes\openstrutheight
     \dp\b_page_mul_notes\openstrutdepth
     \wd\b_page_mul_notes\zeropoint
     \scratchdimen\ht\firstcolumnbox
     \global\setbox\firstcolumnbox\vbox to \scratchdimen
       {\box\firstcolumnbox
        \vskip-\scratchdimen
        \box\b_page_mul_notes}%
   \fi
   \endgroup}

\def\page_mul_notes_flush_last_column
  {\begingroup
   \setbox\b_page_mul_notes\vbox{\placenoteinserts}%
   \ifzeropt\ht\b_page_mul_notes
     % can't happen as we already checked
   \else
     % maybe here also \getmulticolumnlines
     \scratchdimen\dimexpr\ht\firstcolumnbox-\openstrutdepth\relax % \strutdp
     \getnoflines\scratchdimen
     \advance\noflines \minustwo
     \scratchdimen\dimexpr\noflines\lineheight+\topskip\relax
     \setbox\b_page_mul_notes\hbox{\lower\scratchdimen\box\b_page_mul_notes}%
     \ht\b_page_mul_notes\openstrutheight
     \dp\b_page_mul_notes\openstrutdepth
     \wd\b_page_mul_notes\zeropoint
     \scratchdimen\ht\lastcolumnbox
     \global\setbox\lastcolumnbox\vbox to \scratchdimen
       {\box\lastcolumnbox
        \vskip-\scratchdimen
        \box\b_page_mul_notes}%
   \fi
   \endgroup}

%D Here comes the routine that splits the long box in columns. The macro \type
%D {\flushcolumnfloats} can be used to flush either floats that were present before
%D the multi||column mode was entered, or floats that migrate to next columns.
%D Flushing floats is a delicate process.

\def\continuousmulticolumnsout
  {\bgroup
   \forgetall
   \setmulticolumnsout
%    \dimen0=\columntextheight
%    \advance\dimen0 -\precolumnboxheight
%    \settotalinsertionheight
%    \advance\dimen0 -\totalinsertionheight
%    \ifgridsnapping % evt altijd, nog testen
%      \getnoflines{\dimen0}
%      \dimen0=\noflines\openlineheight
%    \fi
   \getmulticolumnlines
   \dimen0=\nofcolumnlines\openlineheight
   \dohandleallcolumns
     {\splitcurrentcolumn from \box\normalpagebox to \dimen0}%
   \setbox\restofpage\vbox{\unvbox\normalpagebox}%
   \ifinheritcolumns
     \ifcase\bottomraggednessmode
       % 0 = ragged
       \dohandleallcolumns
         {\global\setbox\currentcolumnbox\vbox to \ht\firstcolumnbox
            {\dimen0\dp\currentcolumnbox
             \unvbox\currentcolumnbox
             \vskip-\dimen0
             \vskip\openstrutdepth % \strutdp
             \prevdepth\openstrutdepth % \strutdp
             \vfill}}%
       \strc_notes_check_if_bottom_present
       \ifconditional\c_notes_bottom_present \else
         \dimen0\ht\firstcolumnbox
       \fi
     \or
       % 1 = normal
       \advance\dimen0 \maxdepth
       \dohandleallcolumns
         {\global\setbox\currentcolumnbox\vbox to \dimen0
            {\unvbox\currentcolumnbox}}%
     \or
       % 2 = baseline
       % the columns are on top of the baseline
     \fi
   \else
     \dohandleallcolumns
       {\global\setbox\currentcolumnbox\vbox to \dimen0
          {\ifstretchcolumns
             \unvbox\currentcolumnbox
           \else
             \unvbox\currentcolumnbox % wel of niet \unvbox ?
             \vfill
           \fi}}%
     \dohandleallcolumns
       {\ht\currentcolumnbox\dimen0}% redundant
   \fi
   \setbox\precolumnbox\vbox{\flushcolumnedpage\zerocount}%
   \page_otr_construct_and_shipout\box\precolumnbox
   \page_otr_command_set_hsize
   \page_otr_command_set_vsize
   \flushcolumnfloats
   \unvbox\restofpage
   % \penalty\outputpenalty % gaat gruwelijk mis in opsommingen
   \egroup}

%D And this is the balancing stuff. Again, part of the routine is dedicated to
%D handling ragged bottoms, but here we also see some handling concerning the
%D stretching of columns. We set \type {\widowpenalty} at~0, which enables us to
%D balance columns with few lines. The use of \type {\box2} and \type {\box4}
%D garantees a more robust check when skips are used.

\def\multicolumnsbalancemax{250} % 100 is too small when floats are involved

\def\balancedmulticolumnsout
  {\bgroup
   \setmulticolumnsout
   \widowpenalty\zerocount
   \setbox0\vbox{\unvbox\normalpagebox}%
   \ifdim\ht0>\openlineheight % at least one line
     \ifnum\minbalancetoplines<2 % balance anyway
       \donetrue
     \else % check criterium to available lines
       \getnoflines{\ht0}%
       \divide\noflines \nofcolumns \relax
       \ifnum\noflines<\minbalancetoplines \relax
         % let's play safe
         \ifdim\dimexpr\ht0+\ht\firsttopcolumnbox+\openlineheight\relax>\columntextheight
           \donetrue % column exceeding text height
         \else
           \donefalse % it seems to fit
         \fi
       \else % balance indeed
         \donetrue
       \fi
     \fi
  \else % balancing does not make sense
    \donefalse
  \fi
  \ifdone % start balancing, was: \ifdim\ht0>\openlineheight
     \dimen0\ht0
     \advance\dimen0 \topskip
     \advance\dimen0 -\baselineskip
     \dohandleallcolumns
       {\advance\dimen0 \ht\currenttopcolumnbox}%
     \divide\dimen0 \nofcolumns
     \vbadness\plustenthousand
     \count255=\zerocount
     \bgroup
     \ifgridsnapping
       \dimen2\lineheight
     \else
       \dimen2=\onepoint % RUBISH
       \dimen2=\spacingfactor\dimen2
     \fi
     \doloop
       {\advance\count255 \plusone
        \global\setbox\restofpage\copy0\relax
        \splitfirstcolumn from \box\restofpage to \dimen0
        \dohandlemidcolumns
          {\splitcurrentcolumn from \box\restofpage to \dimen0}%
        \splitlastcolumn from \box\restofpage to \dimen0
        \setbox2\vbox{\unvcopy\firstcolumnbox}%
        \dimen4\zeropoint
        \dohandleallcolumns
          {\setbox4\vbox
             {\unvcopy\currentcolumnbox
             %rather new, test this on pdftex-z.tex
              \unpenalty\unskip\unpenalty\unskip}% maybe better in main splitter
          %\writestatus{balance}{\the\currentcolumnbox: \the\ht4}%
%            \dimen6\ht4 \ifdim\dimen6>\dimen4 \dimen4=\dimen6 \fi}%
           \ifdim\ht4>\dimen4 \dimen4=\ht4 \fi}%
        \advance\dimen4 -.0005pt % get rid of accurracy problem, pretty new
        \ifnum\count255>\multicolumnsbalancemax\relax
          \exitloop
        \else\ifdim\dimen4>\ht2
          \advance\dimen0 \dimen2\relax
        \else
          \exitloop
        \fi\fi}%
     \dohandleallcolumns
       {\global\setbox\currentcolumnbox\vbox{\unvcopy\currentcolumnbox}}% NIEUW
     \ifnum\count255>\multicolumnsbalancemax\relax
       \showmessage\m!columns7\empty
     \else
       \showmessage\m!columns8{\the\count255\space}%
     \fi
     \egroup
     \ifinheritcolumns
       % We cannot assume that the first column is the tallest, if
       % only because we may have an aborted balance (one line in the
       % first column and a graphic in the second one).
       %
       % \dimen0\ht\firstcolumnbox
       % \dimen2\ht\firstcolumnbox
       %
       \dimen0=\zeropoint
       \dohandleallcolumns
         {\ifdim\ht\currentcolumnbox>\dimen0
            \dimen0=\ht\currentcolumnbox
          \fi}%
       \dimen2\dimen0
       % so far
       \advance\dimen2 -\openlineheight
       \dohandleallcolumns
         {\dimen4\ht\currentcolumnbox
          \dimen6=10\openlineheight % funny value
          \global\setbox\currentcolumnbox\vbox to \dimen0
            {\unvbox\currentcolumnbox
             \ifdim\dimen4>\dimen6
               \ifdim\dimen4<\dimen0
                 \ifdim\dimen4>\dimen2
                   \vskip\zeropoint  % !!
                 \else
                   \vskip\openlineheight
                   \vfill
                 \fi
               \else
                 \vskip\zeropoint
               \fi
             \else
               \vskip\openlineheight
               \vfill
             \fi}}%
     \else
       \bgroup
       \ifstretchcolumns
         \dimen0\ht\firstcolumnbox
         \dimen2=\bottomtolerance\ht\firstcolumnbox
         \setbox0\vbox{\unvcopy\lastcolumnbox}%
         \advance\dimen0 -\ht0\relax
         \advance\dimen0 -\dp0\relax
         \ifdim\dimen0>\openlineheight\relax
           \ifdim\dimen0>\dimen2\relax
             % \stretchcolumnsfalse % beter goed slecht dan slecht goed
             \showmessage\m!columns9\empty
           \fi
         \fi
       \fi
       \dohandleallcolumns
         {\global\setbox\currentcolumnbox\vbox to \ht\firstcolumnbox
            {\ifstretchcolumns
               \unvbox\currentcolumnbox
             \else
               \box\currentcolumnbox
               \vfill
             \fi}}%
       \egroup
     \fi
   \else
     % a one liner is not properly handled here, so best rewrite the text then
     \showmessage\m!columns{10}\empty
     \global\setbox\firstcolumnbox\vbox{\unvbox0}%
   \fi
   \c_page_mul_routine\c_page_mul_routine_error
   \baselinebottom % forces depth in separation rule
   \flushcolumnedpage\plusone
   \multicolumnseject
   \egroup}

\def\multicolumnseject
  {%\ifdim\pagetotal>\textheight
   %  \page_otr_trigger_output_routine % new, but wrong as fails on mixed-001.tex (wrong pagetotal at this point)
   %\else
     \allowbreak
   }%\fi}

%D The multicolumn mechanism is incorporated in a \CONTEXT\ interface,
%D which acts like:
%D
%D \starttyping
%D \startcolumns[n=4,balance=no]
%D   some text
%D \stopcolumns
%D \stoptyping
%D
%D The setup is optional. The default behaviour of columns can be set
%D up with:
%D
%D \starttyping
%D \setupcolumns
%D   [n=2,
%D    balance=yes]
%D \stoptyping
%D
%D In this case, stretching is according to the way it's done outside columns
%D (\type{\inheritcolumnstrue}). Also we can setup the \type{tolerance} within a
%D column, the \type{distance} between columns and the fixed \type{height} of a
%D column.
%D
%D Here come the routines that handle the placement of column floats. Floats that
%D are to big migrate to the next column. Floats that are too wide, migrate to the
%D top of the next page, where they span as much columns as needed. Floats that are
%D left over from outside the multi||column mode are flushed first. In macro
%D \type{\page_otr_construct_and_shipout} the topfloats that are left from previous
%D text should be set.
%D
%D When there are some floats in the queue, we inhibit the flushing of floats on top
%D of columns. The number of waiting floats is preswent in \type{\savednoftopfloats}
%D and is saved. As long as there are floats waiting, the topfloats are places as if
%D we are outside multi||column mode. This is neccessary for e.g. multicolumn lists.
%D
%D When all those floats are flushed, we switch to the local flushing routine.

% \newbox  \floatlist
% \newbox  \savedfloatlist
%
% \def\page_floats_column_push_saved
%   {\ifconditional\c_page_floats_some_waiting
%      \showmessage\m!columns6{\the\savednoffloats}%
%      \global\setbox\savedfloatlist\box\floatlist
%      \xdef\page_floats_column_pop_saved
%        {\global\savednoffloats\the\savednoffloats
%         \global\setbox\floatlist\box\savedfloatlist
%         \global\noexpand\settrue\c_page_floats_some_waiting}%
%      \global\savednoffloats\zerocount
%      \global\setfalse\c_page_floats_some_waiting
%    \else
%      \global\let\page_floats_column_pop_saved\relax
%    \fi}
%
% \let\page_floats_column_pop_saved\relax

% \def\setcolumnfloats % messy as it adapts everypar
%   {\xdef\globalsavednoffloats{\the\savednoffloats}%
%    \ifnum\globalsavednoffloats>\zerocount
%      \setglobalcolumnfloats % hm, we always push so this never happens
%    \else
%      \setlocalcolumnfloats
%    \fi}

\def\setcolumnfloats % messy as it adapts everypar, we need to adapt this
  {\setlocalcolumnfloats}

\newconditional\onlylocalcolumnfloats % temp hack as we will redo floats (grid snapping is also messy now)

\unexpanded\def\page_mul_command_flush_floats
  {\ifconditional\onlylocalcolumnfloats
     \doflushcolumnfloats
   \else
     \page_one_command_flush_floats
   \fi}

\unexpanded\def\page_mul_command_check_if_float_fits
  {\ifconditional\onlylocalcolumnfloats
     \docolumnroomfloat
   \fi}

\unexpanded\def\page_mul_command_flush_saved_floats
  {\ifconditional\onlylocalcolumnfloats\relax
   \else
     \page_one_command_flush_saved_floats
   \fi}

\unexpanded\def\page_mul_command_flush_top_insertions
  {\ifconditional\onlylocalcolumnfloats\relax
   \else
     \page_one_command_flush_top_insertions
   \fi}

\newtoks\everylocalcolumnfloatspar

\everylocalcolumnfloatspar
  {\flushnotes
   \flushcolumnfloat
 % \flushmargincontents
   \checkindentation}

\def\setlocalcolumnfloats
  {\settrue\onlylocalcolumnfloats
   \everypar\everylocalcolumnfloatspar
   \let\flushcolumnfloat\doflushcolumnfloat
   \let\flushcolumnfloats\doflushcolumnfloats}

\def\setglobalcolumnfloats
  {\setfalse\onlylocalcolumnfloats
   \everypar\emptytoks
   \let\flushcolumnfloat\relax
   \let\flushcolumnfloats\noflushcolumnfloats}

\def\noflushcolumnfloats
  {\bgroup
   \xdef\localsavednoffloats{\the\savednoffloats}%
   \global\savednoffloats\globalsavednoffloats
   \page_otr_command_flush_top_insertions
   \xdef\globalsavenoffloats{\the\savednoffloats}%
   \ifnum\globalsavednoffloats=\zerocount
     \setlocalcolumnfloats
   \fi
   \global\savednoffloats\localsavednoffloats
   \egroup}

%D We need to calculate the amount of free space in a columns. When there is not
%D enough room, we migrate the float to the next column. These macro's are
%D alternatives (and look||alikes) of \type {\doroomfloat}. When a float is to wide,
%D for one column, it is moved to the top of the next page. Of course such moved
%D floats have to be taken into account when we calculate the available space. It's
%D a pitty that such things are no integral part of \TEX.

\def\getcolumnstatus\column#1\total#2\goal#3\\%
  {\dimen0=\ifdim\pagegoal<\maxdimen \pagetotal \else \zeropoint \fi
   \dimen2=\zeropoint
   \count255=\zerocount
   \dimen8=\columntextheight
   \advance\dimen8 -\precolumnboxheight
   \def\dogetcolumnstatus
     {\advance\count255 \plusone
      \advance\dimen2 \ht\currenttopcolumnbox
      \advance\dimen2 \dp\currenttopcolumnbox
      \dimen4\dimen2
      \advance\dimen4 \dimen0
      \dimen6=\count255\dimen8
      \ifdim\dimen4>\dimen6
      \else
        \let\dogetcolumnstatus\relax
      \fi}%
   \dohandleallcolumns{\dogetcolumnstatus}%
   \ifnum\count255=0 \count255=1 \fi
   #1=\count255
   #2=\dimen4
   #3=\dimen6 }

\def\getinsertionheight
  {\ifdim\pagegoal<\maxdimen
     \bgroup
     \dimen0=\columntextheight
     \advance\dimen0 -\pagegoal
     \xdef\insertionheight{\the\dimen0}%
     \egroup
   \else
     \global\let\insertionheight\zeropoint
   \fi}

\def\docolumnroomfloat
  {\ifpostponecolumnfloats
     \global\setfalse\c_page_floats_room
   \else\ifconditional\c_page_floats_not_permitted
     \global\setfalse\c_page_floats_room
   \else
     \bgroup
     \getcolumnstatus\column\count255\total\dimen0\goal\dimen2\\%
     \page_floats_get_info\s!text
     \setbox\scratchbox\vbox % tricky met objecten ?
       {\blank[\rootfloatparameter\c!spacebefore]
        \snaptogrid\vbox{\vskip\floatheight}}% copy?
     \advance\dimen0\dimexpr\ht\scratchbox+2\openlineheight+.5\lineheight\relax\relax % needed because goal a bit higher
     \ifdim\dimen0>\dimen2
       \global\setfalse\c_page_floats_room
     \else
       \global\settrue\c_page_floats_room
     \fi
     \ifdim\floatwidth>\hsize
       \showmessage\m!columns{11}\empty
       \global\setfalse\c_page_floats_room
     \fi
     \egroup
   \fi\fi}

%D Flushing one float is done as soon as possible, i.e. \type {\everypar}.
%D This means that (at the moment) sidefloats are not supported (overulled)!

\newif\ifflushingcolumnfloats \flushingcolumnfloatstrue

\def\doflushcolumnfloat
  {\ifpostponecolumnfloats\else\ifflushingcolumnfloats\ifconditional\c_page_floats_some_waiting
     \doflushcolumnfloatindeed
   \fi\fi\fi}

\def\doflushcolumnfloatindeed
  {\bgroup
   \forgetall
   \let\doflushcolumnfloat\relax
   \getcolumnstatus\column\mofcolumns\total\dimen0\goal\dimen2\\%
   \ifdim\dimen0>\zeropoint
     \page_floats_get_info\s!text
     \ifdim\floatwidth>\hsize
        % dropped ?
     \else
       \setbox2\vbox
         {\blank[\rootfloatparameter\c!spacebefore]
          \snaptogrid\vbox{\vskip\floatheight}}%
       \advance\dimen0 \ht2
       \ifdim\dimen0>\dimen2
         \ifnum\mofcolumns<\nofcolumns
           \advance\mofcolumns \plusone
           \ifdim\ht\currenttopcolumnbox=\zeropoint
             \page_floats_flush\s!text\plusone
             \global\setbox\currenttopcolumnbox\vbox
               {\snaptogrid\vbox{\box\floatbox}
                \whitespace % nodig ?
                \blank[\rootfloatparameter\c!spaceafter]}%
             \dimen4=\htdp\currenttopcolumnbox
             \global\advance\vsize -\dimen4
             \advance\dimen4 -\pagegoal
             \global\pagegoal-\dimen4
             \showmessage\m!columns{12}a%
           \else
             \showmessage\m!columns{12}b%
           \fi
         \else
           \showmessage\m!columns{12}c%
         \fi
       \else
         \ifhmode{\setbox0\lastbox}\fi% waar is die er in geslopen
         \par
         \ifdim\prevdepth<\zeropoint \else % anders bovenaan kolom witruimte
           \nobreak
           \blank[\rootfloatparameter\c!spacebefore]
           \nobreak
         \fi
         \page_floats_flush\s!text\plusone
         \page_otr_command_flush_float_box
         \blank[\rootfloatparameter\c!spaceafter]
       \fi
     \fi
   \fi
   \egroup}

%D This one looks complicated. Upto \type{\nofcolumns} floats are placed,
%D taking the width of a float into account. This routine can be improved
%D on different ways:
%D
%D \startitemize[intro,packed]
%D \item taking into account some imaginary baseline, just to get the
%D       captions in line
%D \item multipass flushing until as many floats are displaced as possible
%D \stopitemize
%D
%D When handling lots of (small) floats spacing can get worse because of
%D lining out the columns.

\def\doflushcolumnfloats
  {\ifpostponecolumnfloats\else
     \bgroup
     \forgetall
     \ifconditional\c_page_floats_some_waiting
       \dimen8\zeropoint
       \dimen4\zeropoint
       \count0\zerocount   % count0 can be used local
       \count2\nofcolumns  % count2 can be used local
       \dohandleallcolumns
         {\ifnum\count0>\zerocount % the wide one's reserved space
            \global\setbox\currenttopcolumnbox\vbox
              {\snaptogrid\vbox
                 {\copy\currenttopcolumnbox
                  \hbox{\vphantom{\vskip\floatheight}}}% known from previous
                  \whitespace % nodig ?
                  \blank[\rootfloatparameter\c!spaceafter]}%
          \else
            \page_floats_get_info\s!text
            \ifdim\floatwidth>\hsize
              \dimen0\dimexpr\floatwidth+\intercolumnwidth+.5pt\relax
              \dimen2\dimexpr\hsize     +\intercolumnwidth+.5pt\relax
              \divide\dimen0 \dimen2
              \count0\dimen0
              \advance\count0 \plusone
              \ifnum\count0>\count2
                \count0\zerocount
              \else
                \dimen0\dimexpr\count0\hsize+\count0\intercolumnwidth-\intercolumnwidth\relax
                \page_floats_flush\s!text\plusone
                \ifdim\floatwidth>\finalcolumntextwidth % better somewhere else too
                  \global\setbox\floatbox\hbox to \finalcolumntextwidth{\hss\box\floatbox\hss}%
                \fi % otherwise the graphic may disappear
                \global\setbox\floatbox\hbox to \dimen0
                  {\processaction[\rootfloatparameter\c!location] % how easy to forget
                     [   \v!left=>\box\floatbox\hss,
                        \v!right=>\hss\box\floatbox,
                      \s!default=>\hss\box\floatbox\hss,
                      \s!unknown=>\hss\box\floatbox\hss]}%
              \fi
              \showmessage\m!columns{13}\empty
            \else
              \page_floats_flush\s!text\plusone
              \ifdim\floatwidth>\finalcolumntextwidth % better somewhere else too
                \global\setbox\floatbox\hbox to \finalcolumntextwidth{\hss\box\floatbox\hss}%
              \fi % otherwise the graphic may disappear
            % \showmessage\m!columns{13}\empty
            \fi
            \ifdim\ht\floatbox>\zeropoint\relax
              \global\setbox\currenttopcolumnbox\vbox
                {\snaptogrid\vbox
                   {\box\currenttopcolumnbox % was copy
                    \box\floatbox}
                 \whitespace % nodig ?
                 \blank[\rootfloatparameter\c!spaceafter]}%
            \fi
            \dimen6\htdp\currenttopcolumnbox
          \fi
          \ifdim\dimen4<\ht\currenttopcolumnbox
            \dimen4\ht\currenttopcolumnbox
          \fi
          \advance\dimen8 \dimen6
          \advance\count2 \minusone
          \advance\count0 \minusone }%
       \page_otr_command_set_vsize
       \global\advance\vsize -\dimen8
       \global\pagegoal\vsize
     \else
       % \page_mul_command_flush_floats % does not snap!
     \fi
     \egroup
   \fi}

%D The next macro can be used to flush floats in the current stream. No
%D width checking is (yet) done.

\def\insertcolumnfloats
  {\doloop
     {\ifconditional\c_page_floats_some_waiting
        \bgroup
        \forgetall
        % no check for width
        \page_floats_get
        \blank[\rootfloatparameter\c!spacebefore]
        \snaptogrid\vbox{\copy\floatbox}
        \blank[\rootfloatparameter\c!spaceafter]
        \egroup
      \else
        \exitloop
      \fi}}

%D This were the multi||column routines. They can and need to be improved
%D but at the moment their behaviour is acceptable.
%D
%D One inprovement can be to normalize the height of floats to $ n \times $
%D \type {\lineheight} with a macro like:
%D
%D \starttyping
%D \normalizevbox{...}
%D \stoptyping

% border case, should fit on one page
%
% \startcolumns
% 1 \input tufte  \par \placefigure{}{\framed[width=\hsize,height=3cm]{1}}
% 2 \input tufte  \par \placefigure{}{\framed[width=\hsize,height=3cm]{2}}
% 3 \input tufte  \par \placefigure{}{\framed[width=\hsize,height=3cm]{3}}
% \stopcolumns

\unexpanded\def\setupcolumns
  {\dosingleempty\dosetupcolumns}

\def\dosetupcolumns[#1]%
  {\getparameters[\??kl][#1]%
   \nofcolumns\@@kln\relax
   \processaction
     [\@@klrule]
     [     \v!on=>\let\betweencolumns\linebetweencolumns,
          \v!off=>\let\betweencolumns\spacebetweencolumns,
      \s!default=>\let\betweencolumns\spacebetweencolumns,
      \s!unknown=>\let\betweencolumns\@@klrule]}

\def\linebetweencolumns
  {\bgroup
   \starttextproperties
   \ifdim\@@kldistance>\zeropoint
     \dimen0=\@@kldistance
   \else
     \dimen0=\linewidth
   \fi
   \advance\dimen0 -\linewidth
   \hskip.5\dimen0
   \vrule
     \!!width\linewidth
     \ifnum\bottomraggednessmode=\plustwo % baselinebottom
       \!!depth\strutdepth
     \fi
   \hskip.5\dimen0\relax
   \stoptextproperties
   \egroup}

\def\spacebetweencolumns
  {\hskip\@@kldistance}

\presetlocalframed[\??kl]

\def\backgroundfinishcolumnbox
  {\doifinsetelse\@@kloffset{\v!none,\v!overlay}
     {\let\@@kloffset\!!zeropoint}
     {\scratchdimen\@@kloffset
      \advance\scratchdimen -\@@klrulethickness
      \edef\@@kloffset{\the\scratchdimen}}%
   \localframed
     [\??kl]
     [\c!strut=\v!no,
      \c!width=\v!fit,
      \c!height=\v!fit,
      \c!align=]}

\definecomplexorsimpleempty\startcolumns

% to be reconsidered ... (in any case they need to be unexpandable sinze 2011.12.30)

\unexpanded\def\page_columns_align_option_yes {\stretchcolumnstrue \inheritcolumnsfalse}% todo: new key
\unexpanded\def\page_columns_align_option_no  {\stretchcolumnsfalse\inheritcolumnsfalse}% todo: new key
\unexpanded\def\page_columns_align_option_text{\stretchcolumnsfalse\inheritcolumnstrue }%

\def\complexstartcolumns[#1]% %% \startcolumns
  {\bgroup
   \let\stopcolumns\egroup
   \ifinsidecolumns
   \else
     \setupcolumns[#1]%
     \ifnum\@@kln>1\relax
       \whitespace
       \begingroup
       \doif\@@kloption\v!background
         {\let\finishcolumnbox\backgroundfinishcolumnbox
          \let\columntextoffset\@@kloffset}%
       \ifx\@@klcommand\empty\else
         \let\postprocesscolumnline\@@klcommand
       \fi
       \doifelsenothing\@@klheight
         \heightencolumnsfalse
         \heightencolumnstrue
       \doifelse\@@kldirection\v!right
         \reversecolumnsfalse
         \reversecolumnstrue
       \doifelse\@@klbalance\v!yes
         \balancecolumnstrue
         \balancecolumnsfalse
       \installalign\v!yes {\page_columns_align_option_yes }%
       \installalign\v!no  {\page_columns_align_option_no  }%
       \installalign\v!text{\page_columns_align_option_text}%
       \stretchcolumnsfalse
       \inheritcolumnstrue
       \doifsomething\@@klalign{\expanded{\setupalign[\@@klalign]}}%
       \nofcolumns\@@kln
       \edef\fixedcolumnheight{\@@klheight}%
       \edef\minbalancetoplines{\@@klntop}%
       \setuptolerance[\@@kltolerance]%     %% \startcolumns
       \setupblank[\@@klblank]%
       \ifdim\s_spac_whitespace_parskip>\zeropoint\relax
         \setupwhitespace[\@@klblank]%
       \fi
       \unexpanded\def\stopcolumns
         {\endmulticolumns
          \global\insidecolumnsfalse
          \endgroup
          \egroup}%
       \global\insidecolumnstrue
       \beginmulticolumns
     \fi
   \fi}

\installcolumnbreakmethod \s!multicolumn \v!preference
  {\goodbreak}

\installcolumnbreakmethod \s!multicolumn \v!yes
  {\par                                             % todo: since
   {\testrulewidth\zeropoint\ruledvskip\textheight} % we misuse a
   \penalty-200                                     % side effect
   \vskip-\textheight
   }% bugged : \prevdepth-\thousandpoint} % signals top of column to \blank

%D New: only at start of columns; may change ! Rather interwoven and therefore
%D to be integrated when the multi column modules are merged.

\unexpanded\def\setupcolumnspan[#1]%
  {\getparameters[\??ks][#1]}

\presetlocalframed
  [\??ks]

\setupcolumnspan
  [\c!n=2,
   \c!offset=\v!overlay,
   \c!frame=\v!off]

\newbox\b_page_columns_span \let\postprocesscolumnspanbox\gobbleoneargument

\def\dostartcolumnspan[#1]%
  {\bgroup
   \setupcolumnspan[#1]%
   \forgetall
   \ifinsidecolumns
     \advance\hsize \intercolumnwidth
     \hsize\@@ksn\hsize
     \advance\hsize -\intercolumnwidth
   \fi
   \dowithnextboxcs\dofinishcolumnsetspan\vbox\bgroup
     %\topskipcorrection % becomes an option !
     \EveryPar{\begstrut\EveryPar{}}} % also !

\def\dofinishcolumnsetspan
  {\setbox\b_page_columns_span\flushnextbox
   \ifinsidecolumns\wd\b_page_columns_span\hsize\fi
   \postprocesscolumnspanbox\b_page_columns_span
   \scratchdimen\ht\b_page_columns_span
   \setbox\b_page_columns_span\hbox % depth to be checked, probably option!
     {\localframed[\??ks][\c!offset=\v!overlay]{\box\b_page_columns_span}}%
   \ht\b_page_columns_span\scratchdimen
   \dp\b_page_columns_span\strutdp
   \wd\b_page_columns_span\hsize
   \ifinsidecolumns
     \ifnum\@@ksn>1
       \page_otr_command_set_vsize
       \dohandleallcolumns
         {\ifnum\currentcolumn>\@@ksn\else
            \global\setbox\currenttopcolumnbox=\vbox
              {\ifnum\currentcolumn=1
                 \snaptogrid\vbox{\copy\b_page_columns_span}
               \else
                 \snaptogrid\vbox{\vphantom{\copy\b_page_columns_span}}
               \fi}%
            \wd\currenttopcolumnbox\hsize
            \global\advance\vsize -\ht\currenttopcolumnbox
          \fi}
       \global\pagegoal\vsize
     \else
       \snaptogrid\vbox{\box\b_page_columns_span}
     \fi
   \else
     \snaptogrid\vbox{\box\b_page_columns_span}
   \fi
   \endgraf
   \ifvmode\prevdepth\strutdp\fi
   \egroup}

\unexpanded\def\startcolumnspan
  {\dosingleempty\dostartcolumnspan}

\unexpanded\def\stopcolumnspan
  {\egroup}

\setupcolumns
  [\c!n=2,
   \c!ntop=1,
   \c!command=,
   \c!direction=\v!right,
   \c!rule=\v!off,
   \c!tolerance=\v!tolerant,
   \c!distance=1.5\bodyfontsize, % influenced by switching
   \c!height=,
   \c!balance=\v!yes,
   \c!align=\v!text,
   \c!blank={\v!line,\v!fixed},
   \c!option=,
   \c!rulethickness=\linewidth,
   \c!offset=.5\bodyfontsize]

%D Undocumented and still under development.

\unexpanded\def\startsimplecolumns
  {\dosingleempty\dostartsimplecolumns}

\def\dostartsimplecolumns[#1]%
  {\bgroup
   \nopenalties
   \getparameters[\??kl]
     [\c!width=\hsize,\c!distance=1.5\bodyfontsize,%
      \c!n=2,\c!lines=0,#1]%
   \let\rigidcolumnlines\@@kllines
   \setrigidcolumnhsize\@@klwidth\@@kldistance\@@kln
   \setbox\scratchbox\vbox\bgroup
   \forgetall} % \blank[\v!disable]

\unexpanded\def\stopsimplecolumns
  {\removebottomthings
   \egroup
   \rigidcolumnbalance\scratchbox
   \egroup}

\unexpanded\def\setsimplecolumnshsize[#1]%
  {\getparameters[\??kl][\c!width=\hsize,\c!distance=1.5\bodyfontsize,\c!n=2,\c!lines=0,#1]%
   \let\rigidcolumnlines\@@kllines
   \setrigidcolumnhsize\@@klwidth\@@kldistance\@@kln}

\let\page_mul_command_package_contents\page_one_command_package_contents
\let\page_mul_command_flush_float_box \page_one_command_flush_float_box

\defineoutputroutine
  [\s!multicolumn]
  [\s!page_otr_command_routine                  =\page_mul_command_routine,
   \s!page_otr_command_package_contents         =\page_mul_command_package_contents,
   \s!page_otr_command_set_vsize                =\page_mul_command_set_vsize,
   \s!page_otr_command_set_hsize                =\page_mul_command_set_hsize,
   \s!page_otr_command_next_page                =\page_mul_command_next_page,
   \s!page_otr_command_next_page_and_inserts    =\page_mul_command_next_page_and_inserts,
 % \s!page_otr_command_synchronize_hsize        =\page_mul_command_synchronize_hsize,
 % \s!page_otr_command_set_top_insertions       =\page_mul_command_set_top_insertions,
 % \s!page_otr_command_set_bottom_insertions    =\page_mul_command_set_bottom_insertions,
   \s!page_otr_command_flush_top_insertions     =\page_mul_command_flush_top_insertions,
 % \s!page_otr_command_flush_bottom_insertions  =\page_mul_command_flush_bottom_insertions,
 % \s!page_otr_command_set_float_hsize          =\page_mul_command_set_float_hsize,
   \s!page_otr_command_check_if_float_fits      =\page_mul_command_check_if_float_fits,
   \s!page_otr_command_flush_float_box          =\page_mul_command_flush_float_box,
   \s!page_otr_command_synchronize_side_floats  =\page_mul_command_synchronize_side_floats,
   \s!page_otr_command_side_float_output        =\page_mul_command_side_float_output,
   \s!page_otr_command_flush_floats             =\page_mul_command_flush_floats,
   \s!page_otr_command_flush_side_floats        =\page_mul_command_flush_side_floats,
   \s!page_otr_command_flush_saved_floats       =\page_mul_command_flush_saved_floats
 % \s!page_otr_command_flush_margin_blocks      =\page_mul_command_flush_margin_blocks, % not used
  ]

\protect \endinput
