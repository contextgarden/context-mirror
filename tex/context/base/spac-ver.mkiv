%D \module
%D   [       file=spac-ver,
%D        version=2009.10.16, % 1997.03.31, was core-spa.tex
%D          title=\CONTEXT\ Spacing Macros,
%D       subtitle=Vertical,
%D         author=Hans Hagen,
%D           date=\currentdate,
%D      copyright={PRAGMA ADE \& \CONTEXT\ Development Team}]
%C
%C This module is part of the \CONTEXT\ macro||package and is
%C therefore copyrighted by \PRAGMA. See mreadme.pdf for
%C details.

\writestatus{loading}{ConTeXt Spacing Macros / Vertical}

\unprotect

\registerctxluafile{spac-ver}{1.001}

% Isn't it about time to get rid of topskip i.e. make it equivalent to
% \openstrutheight so that we can remove delta code.

%D There are two ways to influence the interline spacing. The
%D most general and often most consistent way is using
%D
%D \showsetup{setupinterlinespace}
%D
%D For instance
%D
%D \starttyping
%D \setupinterlinespace[line=2.8ex]
%D \stoptyping
%D
%D This setting adapts itself to the bodyfontsize, while for
%D instance saying
%D
%D \starttyping
%D \setupinterlinespace[line=12pt]
%D \stoptyping
%D
%D sets things fixed for all sizes, which is definitely not
%D what we want. Therefore one can also say:
%D
%D \starttyping
%D \definebodyfontenvironment[9pt][interlinespace=11pt]
%D \stoptyping
%D
%D One can still use \type{\setupinterlinespace} (without
%D arguments) to set the interline space according to the
%D current font, e.g. a \type{\bfa}.

% will be cleaned up but it will stay messy because we accept so
% many variants

\newif\iflocalinterlinespace

\newskip\s_spac_vspacing_temp \s_spac_vspacing_temp\bigskipamount

\def\skipfactor    {.75}
\def\skipgluefactor{.25}

\def\normalskipamount
  {\openlineheight
     \ifgridsnapping \else \ifblankflexible
       \!!plus \skipgluefactor\openlineheight
       \!!minus\skipgluefactor\openlineheight
     \fi \fi
   \relax}

\ifdefined\bodyfontinterlinespace \else
  \let\bodyfontinterlinespace\empty
\fi

\unexpanded\def\presetnormallineheight % each bodyfont
  {\edef\normallineheight{\interlinespaceparameter\c!line}%
   \iflocalinterlinespace \else
     \edef\m_spac_normallineheight{\bodyfontinterlinespace}%
     \ifx\m_spac_normallineheight\empty \else
       \let\normallineheight\m_spac_normallineheight
     \fi
   \fi}

\unexpanded\def\setupspecifiedinterlinespace[#1]%
  {\setupcurrentinterlinespace[#1]%
   \spac_linespacing_setup_specified_interline_space}

\def\spac_linespacing_setup_specified_interline_space
  {\edef\strutheightfactor  {\interlinespaceparameter\c!height   }%
   \edef\strutdepthfactor   {\interlinespaceparameter\c!depth    }%
   \edef\minimumstrutheight {\interlinespaceparameter\c!minheight}%
   \edef\minimumstrutdepth  {\interlinespaceparameter\c!mindepth }%
   \edef\minimumlinedistance{\interlinespaceparameter\c!distance }%
   \edef\normallineheight   {\interlinespaceparameter\c!line     }%
   \edef\topskipfactor      {\interlinespaceparameter\c!top      }%
   \edef\maxdepthfactor     {\interlinespaceparameter\c!bottom   }%
   \edef\baselinegluefactor {\interlinespaceparameter\c!stretch  }%
   % often topskip does more bad than good, so:
   \ifx\topskipfactor\v!height
     \let\topskipfactor\strutheightfactor
   \fi
   \setfontparameters % redundant, can be \setstrut, test first
   \updateraggedskips} % yes indeed

\installcorenamespace{interlinespacerelative}

\let\setrelativeinterlinespace    \relax % used elsewhere
\let\currentrelativeinterlinespace\empty

\setvalue{\??interlinespacerelative\v!on   }{\oninterlineskip}
\setvalue{\??interlinespacerelative\v!off  }{\offinterlineskip}
\setvalue{\??interlinespacerelative\v!reset}{\let\currentrelativeinterlinespace\empty
                                             \let\setrelativeinterlinespace\relax
                                             \setfontparameters}
\setvalue{\??interlinespacerelative\v!auto }{\let\setrelativeinterlinespace\spac_linespacing_set_relative_interlinespace}

\def\spac_linespacing_set_specified_relative_interlinespace#1% fragile?
  {\doifdimenstringelse{#1}
     {\setupspecifiedinterlinespace[\c!line=#1]}
     {\assignvalue{#1}\currentrelativeinterlinespace{1.00}{1.25}{1.50}%
      \spacing\currentrelativeinterlinespace}}

\unexpanded\def\setuprelativeinterlinespace[#1]%
  {\processcommalist[#1]\spac_linespacing_setup_relative_interlinespace}

\def\spac_linespacing_setup_relative_interlinespace#1%
  {\ifcsname\??interlinespacerelative#1\endcsname
     \csname\??interlinespacerelative#1\endcsname
   \else
     \spac_linespacing_set_specified_relative_interlinespace{#1}%
   \fi}

\def\spac_linespacing_set_relative_interlinespace
  {\ifx\currentrelativeinterlinespace\empty\else
     \spacing\currentrelativeinterlinespace
   \fi}

\newtoks\everysetupglobalinterlinespace
\newtoks\everysetuplocalinterlinespace

\newconditional\interlinespaceisset

\installcorenamespace{interlinespace}

\installcommandhandler \??interlinespace {interlinespace} \??interlinespace

\unexpanded\def\setupinterlinespace
  {\dodoubleempty\spac_linespacing_setup}

\def\spac_linespacing_setup[#1][#2]%
  {\settrue\interlinespaceisset % reset has to be done when needed
   \ifsecondargument
     \setup_interlinespace[#1][#2]%
   \else\iffirstargument
     \ifcsname\namedinterlinespacehash{#1}\s!parent\endcsname
        \edef\currentinterlinespace{#1}%
        \spac_linespacing_setup_specified_interline_space
       %\dosetupspecifiedinterlinespaceindeed
     \else
       \space_linespacing_setup_specified_or_relative[#1]%
     \fi
   \else
     \let\currentinterlinespace\empty
     \space_linespacing_synchronize_local
   \fi\fi}

\def\space_linespacing_setup_specified_or_relative[#1]%
  {\doifassignmentelse{#1}\setupspecifiedinterlinespace\setuprelativeinterlinespace[#1]%
   \the\iflocalinterlinespace\everysetuplocalinterlinespace\else\everysetupglobalinterlinespace\fi}

\def\space_linespacing_synchronize_local % adapts to the font
  {\localinterlinespacetrue
   \setfontparameters
   \updateraggedskips % funny one here
   \the\everysetuplocalinterlinespace
   \localinterlinespacefalse}

\def\dosetupcheckedinterlinespace#1% often a chain
  {\edef\askedinterlinespace{#1}%
   \ifx\askedinterlinespace\empty
     \space_linespacing_synchronize_local
   \else\ifcsname\namedinterlinespacehash\askedinterlinespace\s!parent\endcsname % we could have a \s!check
     \pushmacro\currentinterlinespace
     \let\currentinterlinespace\askedinterlinespace
     \spac_linespacing_setup_specified_interline_space % \dosetupspecifiedinterlinespaceindeed
     \iflocalinterlinespace
       \the\everysetuplocalinterlinespace
     \else
       \localinterlinespacetrue
       \the\everysetuplocalinterlinespace
       \localinterlinespacefalse
     \fi
     \popmacro\currentinterlinespace
   \else
     \normalexpanded{\noexpand\doifassignmentelse{\askedinterlinespace}%
       \setupspecifiedinterlinespace\setuprelativeinterlinespace[\askedinterlinespace]}%
     \iflocalinterlinespace
       \the\everysetuplocalinterlinespace
     \else
       \localinterlinespacetrue
       \the\everysetuplocalinterlinespace
       \localinterlinespacefalse
     \fi
   \fi\fi}

\unexpanded\def\setuplocalinterlinespace[#1]%
  {\localinterlinespacetrue
   \pushmacro\currentinterlinespace
   \setupinterlinespace[#1]%
   \popmacro\currentinterlinespace
   \localinterlinespacefalse}

\let\switchtointerlinespace\setuplocalinterlinespace

% \definecomplexorsimple\setupinterlinespace

%D Helpers

\newskip \s_spac_lastskip
\newdimen\d_spac_prevdepth
\newcount\c_spac_spacefactor

\unexpanded\def\removelastskip
  {\ifvmode\ifdim\lastskip=\zeropoint\else\vskip-\lastskip\fi\fi}

\def\doifoutervmode
  {\ifvmode
     \ifinner
       \doubleexpandafter\gobbleoneargument
     \else
       \doubleexpandafter\firstofoneargument
     \fi
   \else
     \expandafter\gobbleoneargument
   \fi}

\unexpanded\def\dosomebreak#1%
  {\doifoutervmode
     {\s_spac_lastskip\lastskip
      \removelastskip
      #1\relax
      \ifdim\s_spac_lastskip=\zeropoint
        % avoid interference with footnotes
      \else
        \vskip\s_spac_lastskip
      \fi}}

\unexpanded\def\packed
  {\nointerlineskip}

\unexpanded\def\godown[#1]%
  {\relax
   \ifhmode\endgraf\fi
   \ifvmode\nointerlineskip\vskip#1\relax\fi}

\unexpanded\def\smallskip{\vskip\smallskipamount}
\unexpanded\def\medskip  {\vskip\medskipamount}
\unexpanded\def\bigskip  {\vskip\bigskipamount}

\unexpanded\def\smallbreak
  {\par
   \ifdim\lastskip<\smallskipamount
     \removelastskip
     \penalty-50
     \smallskip
   \fi}

\unexpanded\def\medbreak
  {\par
   \ifdim\lastskip<\medskipamount
     \removelastskip
     \penalty-100
     \medskip
   \fi}

\unexpanded\def\bigbreak
  {\par
   \ifdim\lastskip<\bigskipamount
     \removelastskip
     \penalty-200
     \bigskip
   \fi}

\unexpanded\def\break     {\penalty-\plustenthousand}     % can be hmode or vmode
\unexpanded\def\nobreak   {\penalty \plustenthousand}     % can be hmode or vmode
\unexpanded\def\allowbreak{\penalty \zeropoint}           % can be hmode or vmode
\unexpanded\def\goodbreak {\par\penalty-500\relax}        % forces vmode
\unexpanded\def\filbreak  {\par\vfil\penalty-200\vfilneg} % forces vmode

%D Made slightly more readable:

\unexpanded\def\vglue  {\afterassignment\spac_helpers_vglue_indeed\s_spac_lastskip=}
\unexpanded\def\hglue  {\afterassignment\spac_helpers_hglue_indeed\s_spac_lastskip=}
\unexpanded\def\topglue{\nointerlineskip\vglue-\topskip\vglue}

\def\spac_helpers_vglue_indeed
  {\par
   \d_spac_prevdepth\prevdepth
   \hrule\!!height\zeropoint
   \nobreak
   \vskip\s_spac_lastskip
   \prevdepth\d_spac_prevdepth}

\def\spac_helpers_hglue_indeed
  {\dontleavehmode % \leavevmode
   \c_spac_spacefactor\spacefactor
   \vrule\!!width\zeropoint
   \nobreak
   \hskip\s_spac_lastskip
   \spacefactor\c_spac_spacefactor}

%D We adapt plain's \type {\removelastskip} a bit:

\unexpanded\def\removelastskip % also in supp-box
  {\ifvmode\ifzeropt\lastskip\else\vskip-\lastskip\fi\fi}

% The whitespace handler.

\installcorenamespace{whitespacemethod}

\newskip        \ctxparskip         \ctxparskip\zeropoint
\newconditional \flexiblewhitespace \settrue\flexiblewhitespace

\def\currentwhitespace{\zeropoint}

\definecomplexorsimple\setupwhitespace

\def\simplesetupwhitespace
  {\doifnot\currentwhitespace\v!none\spac_whitespace_setup}

\def\complexsetupwhitespace[#1]%
  {\edef\nextcurrentwhitespace{#1}%
   \ifx\nextcurrentwhitespace\empty
     \simplesetupwhitespace
   \else
     \let\currentwhitespace\nextcurrentwhitespace
     \spac_whitespace_setup
   \fi}

\newconstant\baselinegridmode % option in layout / 1=permit_half_lines

\def\spac_whitespace_setup % quick test for no list
  {\ifcsname\??whitespacemethod\currentwhitespace\endcsname
     \csname\??whitespacemethod\currentwhitespace\endcsname
   \else
     \expandafter\processcommalist\expandafter[\currentwhitespace]\spac_whitespace_setup_method % can be raw
   \fi\relax
   \ifgridsnapping
     \spac_whitespace_setup_grid
   \else
     \spac_whitespace_setup_normal
   \fi
   \parskip\ctxparskip}

\def\spac_whitespace_setup_normal
  {\ifconditional\flexiblewhitespace \else
     \ctxparskip1\ctxparskip
   \fi}

\def\spac_whitespace_setup_grid
  {\setfalse\flexiblewhitespace
   \ifdim\ctxparskip>\zeropoint
     \ctxparskip
       \ifcase\baselinegridmode
         \baselineskip % normal ! ! ! ! !!
       \or
         \ifdim\scratchdimen=\baselineskip % maybe range
           \baselineskip % normal ! ! ! ! !!
         \else
           \numexpr\ctxparskip/\dimexpr.5\lineheight\relax\relax\dimexpr.5\lineheight\relax
         \fi
       \else
         \baselineskip % normal ! ! ! ! !!
       \fi
   \fi}

% this will become \installwhitespacemethod{}{}

\unexpanded\def\definewhitespacemethod[#1]#2{\setvalue{\??whitespacemethod#1}{#2}}

\definewhitespacemethod [\v!fix]      {}
\definewhitespacemethod [\v!fixed]    {\setfalse\flexiblewhitespace}
\definewhitespacemethod [\v!flexible] {\settrue \flexiblewhitespace}

\definewhitespacemethod [\v!line]     {\ctxparskip  \baselineskip}
\definewhitespacemethod [\v!halfline] {\ctxparskip.5\baselineskip}
\definewhitespacemethod [\v!none]     {\ctxparskip  \zeropoint}
\definewhitespacemethod [\v!big]      {\ctxparskip  \bigskipamount}
\definewhitespacemethod [\v!medium]   {\ctxparskip  \medskipamount}
\definewhitespacemethod [\v!small]    {\ctxparskip  \smallskipamount}

\definewhitespacemethod [\s!default]  {\simplesetupwhitespace}

\def\spac_whitespace_setup_method#1%
  {\ifcsname\??whitespacemethod#1\endcsname
     \csname\??whitespacemethod#1\endcsname
   \else
     \ctxparskip#1\fi
   \relax}

% \definewhitespacemethod [\s!unknown]  {\ctxparskip\commalistelement\relax}
%
% \def\spac_whitespace_setup_method#1%
%   {\csname\??whitespacemethod\ifcsname\??whitespacemethod#1\endcsname#1\else\s!unknown\endcsname\relax}

\unexpanded\def\nowhitespace{\vspacing[\v!nowhite]}
\unexpanded\def\whitespace  {\vspacing[\v!white]}

% De onderstaande macro handelt ook de situatie dat er geen
% tekst tussen \start ... \stop is geplaatst. Daartoe wordt de
% laatste skip over de lege tekst heen gehaald. Dit komt goed
% van pas bij het plaatsen van (mogelijk lege) lijsten.

\newconditional\noblankinpacked
\newcount      \c_spac_packed_level

\unexpanded\def\startpacked
  {\dosingleempty\spac_packed_start}

\def\spac_packed_start[#1]% nesting afvangen
  {\global\advance\c_spac_packed_level\plusone
   \par
   \ifnum\c_spac_packed_level=\plusone \ifvmode
     \begingroup
     \whitespace % not combined
     \blank[\v!disable]%
     \doifelse{#1}\v!blank\setfalse\settrue\noblankinpacked
     \setupwhitespace[\v!none]%
   \fi \fi}

\unexpanded\def\stoppacked
  {\par
   \ifnum\c_spac_packed_level=\plusone \ifvmode
     \endgroup
   \fi \fi
   \global\advance\c_spac_packed_level\minusone}

\unexpanded\def\startunpacked
  {\blank
   \begingroup}

\unexpanded\def\stopunpacked
  {\endgroup
   \blank}

% \prevdepth crosses pageboundaries!
%
% todo: a version that works ok inside a box

\let\doaroundlinecorrection\relax

\unexpanded\def\startlinecorrection
  {\dodoubleempty\dostartlinecorrection}

\def\dostartlinecorrection[#1][#2]% #2 gobbles spaces
  {\bgroup
   \processaction
     [#1]
     [  \v!blank=>\let\doaroundlinecorrection\blank,
      \s!default=>\let\doaroundlinecorrection\relax,
      \s!unknown=>{\def\doaroundlinecorrection{\blank[#1]}}]%
   \doaroundlinecorrection
   \startbaselinecorrection
   \offbaselinecorrection
   \ignorespaces}

\unexpanded\def\stoplinecorrection
  {\stopbaselinecorrection
   \doaroundlinecorrection
   \egroup}

\unexpanded\def\correctwhitespace
  {\dowithnextboxcs\correctwhitespacefinish\vbox}

\def\correctwhitespacefinish
  {\startbaselinecorrection
   \flushnextbox
   \stopbaselinecorrection}

\unexpanded\def\verticalstrut  {\vbox{\hsize\zeropoint\forgetall\strut}}
\unexpanded\def\horizontalstrut{\hbox                          {\strut}}

% Hieronder volgen enkele instellingen en macro's ten behoeve
% van de interlinie en \strut. De waarden 2.8, 0.07, 0.72 en
% 0.28 zijn ooit eens ontleend aan INRS-TEX en moeten wellicht
% nog eens instelbaar worden.
%
%   \lineheight        : de hoogte van een regel
%   \spacing{getal}    : instellen interlinie
%   \normalbaselines   : instellen regelafstend
%
%   \setstrut          : instellen \strut
%   \setnostrut        : resetten \strut, \endstrut, \begstrut
%
%   \setteststrut      : instellen zichtbare struts
%   \resetteststrut    : instellen onzichtbare struts
%
%   \setfontparameters : instellen na fontset
%
% De hoogte van een regel (\lineheight) is gelijk aan de
% som van de hoogte (\ht) en diepte (\dp) van \strutbox.
%
%   \strut            : denkbeeldig blokje met hoogte en diepte
%
% Een \hbox kan als deze aan het begin van een regel staat
% een breedte \hsize krijgen. Dit is soms te voorkomen met het
% commando \leavevmode. Binnen een \vbox geeft dit echter
% niet altijd het gewenste resultaat, vandaar het commando
%
%   \dontleavehmode

% Pas op: niet zomaar \topskip en \baselineskip aanpassen
% en zeker niet \widowpenalty. Dit kan ernstige gevolgen
% hebben voor kolommen.
%
% Enige glue kan op zich geen kwaad, echter als blanko=vast,
% dan moet ook de rek 0 zijn. Binnen kolommen is rek ook
% niet bepaald mooi. Een hele kleine waarde (0.025) voldoet,
% omdat een positieve glue eindeloos rekbaar is.

\newdimen\strutdimen
\newdimen\lineheight
\newdimen\openlineheight
\newdimen\openstrutheight
\newdimen\openstrutdepth
\newdimen\topskipgap
\newdimen\struttotal

\def\strutheightfactor      {.72}
\def\strutdepthfactor       {.28}

\def\baselinefactor         {2.8}
\def\baselinegluefactor     {0}

\def\minimumstrutheight     {\zeropoint}
\def\minimumstrutdepth      {\zeropoint}

\def\normallineheight       {\baselinefactor ex}
\def\minimumlinedistance    {\lineskip}

\def\strutheight            {\zeropoint}
\def\strutdepth             {\zeropoint}
\def\strutwidth             {\zeropoint}

\let\spacingfactor          \plusone

\def\topskipfactor          {1.0}
\def\maxdepthfactor         {0.5}

\def\systemtopskipfactor    {\topskipfactor}
\def\systemmaxdepthfactor   {\maxdepthfactor}

\ifdefined\globalbodyfontsize \else
    \newdimen\globalbodyfontsize
    \globalbodyfontsize=12pt
\fi

\ifdefined\normalizedbodyfontsize \else
    \def\normalizedbodyfontsize{12pt}
\fi

\def\topskipcorrection
  {\simpletopskipcorrection
   \vskip-\struttotal
   \verticalstrut}

\def\simpletopskipcorrection
  {\ifdim\topskip>\openstrutheight
     % == \vskip\topskipgap
     \vskip\topskip
     \vskip-\openstrutheight
   \fi}

\unexpanded\def\settopskip % the extra test is needed for the lbr family
  {\topskip
     \ifgridsnapping
       \zeropoint
     \else
       \systemtopskipfactor\globalbodyfontsize
       \ifcase\bottomraggednessmode % ragged bottom
         \!!plus5\globalbodyfontsize
       \fi
   \fi
   %\relax
   \topskipgap\topskip
   \advance\topskipgap -\openstrutheight\relax
   \ifdim\minimumstrutheight>\zeropoint
     \ifdim\topskip<\minimumstrutheight
       \topskip\minimumstrutheight\relax
     \fi
   \else
     \ifdim\topskip<\strutheightfactor\openlineheight
       \topskip\strutheightfactor\openlineheight\relax
     \fi
   \fi}

\unexpanded\def\setmaxdepth
  {\maxdepth\systemmaxdepthfactor\globalbodyfontsize}

\unexpanded\def\normalbaselines
  {\baselineskip \normalbaselineskip
   \lineskip     \normallineskip
   \lineskiplimit\normallineskiplimit}

\unexpanded\def\setnormalbaselines
  {\ifdim\normallineheight>\zeropoint
     \lineheight\normallineheight
   \fi
   \openlineheight\spacingfactor\lineheight
   \openstrutheight \ifdim\minimumstrutheight>\zeropoint
     \minimumstrutheight % new
   \else
     \strutheightfactor\openlineheight
   \fi
   \openstrutdepth \ifdim\minimumstrutdepth>\zeropoint
     \minimumstrutdepth % new
   \else
     \strutdepthfactor \openlineheight
   \fi
   \ifdim\dimexpr\minimumstrutdepth+\minimumstrutheight\relax>\zeropoint
     \openlineheight\dimexpr\openstrutheight+\openstrutdepth\relax % new
   \fi
   \normalbaselineskip\openlineheight
     \ifgridsnapping\else
       \!!plus \baselinegluefactor\openlineheight
       \!!minus\baselinegluefactor\openlineheight
     \fi
   \normallineskip\minimumlinedistance\relax % \onepoint\relax
   \normallineskiplimit\zeropoint\relax
   \normalbaselines}

\unexpanded\def\spacing#1% vertical
  {\ifgridsnapping
     \let\spacingfactor\plusone
   \else
     \edef\spacingfactor{#1}%
   \fi
   \edef\systemtopskipfactor {\withoutpt\the\dimexpr#1\dimexpr\topskipfactor \points}%
   \edef\systemmaxdepthfactor{\withoutpt\the\dimexpr#1\dimexpr\maxdepthfactor\points}%
   \setnormalbaselines
   \setstrut}

%D Sometimes one needs to freeze the interlinespacing
%D
%D \starttyping
%D \rm \saveinterlinespace .... {\ss \restoreinterlinespace .... \endgraf}
%D \stoptyping

\let\restoreinterlinespace\relax

\def\saveinterlinespace
  {\edef\restoreinterlinespace
     {\lineheight         \the\lineheight
      \openstrutheight    \the\openstrutheight
      \openstrutdepth     \the\openstrutdepth
      \openlineheight     \the\openlineheight
      \normalbaselineskip \the\normalbaselineskip
      \normallineskip     \the\normallineskip
      \normallineskiplimit\the\normallineskiplimit
      \noexpand\def\noexpand\normallineheight{\the\dimexpr\normallineheight}%
      \noexpand\normalbaselines}}

% plain definition:
%
% \def\strut{\relax\ifmmode\copy\strutbox\else\unhcopy\strutbox\fi}
%
% could be:
%
% \def\strut{\relax\ifmmode\copy\else\unhcopy\fi\strutbox}

\newbox\strutbox

\setbox\strutbox\hbox{\vrule\!!height8.5pt\!!depth3.5pt\!!width\zeropoint} % just a start

\def\strut{\relax\ifmmode\copy\else\unhcopy\fi\strutbox}

\let\normalstrut\strut

% The double \hbox construction enables us to \backtrack
% boxes.

\let\strutht\undefined \newdimen\strutht
\let\strutdp\undefined \newdimen\strutdp

\unexpanded\def\setstrut
  {\ifgridsnapping
     \setstrutgridyes
   \else
     \setstrutgridnop
   \fi}

\unexpanded\def\setstrutgridyes
  {\strutht\spacingfactor\dimexpr
     \ifdim\minimumstrutheight>\zeropoint
       \minimumstrutheight
     \else
       \strutheightfactor\dimexpr\normallineheight
     \fi
   \strutdp\dimexpr
     \ifdim\minimumstrutdepth>\zeropoint
       \minimumstrutdepth
     \else
       \normallineheight-\strutht
     \fi
   \dosetstrut}

\unexpanded\def\setstrutgridnop
  {\strutht\spacingfactor\dimexpr
     \ifdim\minimumstrutheight>\zeropoint
       \minimumstrutheight
     \else
       \strutheightfactor\dimexpr\normallineheight
     \fi
   \strutdp\spacingfactor\dimexpr
       \ifdim\minimumstrutdepth>\zeropoint
         \minimumstrutdepth
       \else
         \strutdepthfactor\dimexpr\normallineheight
       \fi
   \dosetstrut}

\unexpanded\def\setcharstrut#1%
  {\setbox\strutbox\hbox{#1}%
   \strutht\ht\strutbox
   \strutdp\dp\strutbox
   \dosetstrut}

\unexpanded\def\setfontstrut
  {\setcharstrut{(gplQT}}

\unexpanded\def\setcapstrut% could be M, but Q has descender
  {\setcharstrut{Q}}

%D Handy for math (used in mathml):

\unexpanded\def\charhtstrut
  {\begingroup
   \setcharstrut{GJY}%
   \vrule\!!width\zeropoint\!!depth\zeropoint\!!height\strutht
   \endgroup}

\unexpanded\def\chardpstrut
  {\begingroup
   \setcharstrut{gjy}%
   \vrule\!!width\zeropoint\!!depth\strutdp\!!height\zeropoint
   \endgroup}

% because of all the callbacks in mkiv, we avoid unnecessary boxes ...
% maybe use an attribute so that we can tag boxes that don't need a
% treatment; tests with using an attribute so far have shown that
% it's slower because testing the attribute takes time too

\unexpanded\def\dosetstrut
  {\let\strut\normalstrut
   \ifabsnum\dimexpr\strutht+\strutdp-\lineheight\relax<\plustwo
     % compensate rounding error /- 1sp to avoid too many
     % 1sp baselineskips in for instance verbatim
     \strutht\dimexpr\lineheight-\strutdp\relax
     \struttotal\lineheight
   \else
     \struttotal\dimexpr\strutht+\strutdp\relax
   \fi
   \edef\strutheight{\the\strutht}%
   \edef\strutdepth {\the\strutdp}%
   \ifdim\strutwidth=\zeropoint
      \spac_struts_set_hide
   \else
      \spac_struts_set_vide
   \fi}

\def\spac_struts_set_hide
  {\setbox\strutbox\hbox
     {\vrule
        \!!width \zeropoint
        \!!height\strutht
        \!!depth \strutdp}}

\def\spac_struts_set_vide
  {\setbox\strutbox\hbox
     {\hbox to \zeropoint
        {% \hss % new, will be option
         \vrule
           \!!width \strutwidth
           \!!height\strutht
           \!!depth \strutdp
         \hss}}}

%D The dimen \type {\struttotal} holds the exact size of the
%D strut; occasionally a one scaled point difference can show
%D up with the lineheight.

% This is more efficient (less callbacks):

\newbox\b_spac_struts_empty \setbox\b_spac_struts_empty\emptyhbox

\def\spac_struts_set_hide
  {\setbox\strutbox\copy\b_spac_struts_empty
   \ht\strutbox\strutht
   \dp\strutbox\strutdp}

\unexpanded\def\strut % still callbacks for \hbox{\strut}
  {\relax
  \dontleavehmode
  \copy\strutbox}

\let\normalstrut\strut

%D Sometimes a capstrut comes in handy
%D
%D \starttabulate[|Tl|l|l|]
%D \NC yes          \NC normal strut               \NC {\showstruts\setupstrut[yes]\strut}  \NC \NR
%D \NC no           \NC no strut                   \NC {\showstruts\setupstrut[no]\strut}  \NC \NR
%D \NC kap          \NC a capital strut (i.e. Q)   \NC {\showstruts\setupstrut[cap]\strut} \NC \NR
%D \NC A B \unknown \NC a character strut (e.g. A) \NC {\showstruts\setupstrut[A]\strut}   \NC \NR
%D \NC              \NC a normal strut             \NC {\showstruts\setupstrut\strut}      \NC \NR
%D \stoptabulate

%D Beware: using an unknown value results in char struts.

\installcorenamespace{struts}

\unexpanded\def\setupstrut
  {\dosingleempty\spac_struts_setup}

\def\spac_struts_setup[#1]%
  {\ifcsname\??struts#1\endcsname
     \csname\??struts#1\endcsname % these are defined later
   \else
     \setcharstrut{#1}%
   \fi}

\def\synchronizestrut#1% no [] parsing, faster for internal
  {\ifcsname\??struts#1\endcsname
     \csname\??struts#1\endcsname
   \else
     \setcharstrut{#1}%
   \fi}

\unexpanded\def\showstruts
  {\setteststrut
   \settestcrlf}

\unexpanded\def\setteststrut
  {\def\strutwidth{.8pt}%
   \setstrut}

\def\autostrutfactor{1.1}

\unexpanded\def\setautostrut
  {\begingroup
   \setbox\scratchbox\copy\strutbox
   \setstrut
   \ifdim\strutht>\autostrutfactor\ht\scratchbox
     \endgroup \setstrut
   \else\ifdim\strutdp>\autostrutfactor\dp\scratchbox
     \endgroup \setstrut
   \else
     \endgroup
   \fi\fi}

\newbox\nostrutbox \setbox\nostrutbox\emptyhbox

\unexpanded\def\setnostrut
  {\setbox\strutbox\copy\nostrutbox
   \let\strut\empty
   \let\endstrut\empty
   \let\begstrut\empty
   \let\crlfplaceholder\empty}

% when enabled, sigstruts will remove themselves if nothing
% goes inbetween

\newsignal\strutsignal \setfalse\sigstruts

\unexpanded\def\begstrut
  {\relax\ifcase\strutht
     % \ignorespaces % maybe
   \else
     \spac_struts_beg
   \fi}

\def\spac_struts_beg
  {\ifconditional\sigstruts
     \spac_struts_beg_signal
   \else
     \spac_struts_beg_normal
   \fi
   \ignorespaces}

\def\spac_struts_beg_signal
  {\noindent\horizontalstrut
   \penalty\plustenthousand
   \hskip-\strutsignal
   \hskip\strutsignal}

\def\spac_struts_beg_normal
  {\strut
   \penalty\plustenthousand
   \hskip\zeropoint}

\unexpanded\def\endstrut
  {\relax\ifhmode
     \ifcase\strutht
       % \removeunwantedspaces % maybe
     \else
       \spac_struts_end
     \fi
   \fi}

\def\spac_struts_end
  {\ifconditional\sigstruts
     \spac_struts_end_signal
   \else
     \spac_struts_end_normal
   \fi}

\def\spac_struts_end_signal
  {\ifdim\lastskip=\strutsignal
     \unskip
     \unskip
     \unpenalty
     \setbox\scratchbox\lastbox
   \else
     \penalty\plustenthousand
     \hskip\zeropoint
     \strut
   \fi}

\def\spac_struts_end_normal
  {\removeunwantedspaces
   \penalty\plustenthousand
   \hskip\zeropoint
   \strut}

% unsave:
%
% \def\pseudostrut
%   {\bgroup
%    \setnostrut
%    \normalstrut
%    \egroup}
%
% try:
%
% \startchemie
%   \chemie[ONE,Z0,SB15,MOV1,SB15,Z0][C,C]
% \stopchemie
%
% so:

\unexpanded\def\pseudostrut
  {\noindent} % better: \dontleavehmode

\let\pseudobegstrut\pseudostrut
\let\pseudoendstrut\removeunwantedspaces

\unexpanded\def\resetteststrut
  {\def\strutwidth{\zeropoint}% no let
   \setstrut}

\ifdefined\setfontparameters \else
    \def\setfontparameters{\the\everybodyfont}
\fi

%D Keyword based strutting:

\letvalue{\??struts\v!yes    }\setstrut     % \setvalue{\??struts\v!yes    }{\setstrut}
\letvalue{\??struts\v!auto   }\setautostrut % \setvalue{\??struts\v!auto   }{\setautostrut}
\letvalue{\??struts\v!no     }\setnostrut   % \setvalue{\??struts\v!no     }{\setnostrut}
\letvalue{\??struts\v!cap    }\setcapstrut  % \setvalue{\??struts\v!cap    }{\setcapstrut}
\letvalue{\??struts\v!fit    }\setfontstrut % \setvalue{\??struts\v!fit    }{\setfontstrut}
\letvalue{\??struts\v!line   }\setstrut     % \setvalue{\??struts\v!line   }{\setstrut}
\letvalue{\??struts\s!default}\setstrut     % \setvalue{\??struts\s!default}{\setstrut}
\letvalue{\??struts\empty    }\setstrut     % \setvalue{\??struts\empty    }{\setstrut}

%D Handy:

\def\baselinedistance{\the\lineheight}

%D We need \type{\normaloffinterlineskip} because the new
%D definition contains an assignment, and |<|don't ask me
%D why|>| this assignment gives troubles in for instance the
%D visual debugger.

\unexpanded\def\offinterlineskip
  {\baselineskip-\thousandpoint
   \lineskip\zeropoint
   \lineskiplimit\maxdimen
   % We also need this here now; thanks to taco for figuring that out!
   \def\minimumlinedistance{\zeropoint}}

\unexpanded\def\nointerlineskip
  {\prevdepth-\thousandpoint}

\let\normaloffinterlineskip\offinterlineskip % knuth's original

%D My own one:

\unexpanded\def\dopushinterlineskip
  {\edef\oninterlineskip
     {\baselineskip\the\baselineskip
      \lineskip\the\lineskip
      \lineskiplimit\the\lineskiplimit
      \noexpand\edef\noexpand\minimumlinedistance{\the\dimexpr\minimumlinedistance}%
      \let\noexpand\offinterlineskip\noexpand\normaloffinterlineskip}} % \noexpand not needed

\unexpanded\def\nopushinterlineskip
  {\let\oninterlineskip\setnormalbaselines}

\unexpanded\def\offinterlineskip
  {\ifdim\baselineskip>\zeropoint
     \dopushinterlineskip
   \else
     \nopushinterlineskip
   \fi
   \normaloffinterlineskip}

\let\oninterlineskip\relax

\unexpanded\def\leaveoutervmode
  {\ifvmode\ifinner\else
     \leavevmode
   \fi\fi}

\unexpanded\def\resetpenalties#1%
  {\ifdefined#1%
     #1\minusone
   \fi}

\unexpanded\def\setpenalties#1#2#3%
  {\ifdefined#1% space before #3 prevents lookahead problems, needed when #3=text
     #1\numexpr#2+\plusone\relax\space\doexpandedrecurse{\the\numexpr#2\relax}{ #3}\zerocount\relax
   \fi}

\def\doexpandedrecurse#1#2%
  {\ifnum#1>\zerocount#2\@EA\doexpandedrecurse\@EA{\the\numexpr#1-1\relax}{#2}\fi}

%D \macros
%D   {keeplinestogether}
%D
%D Dirty hack, needed in margin content that can run of a page.

% just before margintexts ... will eventually be done differently in mkiv using
% attributes

\newcount\nofkeeplinestogether
\let\restoreinterlinepenalty\relax

\unexpanded\def\dorestoreinterlinepenalty
  {\global\let\restoreinterlinepenalty\relax
   \global\resetpenalties\interlinepenalties
   \global\nofkeeplinestogether\zerocount}

\unexpanded\def\keeplinestogether#1%
  {\ifnum#1>\nofkeeplinestogether
     \global\nofkeeplinestogether#1%
     \global\setpenalties\interlinepenalties\nofkeeplinestogether\plustenthousand
     \global\let\restoreinterlinepenalty\dorestoreinterlinepenalty
   \fi}

\newif\ifgridsnapping % to be sure

\def\defaultwidowpenalty         {2000} % was: 1000
\def\defaultclubpenalty          {2000} % was:  800
\def\defaultdisplaywidowpenalty    {50}
\def\defaultbrokenpenalty         {100}

\def\defaultgridwidowpenalty        {0}
\def\defaultgridclubpenalty         {0}
\def\defaultgriddisplaywidowpenalty {0}
\def\defaultgridbrokenpenalty       {0}

\unexpanded\def\nopenalties
  {\widowpenalty        \zerocount
   \clubpenalty         \zerocount
   \brokenpenalty       \zerocount
   \doublehyphendemerits\zerocount
   \finalhyphendemerits \zerocount
   \adjdemerits         \zerocount}

\unexpanded\def\setdefaultpenalties
  {\directsetup{\systemsetupsprefix\s!default}}

\startsetups [\systemsetupsprefix\s!reset]
    \resetpenalties\widowpenalties
    \resetpenalties\clubpenalties
    \resetpenalties\interlinepenalties
\stopsetups

% we use \directsetup because it's faster and we know there is no csl

\startsetups [\systemsetupsprefix\s!default]

    \directsetup{\systemsetupsprefix\s!reset}

    \widowpenalty       \defaultwidowpenalty
    \clubpenalty        \defaultclubpenalty
    \displaywidowpenalty\defaultdisplaywidowpenalty
    \brokenpenalty      \defaultbrokenpenalty

\stopsetups

\startsetups [\v!grid] [\systemsetupsprefix\s!default]

    \directsetup{\systemsetupsprefix\s!reset}

    \widowpenalty       \defaultgridwidowpenalty
    \clubpenalty        \defaultgridclubpenalty
    \displaywidowpenalty\defaultgriddisplaywidowpenalty
    \brokenpenalty      \defaultgridbrokenpenalty

\stopsetups

% as an illustration:

\startsetups [\systemsetupsprefix\v!strict]

    \directsetup{\systemsetupsprefix\s!reset}

    \setpenalties\widowpenalties2\maxdimen
    \setpenalties\clubpenalties 2\maxdimen
                 \brokenpenalty  \maxdimen

\stopsetups

\setdefaultpenalties % will happen later in \setuplayout

%D To be checked:

\newbox\b_spac_struts_saved

\unexpanded\def\savestrut {\setbox\b_spac_struts_saved\copy\strutbox}
\unexpanded\def\savedstrut{\copy  \b_spac_struts_saved}

%D Good old blank redone:

%definesystemattribute[kernchars]    [public]
\definesystemattribute[skipcategory] [public]
\definesystemattribute[skippenalty]  [public]
\definesystemattribute[skiporder]    [public]
\definesystemattribute[displaymath]  [public]
\definesystemattribute[snapmethod]   [public]
\definesystemattribute[snapvbox]     [public]
%definesystemattribute[snapcategory] [public]

% TODO: NAMED SNAPPERS

\installcorenamespace{gridsnappers}

\newskip  \bodyfontlineheight
\newdimen \bodyfontstrutheight
\newdimen \bodyfontstrutdepth

\newskip  \globalbodyfontlineheight
\newdimen \globalbodyfontstrutheight
\newdimen \globalbodyfontstrutdepth

\def\snappedvboxattribute{\ifgridsnapping attr       \snapvboxattribute \attribute\snapmethodattribute\fi}
\def\setlocalgridsnapping{\ifgridsnapping \attribute \snapvboxattribute \attribute\snapmethodattribute\fi}

\def\dosetlocalgridsnapping#1%
  {\ifgridsnapping
     \doifsomething{#1}%
       {\autosetsnapvalue{#1}%
        \attribute \snapvboxattribute \attribute\snapmethodattribute}%
   \fi}

\def\installsnapvalues#1#2% todo: a proper define
  {\edef\currentsnapper{#1:#2}%
   \ifcsname\currentsnapper\endcsname \else
     \setevalue\currentsnapper{\ctxlua{builders.vspacing.definesnapmethod("#1","#2")}}%
   \fi
   \setevalue{\??gridsnappers#1}{\attribute\snapmethodattribute\csname\currentsnapper\endcsname\space}}

\unexpanded\def\definegridsnapping
  {\dodoubleargument\dodefinegridsnapping}

\def\dodefinegridsnapping[#1][#2]%
  {\installsnapvalues{#1}{#2}}

\edef\resetsnapvalue
  {%\gridsnappingfalse
   \attribute\snapmethodattribute\attributeunsetvalue}

\def\setsnapvalue#1%
  {%\gridsnappingtrue
   \ifcsname\??gridsnappers#1\endcsname\csname\??gridsnappers#1\endcsname\fi}

\def\autosetsnapvalue#1%
  {\ifcsname\??gridsnappers#1\endcsname
     \csname\??gridsnappers#1\endcsname
   \else
     \installsnapvalues\s!dummy{#1}%
     \csname\??gridsnappers\s!dummy\endcsname
   \fi}

% \installsnapvalues{loose} {\v!maxdepth:0.8,\v!maxheight:0.8,\v!strut}
% \installsnapvalues{normal}{\v!maxdepth:1.0,\v!maxheight:1.0,\v!strut}
% \installsnapvalues{tight} {\v!maxdepth:1.2,\v!maxheight:1.2,\v!strut}

% none             don't enlarge
% halfline         enlarge by halfline/halfline
% line             enlarge by line/line
% strut            enlarge by ht/dp (default)
% first            align to top line
% last             align to bottom line
% mindepth         round depth down
% maxdepth         round depth up
% minheight        round height down
% maxheight        round height up
% local            use local interline space
% offset:-3tp      vertical shift within box
% bottom:lines
% top:lines

%D We're not downward compatible with \MKII !

\definegridsnapping[\v!normal]   [\v!maxheight,\v!maxdepth,\v!strut]
\definegridsnapping[\v!standard] [\v!maxheight,\v!maxdepth,\v!strut]
\definegridsnapping[\v!yes]      [\v!maxheight,\v!maxdepth,\v!strut]

\definegridsnapping[\v!strict]   [\v!maxdepth:0.8,\v!maxheight:0.8,\v!strut]
\definegridsnapping[\v!tolerant] [\v!maxdepth:1.2,\v!maxheight:1.2,\v!strut]

\definegridsnapping[\v!top]      [\v!minheight,\v!maxdepth,\v!strut]
\definegridsnapping[\v!bottom]   [\v!maxheight,\v!mindepth,\v!strut]
\definegridsnapping[\v!both]     [\v!minheight,\v!mindepth,\v!strut]

\definegridsnapping[\v!broad]    [\v!maxheight,\v!maxdepth,\v!strut,0.8] % maybe 0.85
\definegridsnapping[\v!fit]      [\v!maxheight,\v!maxdepth,\v!strut,1.2] % tight 0.15

\definegridsnapping[\v!first]    [\v!first]
\definegridsnapping[\v!last]     [\v!last]
\definegridsnapping[\v!high]     [\v!minheight,\v!maxdepth,\v!none]
\definegridsnapping[\v!one]      [\v!minheight,\v!mindepth]
\definegridsnapping[\v!low]      [\v!maxheight,\v!mindepth,\v!none]
\definegridsnapping[\v!line]     [\v!line]
\definegridsnapping[\v!strut]    [\v!strut]

\definegridsnapping[\v!max]      [\v!maxdepth,\v!maxheight,\v!strut]
\definegridsnapping[\v!min]      [\v!mindepth,\v!minheight,\v!strut]

\definegridsnapping[\v!middle]   [\v!maxheight,\v!maxdepth] % used in placement

\newtoks\everysetupgridsnapping % this only happens at the setuplayout level

\def\dosetupgridsnapping{\the\everysetupgridsnapping} % not used !

\def\synchronizelocallinespecs
  {\bodyfontlineheight \normallineheight
   \bodyfontstrutheight\strutheight
   \bodyfontstrutdepth \strutdepth}

\def\synchronizegloballinespecs
  {\global\globalbodyfontlineheight \normallineheight
   \global\globalbodyfontstrutheight\strutheight
   \global\globalbodyfontstrutdepth \strutdepth}

\appendtoks
    \synchronizegloballinespecs
    \synchronizelocallinespecs
\to \everysetupglobalinterlinespace

\appendtoks
    \synchronizelocallinespecs
\to \everysetuplocalinterlinespace

%D Snapping.

\newif\ifgridsnapping

\let\showgridsnapping\relax

\def\snaptogrid {\dosingleempty\dosnaptogrid}
\def\moveongrid {\dosingleempty\domoveongrid}
\unexpanded\def\placeongrid{\dosingleempty\doplaceongrid}

\def\domoveongrid[#1]%
  {[obsolete]} % gone, unless we set an attribute

\def\doplaceongrid[#1]%
  {\snaptogrid[#1]\vbox} % mark as done

\def\dosnaptogrid[#1]% list or predefined
  {\ifgridsnapping
     \expandafter\dodosnaptogrid
   \else
     \expandafter\gobbleoneargument
   \fi{#1}}

\def\dodosnaptogrid#1%
  {\bgroup
   \resetsnapvalue
   \dowithnextbox{\dododosnaptogrid{#1}}}

% eventually there will always be a line snap

\def\dododosnaptogrid#1%
  {\ifvbox\nextbox % this will go away
     \ctxlua{builders.vspacing.collapsevbox(\number\nextbox)}% isn't that already done?
   \fi
   \doifelsenothing{#1}{\setsnapvalue\v!normal}{\autosetsnapvalue{#1}}%
   \ctxlua{builders.vspacing.snapbox(\number\nextbox,\number\attribute\snapmethodattribute)}%
   \ifvbox\nextbox\vbox\else\hbox\fi attr \snapmethodattribute \zerocount {\box\nextbox}%
   \egroup}

\def\docheckgridsnappingnop
  {\gridsnappingfalse
   \resetsystemmode\v!grid
   \resetsnapvalue}

\def\docheckgridsnappingyes
  {\gridsnappingtrue
   \setsystemmode\v!grid
   \autosetsnapvalue\askedgridmode}

\def\docheckgridsnapping
  {\edef\askedgridmode{\layoutparameter\c!grid}%
   \ifx\askedgridmode\v!no       % official
     \docheckgridsnappingnop
   \else\ifx\askedgridmode\v!off % for taco and luigi
     \docheckgridsnappingnop
   \else\ifx\askedgridmode\empty % to be sure
     \docheckgridsnappingnop
   \else
     \docheckgridsnappingyes
   \fi\fi\fi}

%D Visualization:

\definepalet
  [grid]
  [  one=red,
     two=green,
   three=blue,
    four=gray]

\def\setgridtracebox#1[#2]% % maybe reverse the order
  {\setbox\nextbox#1%
     {\hbox
        {\hbox to \zeropoint
           {\setlayoutcomponentattribute{\v!grid:\v!test}%
            \color[grid:#2]{\ruledhbox \layoutcomponentboxattribute {\fakebox\nextbox}}%
            \hss}%
         \flushnextbox}}}

\setnewconstant\gridboxlinenomode\plusone % 0:nothing 1:all 2:lines 3:frame 4:l/r
\setnewconstant\gridboxlinemode  \plusone

\def\gridboxvbox {\ifcase\gridboxlinemode\vbox\or\ruledvbox\or\vbox\or\ruledvbox\else\ruledvbox\fi}
\def\gridboxwidth{\ifcase\gridboxlinemode0\or.5\or.5\or0\else.5\fi\testrulewidth}

\def\setgridbox#1#2#3% maybe ifgridsnapping at outer level
  {\setbox#1\gridboxvbox to #3 % given size
     {\forgetall
      \resetteststrut
      \offinterlineskip
      \hsize#2%
      \baselinerulefalse
      \ifnum\gridboxlinenomode=\plusthree
        \gridboxlinenomode\ifodd\realpageno\plusone\else\plustwo\fi
      \fi
      \gridboxvbox % calculated size
        {\getrawnoflines{#3}% \getnoflines{#3}%
         \scratchdimen\dimexpr#2+\lineheight\relax
         \dorecurse\noflines
           {\strut
            \hskip-.5\lineheight\relax
            \ifcase\gridboxlinenomode\or
              \rlap
                {\hskip.2\bodyfontsize\hskip\scratchdimen
                 \infofont\hbox to 1em{\hss\recurselevel}}%
            \or
              \llap
                {\infofont\hbox to 1em{\hss\recurselevel}%
                 \hskip.2\bodyfontsize}%
            \fi
            \vrule
              \!!height \gridboxwidth
              \!!depth  \gridboxwidth
              \!!width  \scratchdimen
            \par}}
      \vfill}}

%D This has become obsolete:

\def\fuzzysnappedbox#1#2% \box<n> \unvbox<n>
  {#1#2}

\def\moveboxontogrid#1#2#3% will become obsolete
  {}

%D Helper:

\def\doassignsomeskip#1\to#2% ook nog \v!halfline+fuzzysnap
  {\doifelse{#1}\v!line
     {#2\ifgridsnapping
        \bodyfontlineheight
      \else
        \openlineheight
      \fi}
     {\ifgridsnapping
        \assigndimension{#1}{#2}{.25\bodyfontlineheight}{.5\bodyfontlineheight}\bodyfontlineheight
      \else
        \assigndimension{#1}{#2}\smallskipamount\medskipamount\bigskipamount
      \fi}%
   \relax}

% \start \dosetstretch{.25em} \setuptolerance[tolerant,stretch] \input tufte \endgraf \stop
% \start \dosetstretch{.5em} effe flink doorfietsen \stop

% experimental code, not yet interfaced:

% category:
% 0 == discard                             discard
% 1 == only if larger                      largest
% 2 == force even if smaller               force
% 3 == only take penalty component         penalty
% 4 == add to existing skip                add
% 5 == disable (ignore following)          disable
% 6 == kill whitespace                     nowhite
% 7 == discard previous                    back
%
% penalty: larger wins
% order: larger wins
% category:2,order:5,penalty:10000,skip:value|kw
%
% \defineblankmethod  [\v!joinedup] {\ifvmode\nointerlineskip\fi}

% todo, in grid mode: builders.vspacing.fixed = false

\let\saveouterspacing   \relax % for old times sake
\let\restoreouterspacing\relax % for old times sake

\newtoks\everybeforeblankhandling
\newtoks\everyafterblankhandling

\newconditional\someblankdone

\appendtoks
    \s_spac_vspacing_temp\zeropoint
    \attribute\skipcategoryattribute\plusone
    \attribute\skippenaltyattribute \attributeunsetvalue
    \attribute\skiporderattribute   \attributeunsetvalue
    \ifgridsnapping % \ifblankflexible
        \setfalse\blankisfixed
    \else
        \settrue\blankisfixed
    \fi
\to \everybeforeblankhandling

\appendtoks
    \s_spac_vspacing_temp\plusone\s_spac_vspacing_temp
      \ifconditional\blankisfixed \else
        \!!plus \skipgluefactor\s_spac_vspacing_temp
        \!!minus\skipgluefactor\s_spac_vspacing_temp
      \fi
\to \everyafterblankhandling

% \ifgridsnapping will go

\appendtoks
    \ifgridsnapping
        \settrue\blankisfixed
    \else
        \setfalse\blankisfixed
    \fi
\to \everybeforeblankhandling

\def\setblankcategory#1%
  {\settrue\someblankdone
   \attribute\skipcategoryattribute#1\relax}

\def\setblankorder#1%
  {\attribute\skiporderattribute#1\relax}

\def\fixedblankskip
  {\settrue\blankisfixed}

\def\flexibleblankskip
  {\setfalse\blankisfixed}

\def\addblankskip#1#2#3%
  {\settrue\someblankdone
   \advance\s_spac_vspacing_temp#1\dimexpr\ifgridsnapping#3\else#2\fi\relax\relax}

\def\setblankpenalty #1%
  {\flushblankhandling
   \settrue\someblankdone
   \attribute\skipcategoryattribute \plusthree
   \attribute\skippenaltyattribute #1\relax
   \flushblankhandling}

\unexpanded\def\startblankhandling
  {\par
   \ifvmode
     \expandafter\dostartblankhandling
   \else
     \expandafter\nostartblankhandling
   \fi}

\def\nostartblankhandling#1\stopblankhandling
  {}

\def\dostartblankhandling
  {\begingroup
   \setfalse\someblankdone
   \the\everybeforeblankhandling}

\unexpanded\def\stopblankhandling
  {\the\everyafterblankhandling
   \ifconditional\someblankdone
     \vskip\s_spac_vspacing_temp
   \fi
   \endgroup}

\def\flushblankhandling
  {\the\everyafterblankhandling
   \ifconditional\someblankdone
     \vskip\s_spac_vspacing_temp
   \fi
   \setfalse\someblankdone
   \the\everybeforeblankhandling}

% % % % we can move much to lua once we can expand there % % % %

\installcorenamespace{vspacingamount}

\unexpanded\def\definevspacingamount
  {\dotripleempty\dodefinevspacingamount}

\def\dodefinevspacingamount[#1][#2][#3]% can be combined
  {\setvalue{\??vspacingamount#1}{\ifgridsnapping#3\else#2\fi}%
   \ctxlua{builders.vspacing.setskip("#1")}}

\def\addpredefinedblankskip#1#2%
  {\settrue\someblankdone
   \advance\s_spac_vspacing_temp#1\dimexpr\csname\??vspacingamount#2\endcsname\relax}

\def\addaskedblankskip#1#2%
  {\settrue\someblankdone
   \advance\s_spac_vspacing_temp#1\dimexpr#2\relax}

\unexpanded\def\definevspacing
  {\dodoubleempty\dodefinevspacing}

\def\dodefinevspacing[#1][#2]%
  {\ctxlua{builders.vspacing.setmap("#1","#2")}}

\unexpanded\def\vspacing
  {\dosingleempty\dovspacing}

% todo: when packed blocks blank, we need to enable forced

\def\dovspacing % blank also has a \flushnotes
  {\ifinpagebody
     \expandafter\dovspacingyes
   \else\ifconditional\noblankinpacked % todo: better reset this conditional in pagebody
     \expandafter\expandafter\expandafter\dovspacingnop
   \else
     \expandafter\expandafter\expandafter\dovspacingyes
   \fi\fi}

\def\dovspacingyes[#1]%
 %{\ifmmode\else\ctxlua{builders.vspacing.analyze("\iffirstargument#1\else\s!default\fi")}\fi}
  {\ifmmode\else\ctxlua{builders.vspacing.analyze("\iffirstargument#1\else\currentvspacing\fi")}\fi}

\def\dovspacingnop[#1]%
  {\ifmmode\else\par\fi}

% todo: check them and make them faster:

\definecomplexorsimple\setupvspacing

\let\currentvspacing\s!default

\def\complexsetupvspacing[#1]%
  {\edef\currentvspacing{#1}}

\def\simplesetupvspacing
  {\ifx\empty\currentvspacing\else
     \let\currentvspacing\s!default
   \fi
   \simplesetupwhitespace}

\def\restorestandardblank
  {\let\currentvspacing\v!standard}

% used both

\def\doinhibitblank{\vspacing[\v!disable]} % can be made faster (keep this command, used in styles)
\def\inhibitblank  {\vspacing[\v!disable]} % can be made faster

\let\setupblank      \setupvspacing
\let\simplesetupblank\simplesetupvspacing
\let\blank           \vspacing

% category:4 is default

\definevspacingamount[\v!none]    [\zeropoint]         [\zeropoint]
\definevspacingamount[\v!big]     [\bigskipamount]     [\bodyfontlineheight]
\definevspacingamount[\v!medium]  [\medskipamount]     [0.50\bodyfontlineheight]
\definevspacingamount[\v!small]   [\smallskipamount]   [0.25\bodyfontlineheight]
\definevspacingamount[\v!line]    [\openlineheight]    [\bodyfontlineheight]
\definevspacingamount[\v!halfline][0.50\openlineheight][0.50\bodyfontlineheight]
\definevspacingamount[\v!formula] [\medskipamount]     [0.50\bodyfontlineheight]
\definevspacingamount[\v!white]   [\parskip]           [\bodyfontwhitespace]
\definevspacingamount[\v!height]  [\strutheight]       [\bodyfontstrutheight]
\definevspacingamount[\v!depth]   [\strutdepth]        [\bodyfontstrutdepth]

\definevspacingamount[-\v!line]    [-\openlineheight]  [-\bodyfontlineheight]
\definevspacingamount[-\v!halfline][-.5\openlineheight][-.5\bodyfontlineheight]

\def\bodyfontwhitespace
  {\dimexpr
     \ifdim\parskip=\zeropoint
       \zeropoint
     \else\ifgridsnapping
       \bodyfontlineheight
     \else
       \parskip
     \fi\fi
   \relax}

\definevspacing[\v!preference][penalty:-500]  % goodbreak
\definevspacing[\v!samepage]  [penalty:10000] % real strong
\definevspacing[\v!max]       [category:1]
\definevspacing[\v!force]     [category:2]
\definevspacing[\v!disable]   [category:5]
\definevspacing[\v!nowhite]   [category:6]
\definevspacing[\v!back]      [category:7]
\definevspacing[\v!always]    [category:0]
\definevspacing[\v!weak]      [order:0]
\definevspacing[\v!strong]    [order:100]

\definevspacing[\s!default]   [\v!white] % was big for a while

\dorecurse{10} % todo: other values < 4000
  {\expanded{\definevspacing[\v!samepage-\recurselevel][penalty:\the\numexpr4000+250*\recurselevel\relax]}}

\let\blank            \vspacing
\let\defineblank      \definevspacing
\let\defineblankmethod\definevspacingamount

%D The following command is for Wolfgang. It has to be used with
%D care as it does {\em not} work in tandem with the other spacing
%D commands.

\installcorenamespace{vspace}

\unexpanded\def\definevspace
  {\dotripleempty\dodefinevspace}

\def\dodefinevspace[#1][#2][#3]%
  {\ifthirdargument
     \setvalue{\??vspace#1:#2}{#3}%
   \else
     \setvalue{\??vspace:#1}{#2}%
   \fi}

\letvalue{\??vspace#1:\s!unknown}\zeropoint

\unexpanded\def\vspace
  {\dodoubleempty\dovspace}

\def\dovspace[#1][#2]%
  {\par
   \ifvmode
     \removelastskip
     \vskip
       \csname\??vspace
       \ifsecondargument
         \ifcsname\??vspace#1:#2\endcsname
           #1:#2%
         \else\ifcsname\??vspace:#2\endcsname
           :#2%
         \else
           :\s!unknown
         \fi\fi
       \else\iffirstargument
         \ifcsname\??vspace:#1\endcsname
           :#1%
         \else
           :\s!unknown
         \fi
       \else
         \ifcsname\??vspace:\s!default\endcsname
           :\s!default
         \else
           :\s!unknown
         \fi
       \fi\fi
     \endcsname
     \relax
   \fi}

\protect \endinput
