\setupbodyfont
  [dejavu,9pt]

\setuppapersize
  [A4,landscape]

\setuplayout
  [width=middle,
   height=middle,
   backspace=1cm,
   topspace=1cm,
   footer=0pt,
   header=1.25cm]

\setuphead
  [title]
  [style=\bfa,
   page=yes]

\setuppagenumbering
  [location=]

\setupheadertexts
  [\currentdate][MkIV Status / Page \pagenumber]

% \showmakeup
% \showallmakeup

\starttext

\starttitle[title=Todo]

\startitemize[packed]
    \startitem currently the new namespace prefixes are not consistent but this
               will be done when we're satisfied with one scheme \stopitem
    \startitem there will be additional columns in the table, like for namespace
               so we need another round of checking then \stopitem
    \startitem the imp modules are not in the list and need checking too \stopitem
    \startitem the s, x, m modules will be checked, redone and reorganized \stopitem
    \startitem the lua code will be cleaned up upgraded as some is quite old
               and experimental \stopitem
    \startitem we need a proper dependency tree and better defined loading order \stopitem
    \startitem all dotag.. will be moved to the tags_.. namespace \stopitem
    \startitem we need to check what messages are gone (i.e.\ clean up mult-mes) \stopitem
    \startitem some commands can go from mult-def (and the xml file) \stopitem
    \startitem check for setuphandler vs simplesetuphandler \stopitem
    \startitem all showcomposition etc can go (we can redo that in lua if needed) \stopitem
    \startitem for the moment we will go for \type {xxxx_} namespaces that (mostly) match
               the filename but later we can replace these by longer names (via a script) so
               module writers should {\bf not} use the core commands with \type{_} in the
               name \stopitem
    \startitem the message system will be unified \stopitem
    \startitem maybe rename dowhatevertexcommand to fromluawhatevertexcommand \stopitem
    \startitem consider moving setups directly to lua end (e.g. in characterspacing, breakpoint, bitmaps etc.) \stopitem
    \startitem more local temporary \type {\temp...} will become \type {\p_...} \stopitem
    \startitem check all ctxlua calls for ctxcommand \stopitem
    \startitem rename all those \type {\current<whatever>}s in strc.
\stopitemize

\stoptitle

\definehighlight[notabenered]   [color=darkred,   style=bold]
\definehighlight[notabeneblue]  [color=darkblue,  style=bold]
\definehighlight[notabeneyellow][color=darkyellow,style=bold]

\startluacode

    local coremodules = dofile("status-mkiv.lua")

    local valid = table.tohash {
        "toks", "attr", "page", "buff", "font", "colo", "phys", "supp", "typo", "strc",
        "syst", "tabl", "spac", "scrn", "lang", "lxml", "mlib", "java", "pack", "math",
        "symb", "grph", "anch", "luat", "mult", "back", "node", "meta", "norm", "catc",
        "cldf", "file", "char", "core", "layo", "trac", "cont", "regi", "enco", "hand",
        "unic", "sort", "blob", "type", "scrp", "prop", "chem", "bibl", "task",
        "module", "mp",
    }

    local specialcategories = {
        mkvi = true,
   }

    local what = {
        "core", "lua", "optional", "implementations", "extra", "extras", "metafun", "modules", "resources"
    }

    if coremodules then

        local function tabelize(loaded,what)

            if loaded then

                local noftodo    = 0
                local nofdelayed = 0
                local nofloaded  = #loaded
                local categories = { }

                for k, v in next, valid do
                    categories[k] = { }
                end

                for i=1,nofloaded do
                    local l = loaded[i]
                    l.order = i
                    local category = string.match(l.filename,"([^%-]+)%-") or "module"
                    local c = categories[category]
                    if c then
                        c[#c+1] = l
                    end
                end

                for k, loaded in table.sortedhash(categories) do

                    local nofloaded = #loaded

                    if nofloaded > 0 then

                        table.sort(loaded,function(a,b) return a.filename < b.filename end) -- in place

                        context.starttitle { title = string.format("%s: %s",what,k) }

                        context.starttabulate { "|Tr|Tlw(12em)|Tl|Tlw(6em)|l|l|l|p|" }
                        context.NC() context.bold("order")
                        context.NC() context.bold("file")
                        context.NC() context.bold("mark")
                        context.NC() context.bold("status")
                        context.NC() context.bold("reference")
                        context.NC() context.bold("manual")
                        context.NC() context.bold("wiki")
                        context.NC() context.bold("comment")
                        context.NC() context.NR()
                        context.HL()
                        for i=1,nofloaded do
                            local module = loaded[i]
                            local status = module.status
                            local category = module.category
                            context.NC() context(module.order)
                            context.NC() context(module.filename)
                            context.NC()
                            if specialcategories[category] then
                                context.notabeneblue(category)
                            else
                                context(category)
                            end
                            context.NC()
                            if status == "todo" then
                                context.notabenered(status)
                                noftodo = noftodo + 1
                            elseif status == "delayed" then
                                context.notabeneyellow(status)
                                nofdelayed = nofdelayed + 1
                            else
                                context(status)
                            end
                            context.NC() context(module.reference)
                            context.NC() context(module.manual)
                            context.NC() context(module.wiki)
                            context.NC() context(module.comment)
                            context.NC() context.NR()
                        end
                        context.stoptabulate()

                        context.stoptitle()

                    end

                end

                context.starttitle { title = string.format("summary of %s modules",what) }

                    local nofdone = nofloaded - noftodo - nofdelayed

                    context.starttabulate { "|B|r|" }
                    context.HL()
                    context.NC() context("done")    context.NC() context(nofdone)    context.NC() context.NR()
                    context.NC() context("todo")    context.NC() context(noftodo)    context.NC() context.NR()
                    context.NC() context("delayed") context.NC() context(nofdelayed) context.NC() context.NR()
                    context.HL()
                    context.NC() context("loaded")  context.NC() context(nofloaded)  context.NC() context.NR()
                    context.HL()
                    context.stoptabulate()

                context.stoptitle()

            end

        end

        for i=1,#what do
            tabelize(coremodules[what[i]],what[i])
        end

    end

 -- context.starttitle { title = "Valid prefixes" }
 --
 -- for namespace, data in table.sortedhash(namespaces) do
 --     if valid[namespace] then
 --         context.type(namespace)
 --     end
 --     context.par()
 -- end
 --
 -- context.stoptitle()

    context.starttitle { title = "messy namespaces" }

    local namespaces = dofile("status-namespaces.lua")

    for namespace, data in table.sortedhash(namespaces) do
        if valid[namespace] then
        else
            context(namespace)
        end
        context.par()
    end

    context.stoptitle()

    context.starttitle { title = "messy registers" }

    local registers  = dofile("status-registers.lua")

    for register, data in table.sortedhash(registers) do
        context(register)
        context.par()
        for name in table.sortedhash(data) do
            context.quad()
            context.type(name)
            context.par()
        end
        context.par()
    end

    context.stoptitle()

\stopluacode

\stoptext
