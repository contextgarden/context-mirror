%D \module
%D   [       file=supp-num,
%D        version=1998.05.15,
%D          title=\CONTEXT\ Support Macros,
%D       subtitle=Number (Digit) Handling, 
%D         author=Hans Hagen,
%D           date=\currentdate,
%D      copyright={PRAGMA / Hans Hagen \& Ton Otten}]
%C
%C This module is part of the \CONTEXT\ macro||package and is
%C therefore copyrighted by \PRAGMA. See mreadme.pdf for 
%C details. 

\writestatus{loading}{Context Support Macros / Number (Digit) Handling}

\unprotect

%D \macros
%D   {digits, setdigitmode, setdigitsign}
%D
%D Depending on the digit mode the command \type {\digits}
%D normalizes number patterns depending on the language set.
%D
%D \starttypen
%D This will never be a \digits{1.000.000} seller. 
%D \stoptypen
%D
%D or
%D
%D \starttypen
%D I will never grow longer than \digits 1.86 \Meter. 
%D \stoptypen
%D
%D The different modes are shown in:
%D
%D \startbuffer
%D \setdigitmode 1 \digits 12.345,90 \digits 12.345.000 \digits 1,23 
%D \setdigitmode 2 \digits 12.345,90 \digits 12.345.000 \digits 1,23 
%D \setdigitmode 3 \digits 12.345,90 \digits 12.345.000 \digits 1,23 
%D \setdigitmode 4 \digits 12.345,90 \digits 12.345.000 \digits 1,23 
%D \setdigitmode 5 \digits 12.345,90 \digits 12.345.000 \digits 1,23 
%D \setdigitmode 6 \digits 12.345,90 \digits 12.345.000 \digits 1,23 
%D \stopbuffer
%D
%D \typebuffer
%D
%D This is typset as: 
%D
%D \startregels
%D \haalbuffer
%D \stopregels
%D
%D The sign can be typeset as is or within the space of a 
%D digit. 
%D
%D \startbuffer
%D \setdigitsign 0 \digits +12.345,90 
%D \setdigitmode 1 \digits +12.345,90  
%D \setdigitmode 2 \digits +12.345,90  
%D \setdigitmode 3 \digits +12.345,90  
%D \stopbuffer
%D
%D \typebuffer
%D
%D This is typset as: 
%D
%D \startregels
%D \haalbuffer
%D \stopregels

\chardef\digitoutputmode=1 % 0..6
\chardef\digitsignmode  =0 % 0..3 

\def\setdigitmode{\chardef\digitoutputmode}
\def\setdigitsign{\chardef\digitsignmode}

%D The digit modes are:
%D 
%D \startopsomming[opelkaar]
%D \som periods      \& comma
%D \som commas       \& period 
%D \som thinmuskips  \& comma
%D \som thinmuskips  \& period
%D \som thickmuskips \& comma
%D \som thickmuskips \& period
%D \stopopsomming

\let\collecteddigits \empty \chardef\digitinputmode =1
\let\saveddigits     \empty \chardef\skipdigit      =0 
\let\savedpowerdigits\empty \chardef\powerdigits    =0

%D The first stage of the \type {\digit} macro takes care of 
%D the grouped call, the other branch handles the fuzzy 
%D delimited calls. 

\unexpanded\def\digits
  {\bgroup\let~@\doifnextcharelse\bgroup\dodigits\grabdigit}

\def\dodigits#1%
  {\grabdigit#1\relax}

\def\grabdigit
  {\futurelet\next\scandigit}

%D Watch the test for \type {\nextobeyedline}, because the 
%D endofline token can be \type {\def'd}, not \type {\let}'d, 
%D we need to do an indirect test (see \type {verb-ini.tex}) 
%D for details. 
%D 
%D \starttypen 
%D \def           ^^M{\obeyedline}
%D \def\nextbeyedline{\obeyedline}
%D \stoptypen 
 
\ifx\normalmathshift\undefined \let\normalmathshift=$ \fi 

\def\scandigit%
  {\ifx\next\blankspace
     \let\next\handledigits
   \else\ifx\next\nextobeyedline % the indirect one 
     \let\next\handledigits
   \else\ifx\next\bgroup
     \let\next\handledigits
   \else\ifx\next\egroup
     \let\next\handledigits
   \else\ifx\next\normalmathshift
     \let\next\handledigits
   \else
     \let\next\collectdigit
   \fi\fi\fi\fi\fi
   \next}

%D We store the power||of||ten (to be signaled by \type {^},
%D \type {e} or~\type {E}) in a seperate macro so that we can
%D typeset it in superscript. The space placeholders are 
%D replaced by a \type {@}.

\def\savedigit#1#2%
  {\edef#1{#1\saveddigits#2}\let\saveddigits\empty}

\long\def\collectdigit#1%
  {\ifx#1~%
     \savedigit\collecteddigits @%
   \else\if#1_%
     \savedigit\collecteddigits @%
   \else\if\noexpand#1\relax
     \let\grabdigit\handledigits
   \else\ifcase\powerdigits
     \if#1E%
       \chardef\powerdigits1
     \else\if#1e%
       \chardef\powerdigits1
     \else\if#1^%
       \chardef\powerdigits1
     \else
       \savedigit\collecteddigits#1%
       %\doifnumberelse{#1}
       %  {\savedigit\collecteddigits#1}
       %  {\def\saveddigits{#1}}%
     \fi\fi\fi
   \else
     \savedigit\savedpowerdigits#1%
     %\doifnumberelse{#1}
     %  {\savedigit\savedpowerdigits#1}
     %  {\def\saveddigits{#1}}%
   \fi\fi\fi\fi
   \grabdigit}

\let\handlemathdigits\firstofoneargument
\let\handletextdigits\mathematics

\def\handledigits%  
  {%\ifcase\powerdigits
   %  \edef\collecteddigits{\collecteddigits\saveddigits}%
   %\else
   %  \edef\savedpowerdigits{\savedpowerdigits\saveddigits}%
   %\fi
   \ifmmode
     \handlemathdigits{\dohandledigits}%
   \else
     \dontleavehmode\hbox{\handletextdigits{\dohandledigits}}%
   \fi
   \egroup}

%D Although we could do with one pass, a second pass for 
%D handling the stored sequence is more readable. 

\def\dohandledigits%
  {\mathcode`\,="013B \mathcode`\.="013A % pretty hard coded
   \expandafter\handletokens\collecteddigits\with\scandigits
   \ifcase\powerdigits\else\digitpowerseparator^{\savedpowerdigits}\fi}

\def\doscandigit#1%
  {\ifcase\skipdigit\else\hphantom{\fi
   \ifnum\digitinputmode=#1\relax
     \ifcase\digitoutputmode
     \or .%
     \or ,%
     \or \mskip\thinmuskip
     \or \mskip\thinmuskip
     \or \mskip\thickmuskip
     \or \mskip\thickmuskip
     \fi
   \else
     \ifodd\digitoutputmode,\else.\fi
   \fi
   \ifcase\skipdigit\else}\fi}

%D The signs can be made smaller and sqeezed into the width 
%D of a digit. Watch the \type {\fontdimen22} trickery (this
%D font related register stored the math axis). 

\def\scandigits#1%
  {\if#1.\doscandigit1\chardef\skipdigit0\else
   \if#1,\doscandigit2\chardef\skipdigit0\else
   \if#1@\hphantom{0}\chardef\skipdigit1\else
   \if#1_\hphantom{0}\chardef\skipdigit1\else
   \if#1/\digitsgn{\hphantom{+}}\chardef\skipdigit0\else
   \if#1-\digitsgn-\chardef\skipdigit0\else
   \if#1+\digitsgn+\chardef\skipdigit0\else
   \if#1=\digitsgn\zeroamount\chardef\skipdigit0\else
   \if#1s\digitsgn{\hphantom{\positive}}\chardef\skipdigit0\else
   \if#1p\digitsgn\positive\chardef\skipdigit0\else
   \if#1m\digitsgn\negative\chardef\skipdigit0\else
   \if#1n\digitsgn\negative\chardef\skipdigit0\else
      #1\chardef\skipdigit0\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi}

\def\digitsgn#1%
  {\ifcase\digitsignmode#1\else
     \hbox
       {\setbox\scratchbox=\hbox{0}%
        \scratchdimen\fontdimen22\textfont2
        \def\digitsgn##1##2%
          {\advance\scratchdimen-\fontdimen22##12
           \raise\scratchdimen
           \hbox to \wd\scratchbox{\hss$##2#1$\hss}}%
        \ifcase\digitsignmode\or
          \digitsgn\textfont        \textstyle        \or
          \digitsgn\scriptfont      \scriptstyle      \or
          \digitsgn\scriptscriptfont\scriptscriptstyle\fi}%
   \fi}

\ifx\undefined\zeroamount \def\zeroamount{-} \fi 
\ifx\undefined\positive   \def\positive  {+} \fi 
\ifx\undefined\negative   \def\negative  {-} \fi 

%D The digit parser handles a bunch of special characters as
%D well as different formats. We strongly suggest you to use
%D the grouped call. 
%D 
%D \starttabulatie[|l|l|l|]
%D \NC \type{.} \NC , . \NC comma or period \NC \NR 
%D \NC \type{,} \NC , . \NC comma or period \NC \NR 
%D \NC \type{@} \NC \NC invisible space \NC \NR 
%D \NC \type{_} \NC \NC invisible space \NC \NR 
%D \NC \type{/} \NC \NC invisible sign \NC \NR 
%D \NC \type{-} \NC $-$ \NC minus sign \NC \NR 
%D \NC \type{+} \NC $+$ \NC plus sign \NC \NR 
%D \NC \type{s} \NC \NC invisible high sign \NC \NR 
%D \NC \type{p} \NC $\positive$ \NC high plus sign \NC \NR 
%D \NC \type{m} \NC $\negative$ \NC high minus sign \NC \NR 
%D \NC \type{n} \NC $\negative$ \NC high minus (negative) sign \NC \NR 
%D \NC \type{=} \NC $\zeroamount$ \NC zero padding \NC \NR 
%D \stoptabulatie
%D
%D These triggers are used in the following examples. 
%D
%D \startbuffer
%D \digits 12
%D \digits{~~~.~~~.~~~.68.712,34}
%D \digits ~~~.~~~.~~~.68.712,34
%D \digits ___.___.111.68.712,34
%D \digits 111.111.111.68.712,34
%D \digits 12.345,90
%D \digits 12.345.000
%D \digits 12,34
%D \digits{392.857.230.68.712,34}
%D {\digits1234}
%D \digits{1234}
%D \digits 1234\relax
%D $\digits 123.222,00$
%D \digits 123.222,00
%D \digits 123.222,==
%D \digits 123.222,00^10
%D \digits 123.222,00e10
%D \digits /123.222,00e-12
%D \digits -123.222,00e-12
%D \digits +123.222,00e-12
%D \digits n123.222,00e-12
%D \digits s123.222,00e-12
%D \digits p123.222,00e-12
%D \stopbuffer
%D 
%D \typebuffer
%D 
%D \startregels
%D \haalbuffer
%D \stopregels

%D \macros 
%D   {Digits}
%D
%D We also permit:

\let\Digits=\digits

%D These macros are complicated by the fact that we also 
%D have to support cases like:
%D
%D \starttypen
%D {\digits1234}
%D \digits{1234}
%D \digits 1234\whatever
%D $\digits 123.222,00$
%D \digits 123.222,00.
%D \stoptypen
%D
%D The latter case shows us that trailing non digits are to
%D be passed untreated. 
%D
%D Another interesting case is: 
%D
%D \starttypen
%D \digits 123.222,00^10
%D \stoptypen
%D
%D The separator is defined as:

\def\digitpowerseparator%
  {\cdot10} % {\times10}

%D \macros
%D   {digittemplate}
%D
%D Users can specify the way they enter those digits by sayon
%D something like:
%D
%D \starttypen
%D \digittemplate 12.000.000,00 % \digittemplate .,
%D \stoptypen

\def\digittemplate #1 %
  {\chardef\digitinputmode=0
   \handletokens#1\with\scandigittemplate}  

\def\scandigittemplate#1%
  {\if     #1.\ifcase\digitinputmode\chardef\digitinputmode=1 \fi% period
   \else\if#1,\ifcase\digitinputmode\chardef\digitinputmode=2 \fi% comma
   \fi\fi}

\protect

\endinput
