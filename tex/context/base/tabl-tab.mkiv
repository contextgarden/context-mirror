%D \module
%D   [       file=core-tab,
%D        version=1997.10.10,
%D          title=\CONTEXT\ Table Macros,
%D       subtitle=\TABLE\ Embedding,
%D         author=Hans Hagen with copied and patched code from MJ Wichura,
%D           date=\currentdate,
%D      copyright=PRAGMA-ADE (patched and extensions)]
%C
%C This module is part of the \CONTEXT\ macro||package and is
%C therefore copyrighted by \PRAGMA. See mreadme.pdf for
%C details.

\writestatus{loading}{ConTeXt Table Macros / TaBlE Embedding}

% In \MKIV\ the old table macros are sort of obsolete. The
% color extensions have been removed and some code is stripped.
% For practical reasons the \TABLE\ macros that are used are
% embedded in this file.
%
% The following code is based on TABLE 1.0 by Michael J. Wichura
% (August 1988. We used a patched version with many overloads
% and extensions. The documented (and larger) source can be found
% in \type {thrd-tab.tex}.
%
% Much more can be stripped.

\unprotect

\newconditional\tablehasleftspacing
\newconditional\tablehasrightspacing

\newdimen\tablelinethicknessunit
\newdimen\tablestrutunit
\newskip \tableintercolumnspaceunit
\newdimen\tablecolumnwidthunit
\newdimen\tablekernunit

\def\tablelinethicknessfactor    {2}
\def\tablestrutheightfactor      {8}
\def\tablestrutdepthfactor       {3}
\def\tableintercolumnspacefactor {3}
\def\tablecolumnwidthfactor     {10}
\def\tablevspacefactor           {2}
\def\tablekernfactor             {1}

\newtoks\NormalTLTU
\newtoks\NormalTSU
\newtoks\NormalTICSU
\newtoks\NormalTCWU
\newtoks\NormalTKU

\NormalTLTU ={1in \divide \tablelinethicknessunit by 300 }
\NormalTSU  ={\normalbaselineskip \divide \tablestrutunit by 11 }
\NormalTICSU={.5em plus 1fil minus .25em}
\NormalTCWU ={.5em}
\NormalTKU  ={.5em}

\def\NormalTableUnits
  {\tablelinethicknessunit   \the\NormalTLTU
   \tablestrutunit           \the\NormalTSU
   \tableintercolumnspaceunit\the\NormalTICSU
   \tablecolumnwidthunit     \the\NormalTCWU
   \tablekernunit            \the\NormalTKU}

\NormalTableUnits

\newtoks\everytable
\newtoks\everytableparbox

\unexpanded\def\tablebeginparbox#1%
  {\setbox\scratchbox\vtop\bgroup % \setbox added
     \hsize#1\relax
     \dontcomplain
     \restoretablelineskips
     \normalbaselines
     \let~\!ttTie
     \let\-\!ttDH
     \blank[\v!disable]% % added
     \the\everytableparbox}

\unexpanded\def\tableendparbox
  {\removelastskip                                     % itemize or so
   \endgraf
   \ifnum\prevgraf>\zerocount                          % we want at least
     \verticalstrut \nowhitespace \vskip-\struttotal   % one line of text
     \egroup
     \ifdim\dp\scratchbox>\lineheight                  % see (*) for an
       \getnoflines{\dp\scratchbox}%                   % example of where
       \dp\scratchbox\zeropoint                        % saving can go
       \setbox\scratchbox                              % terrible wrong
         \vtop to \noflines\lineheight{\box\scratchbox}%
     \fi                                               % esp between rows
   \else                                               % of paragraphs
     \egroup
   \fi
   \box\scratchbox}

\appendtoks
    \parindent\zeropoint
    \raggedright
    \rightskip\zeropoint \!!plus 4em \relax
\to \everytableparbox

\newtoks\!taTableSpread

\newskip\tablelefttabskip
\newskip\tablerighttabskip

\newcount\!taCountA
\newcount\!taColumnNumber
\newcount\!taRecursionLevel % (Initially 0)

\newdimen\!taDimenA  % used by \Enlarge
\newdimen\!taDimenB  % used by \Enlarge
\newdimen\!taDimenC  % used by numeric.tex
\newdimen\!taMinimumColumnWidth

\newtoks\!taToksA

\newtoks\!taPreamble
\newtoks\!taDataColumnTemplate
\newtoks\!taRuleColumnTemplate
\newtoks\!taOldRuleColumnTemplate
\newtoks\!taLeftGlue
\newtoks\!taRightGlue

\newskip\!taLastRegularTabskip

\newif\if!taDigit
\newif\if!taBeginFormat
\newif\if!taOnceOnlyTabskip

\def\!thToksEdef#1=#2%
  {\edef\!ttemp{#2}%
   #1\expandafter{\!ttemp}%
   \ignorespaces}

\def\!thLoop#1\repeat
  {\def\!thIterate{#1\expandafter \!thIterate\fi}%
   \!thIterate
   \let\!thIterate\relax}

\def\BeginFormat
  {\!taPreamble\emptytoks
   \!taColumnNumber\zerocount
   \skip0=\tableintercolumnspaceunit
   \multiply\skip0 \tableintercolumnspacefactor
   \divide\skip0 2
   \!taRuleColumnTemplate=\expandafter{\expandafter\tabskip\the\skip0 }%
   \!taLastRegularTabskip=\skip0
   \!taOnceOnlyTabskipfalse
   \!taBeginFormattrue
   \let\!tfRowOfWidths\empty
   \ReadFormatKeys}

\def\!tfSetWidth
  {\ifx\!tfRowOfWidths\empty          % true if no prior "w" keys
     \ifnum\!taColumnNumber>\zerocount  % true if "w" key is to right of first "|"
       \begingroup                       % RowOfWidths={&\omit || n copies of &\omit&\omit}, where n = number of column to the left of this one
       \!taCountA=1
       \aftergroup \edef \aftergroup \!tfRowOfWidths \aftergroup {%
         \aftergroup &\aftergroup \omit
         \!thLoop
           \ifnum \!taCountA<\!taColumnNumber
           \advance\!taCountA 1
           \aftergroup \!tfAOAO
         \repeat
         \aftergroup}%
       \endgroup
     \fi
   \fi
   \ifx[\!ttemp % \!tgGetValue sets \!ttemp = token after w
     \expandafter\!tfSetWidthText
   \else
     \expandafter\!tfSetWidthValue
   \fi}

\def\!tfAOAO{&\omit&\omit}

\def\!tfSetWidthText[#1]%
  {\def\!tfWidthText{#1}%
   \ReadFormatKeys}

\def\!tfSetWidthValue
  {\!taMinimumColumnWidth=
     \ifnum\!tgCode=\plusone
       \ifx\!tgValue\empty \tablecolumnwidthfactor \else \!tgValue \fi \tablecolumnwidthunit
     \else
       \!tgValue
     \fi
   \let\!tfWidthText\empty %      Override possible prior `w[sample entry]'
   \ReadFormatKeys}

\def\!tfSetTabskip
  {\ifnum\!tgCode=\plusone
     \skip0=\tableintercolumnspaceunit
     \multiply\skip0 \ifx\!tgValue\empty\tableintercolumnspacefactor\else\!tgValue\fi
  \else
    \skip0=\!tgValue
  \fi
  \divide\skip0 by \plustwo
  \ifnum\!taColumnNumber=\zerocount
   %\!thToksEdef\!taRuleColumnTemplate={\the\!taRuleColumnTemplate\tabskip\the\skip0 }%
    \normalexpanded{\!taRuleColumnTemplate{\the\!taRuleColumnTemplate\tabskip\the\skip0 }}%
  \else
   %\!thToksEdef\!taDataColumnTemplate={\the\!taDataColumnTemplate\tabskip\the\skip0 }%
    \normalexpanded{\!taDataColumnTemplate{\the\!taDataColumnTemplate\tabskip\the\skip0 }}%
  \fi
  \if!taOnceOnlyTabskip\else
    \!taLastRegularTabskip=\skip0 % Remember this Tabskip, for possible
  \fi                             % restoration after a subsequent"OnceOnly"
  \ReadFormatKeys}

\def\!tfSetVrule
  {\!thToksEdef\!taRuleColumnTemplate
    ={\noexpand\hfil
      \noexpand\vrule
      \noexpand\!!width
      \ifnum\!tgCode=\plusone
        \ifx\!tgValue\empty
          \tablelinethicknessfactor
        \else
          \!tgValue
        \fi
        \tablelinethicknessunit
      \else
        \!tgValue
      \fi
      ####%
      \noexpand\hfil
      \the\!taRuleColumnTemplate}%
  \!tfAdjoinPriorColumn}

\def\!tfSetAlternateVrule
  {\afterassignment\!tfSetAlternateA
   \toks0 =}

\def\!tfSetAlternateA
  {\!thToksEdef\!taRuleColumnTemplate={\the\toks0 \the\!taRuleColumnTemplate}%
   \!tfAdjoinPriorColumn}

\def\!tfAdjoinPriorColumn
  {\ifnum \!taColumnNumber=0
     \!taPreamble=\!taRuleColumnTemplate % New \tabskip may have been added
   \else
     \ifx\!tfRowOfWidths\empty  % no "w" keys specified yet, not even this col
     \else
       \!tfUpdateRowOfWidths
     \fi
     \!thToksEdef\!taDataColumnTemplate={\the\!taLeftGlue\the\!taDataColumnTemplate\the\!taRightGlue}%
     \!thToksEdef\!taPreamble={\the\!taPreamble&\the\!taDataColumnTemplate&\the\!taRuleColumnTemplate}%
  \fi
  \advance \!taColumnNumber \plusone
  \if!taOnceOnlyTabskip
    \!thToksEdef\!taDataColumnTemplate={####\tabskip \the\!taLastRegularTabskip}%
  \else
    \!taDataColumnTemplate{##}%
  \fi
  \!taRuleColumnTemplate\emptytoks
  \!taLeftGlue{\hfil}%
  \!taRightGlue{\hfil}%
  \!taMinimumColumnWidth\zeropoint
  \let\!tfWidthText\empty
  \!taOnceOnlyTabskipfalse
  \ReadFormatKeys}

% UPDATE ROW OF WIDTHS
\def\!tfUpdateRowOfWidths
  {\ifx\!tfWidthText\empty \else
     \!tfComputeMinColWidth
   \fi
   \edef\!tfRowOfWidths
     {\!tfRowOfWidths
      &%
      \omit
      \ifdim \!taMinimumColumnWidth>\zeropoint
        \hskip \the\!taMinimumColumnWidth
      \fi
      &
      \omit}}

\def\!tfComputeMinColWidth
  {\setbox0\vbox
     {\ialign{% Plain's initialized \halign; \tabskip=0pt \everycr={}
      \span\the\!taDataColumnTemplate\cr
      \!tfWidthText\cr}}%
   \!taMinimumColumnWidth=\wd0 }

\def\!tfFinishFormat
  {\!thToksEdef\!taPreamble={####\tabskip\tablelefttabskip&\the\!taPreamble \tabskip\tablerighttabskip&####\tabskip\zeropoint\cr}
   \!taBeginFormatfalse
   \!ttDoHalign}

\def\ReFormat[#1]%
  {\omit
   \!taDataColumnTemplate{##}%
   \!taLeftGlue\emptytoks
   \!taRightGlue\emptytoks
   \begingroup
   \@@useotherbar
   \@@useotherquote
   \expanded{\endgroup\noexpand\ReadFormatKeys#1]}}% appear in a \ReFormat cmd; this is here as a safeguard.

\def\!tfEndReFormat
  {\!tfReFormat}

\appendtoks \TABLEparalignment \to \everytableparbox

\def\!tfReFormat#1%
  {\the \!taLeftGlue
   \vbox{\forgetall\ialign{\span\the\!taDataColumnTemplate\cr#1\cr}}%
   \the \!taRightGlue
   \kern\zeropoint} % prevents \unskip / really needed

\def\!tgGetValue#1%
  {\def\!tgReturn{#1}%
   \futurelet\!ttemp\!tgCheckForParen}

\def\!tgCheckForParen%
  {\ifx\!ttemp (%
     \expandafter \!tgDoParen
   \else
     \expandafter \!tgCheckForSpace
   \fi}

\def\!tgDoParen(#1)%
  {\def\!tgCode{2}%
   \def\!tgValue{#1}%
   \!tgReturn}

\def\!tgCheckForSpace
  {\def\!tgCode{1}%
   \let\!tgValue\empty
   \ifx\!ttemp\!thSpaceToken
     \expandafter \!tgReturn
   \else
     \expandafter \!tgCheckForDigit
   \fi}

\def\!tgCheckForDigit
  {\!taDigitfalse
        \ifx 0\!ttemp \!taDigittrue
   \else\ifx 1\!ttemp \!taDigittrue
   \else\ifx 2\!ttemp \!taDigittrue
   \else\ifx 3\!ttemp \!taDigittrue
   \else\ifx 4\!ttemp \!taDigittrue
   \else\ifx 5\!ttemp \!taDigittrue
   \else\ifx 6\!ttemp \!taDigittrue
   \else\ifx 7\!ttemp \!taDigittrue
   \else\ifx 8\!ttemp \!taDigittrue
   \else\ifx 9\!ttemp \!taDigittrue
   \fi\fi\fi\fi\fi\fi\fi\fi\fi\fi
   \if!taDigit
     \expandafter \!tgGetNumber
   \else
     \expandafter \!tgReturn
   \fi}

\def\!tgGetNumber {\afterassignment\!tgGetNumberA\!taCountA=}
\def\!tgGetNumberA{\edef\!tgValue{\the\!taCountA}\!tgReturn}

\def\!tgSetUpParBox
  {\normalexpanded
     {\noexpand \ReadFormatKeys
        b{\tablebeginparbox
            {\ifnum \!tgCode=1
               \ifx \!tgValue\empty
                 \tablecolumnwidthfactor
               \else
                 \!tgValue
               \fi
               \tablecolumnwidthunit
             \else
               \!tgValue
             \fi}}%
        a{\tableendparbox}}}

\def\!tgInsertKern
  {\edef\!ttemp
     {\kern
      \ifnum \!tgCode=1
        \ifx \!tgValue\empty
          \tablekernfactor
        \else
          \!tgValue
        \fi
        \tablekernunit
      \else
        \!tgValue
      \fi}%
   \edef\!ttemp
     {\noexpand\ReadFormatKeys
      \ifconditional\tablehasleftspacing
         b{\!ttemp}
      \fi
      \ifconditional\tablehasrightspacing
        a{\!ttemp}
      \fi}%
   \!ttemp}

\def\NewFormatKey  #1{\setvalue{!tk<\string#1>}}
\def\ReadFormatKeys#1{\getvalue{!tk<\string#1>}}

% Key "b":  b{TOKENS} adds TOKENS to the left of (before) the template

\NewFormatKey b#1%
  {\expandafter\!tkJoin\expandafter{\the\!taDataColumnTemplate}{#1}%
   \ReadFormatKeys}

\def\!tkJoin#1#2%
  {\!taDataColumnTemplate{#2#1}}%

% Key "a":  a{TOKENS} adds TOKENS to the right of (after) the template

\NewFormatKey a#1%
  {\!taDataColumnTemplate\expandafter{\the\!taDataColumnTemplate #1}%
   \ReadFormatKeys}

% Key "\{": Enclose template in braces.

\NewFormatKey \{%
  {\!taDataColumnTemplate=\expandafter{\expandafter{\the\!taDataColumnTemplate}}%
   \ReadFormatKeys}

% Key "*":  "*{N}{KEY LETTERS}" is equivalent to specifying
% <KEY LETTERS>  N  times.
% KEY LETTERS may contain further * specifications

\NewFormatKey *#1#2%
  {\!taCountA=#1\relax
   \!taToksA={}%
   \!thLoop
     \ifnum \!taCountA > 0
     \!taToksA\expandafter{\the\!taToksA #2}%
     \advance\!taCountA -1
   \repeat
   \expandafter\ReadFormatKeys\the\!taToksA}

% Key "\LeftGlue": Specifies the glue (usually \hfil, or nothing) to be
% added to extreme left of the template to position a column

\NewFormatKey \LeftGlue#1%
  {\!taLeftGlue{#1}%
   \ReadFormatKeys}

\NewFormatKey \RightGlue#1%
  {\!taRightGlue{#1}%
   \ReadFormatKeys}

\NewFormatKey c%
  {\prependtoks\raggedcenter\to\!taDataColumnTemplate
   \ReadFormatKeys \LeftGlue\hfil \RightGlue\hfil}

\NewFormatKey l%
  {\prependtoks\raggedright\to\!taDataColumnTemplate
   \ReadFormatKeys \LeftGlue\empty \RightGlue\hfil}

\NewFormatKey r%
  {\prependtoks\raggedleft\to\!taDataColumnTemplate
   \ReadFormatKeys \LeftGlue\hfil \RightGlue\empty}

\NewFormatKey x%
  {\prependtoks\notragged\to\!taDataColumnTemplate
   \ReadFormatKeys \LeftGlue\hfil \RightGlue\empty}

% Key "k": Adds kerns to left and right of "#"
% This key and the two below use Plain TeX's \if@h as if it were \if@left,
% and \if@v as if it were \if@right. Table making goes on in a group,
% so even in the unlikely circumstance that a \phantom is currently under
% construction, there's no problem.

\NewFormatKey k%
  {\settrue\tablehasleftspacing
   \settrue\tablehasrightspacing
   \!tgGetValue{\!tgInsertKern}}

% Key "i": Adds a kern to the left of "#"

\NewFormatKey i%
  {\settrue\tablehasleftspacing
   \setfalse\tablehasrightspacing
   \!tgGetValue{\!tgInsertKern}}

% Key "j": Adds a kern to the right of "#"

\NewFormatKey j%
  {\setfalse\tablehasleftspacing
   \settrue\tablehasrightspacing
   \!tgGetValue{\!tgInsertKern}}

% Key "n": numeric item , non-math mode.

\NewFormatKey n%
  {\def\!tnStyle{}%
   \futurelet\!tnext\!tnTestForBracket}

% Key "N": numeric item, math mode.

\NewFormatKey N%
  {\def\!tnStyle{$}%
   \futurelet\!tnext\!tnTestForBracket}

% Key "m": Math mode.

\NewFormatKey m%
  {\ReadFormatKeys b$ a$}

% Key "M": Displaymath mode.

\NewFormatKey M%
  {\ReadFormatKeys \{ b{$\displaystyle} a$}

% Key "\m": Template ${}#\hfil$
\NewFormatKey \m%
  {\ReadFormatKeys l b{{}} m}

% Key "\M": Template $\displaystyle{{}#\hfil}$

\NewFormatKey \M%
  {\ReadFormatKeys l b{{}} M}

% Key "f":  Set font  (E.g., f\it sets up italic font (assuming \it
% has its usual meaning)

\NewFormatKey f#1%
  {\ReadFormatKeys b{#1}}

\NewFormatKey B{\ReadFormatKeys f\bf} % Key "B": abbreviation for f\bf
\NewFormatKey I{\ReadFormatKeys f\it} % Key "I": abbreviation for f\it
\NewFormatKey S{\ReadFormatKeys f\sl} % Key "S": abbreviation for f\sl
\NewFormatKey R{\ReadFormatKeys f\rm} % Key "R": abbreviation for f\rm
\NewFormatKey T{\ReadFormatKeys f\tt} % Key "T": abbreviation for f\tt

% Key "p": ParBox

\NewFormatKey p%
  {\!tgGetValue{\!tgSetUpParBox}}

% Key "w": minimum column width

\NewFormatKey w%
  {\!tkTestForBeginFormat w{\!tgGetValue{\!tfSetWidth}}}

% Key "s": Set tabskip for the inter-column space to the right
% of the current column, and all subsequent spaces, until overriden
% by a new "s" or "o" key.

\NewFormatKey s%
  {\!taOnceOnlyTabskipfalse    % in case same column has a prior "o" key
   \!tkTestForBeginFormat t{\!tgGetValue{\!tfSetTabskip}}}

% Key "o": Apply the \tabskip stated for this column ONLY to the
% inter-column space just to the right of this column; restore the
% the previous \tabskip for subsequent columns.

\NewFormatKey o%
  {\!taOnceOnlyTabskiptrue
   \!tkTestForBeginFormat o{\!tgGetValue{\!tfSetTabskip}}}

% Key "|": Standard rule column designator

\NewFormatKey |%
  {\!tkTestForBeginFormat |{\!tgGetValue{\!tfSetVrule}}}

% Key "\|": Non-standard rule column designator

\NewFormatKey \|%
  {\!tkTestForBeginFormat \|{\!tfSetAlternateVrule}}

% Key ".":  PERIOD -- end of \BeginFormat section.

\NewFormatKey .%
  {\!tkTestForBeginFormat.{\!tfFinishFormat}}

% Key "\EndFormat": Equivalent to "."

\NewFormatKey \EndFormat
  {\!tkTestForBeginFormat\EndFormat{\!tfFinishFormat}}

% Key "]": End of \ReFormat section

\NewFormatKey ]%
  {\!tkTestForReFormat ] \!tfEndReFormat}

% TEST FOR BEGIN FORMAT{<Key>}{Intended Action}: This test is run
% on keys that can only be used by \BeginFormat ---  "s",  "o",
% "|",  "\|",  "w",  ".",  and  "\EndFormat".

\def\!tkTestForBeginFormat#1#2%
  {\if!taBeginFormat
     \def\!ttemp{#2}%
     \expandafter \!ttemp
   \else
     \toks0={#1}%
     \toks2=\expandafter{\string\ReFormat}%
     \expandafter \!tkImproperUse
   \fi}

% TEST FOR RE FORMAT{<Key>}{Intended Action}: This test is run
% on the key "]", which can only be used by \ReFormat.

\def\!tkTestForReFormat#1#2%
  {\if!taBeginFormat
     \toks0={#1}%
     \toks2=\expandafter{\string\BeginFormat}%
     \expandafter \!tkImproperUse
   \else
     \def\!ttemp{#2}%
     \expandafter \!ttemp
   \fi}

% NOTE: THE SPACE BETWEEN A NUMERIC ENTRY AND THE FOLLOWING '|', '"',
%   OR '\|' IS MANDATORY.
% EMPTY NUMERIC ENTRIES ARE NOT ALLOWED: USE '{}' OR '\omit' INSTEAD.

% TEST FOR BRACKET: Invoked by the keys "n" and "N".

\def\!tnTestForBracket
  {\ifx [\!tnext
     \expandafter\!tnGetArgument
   \else
     \expandafter\!tnGetCode
   \fi}

% GET CODE: E.g. "4", or "4.0", "0.4", or "10.2"

\def\!tnGetCode#1 %
  {\!tnConvertCode #1..!}

% CONVERT CODE: E.g. converts above to [0000], [0000.], [.0000],
% [0000000000.00]

\def\!tnConvertCode #1.#2.#3!%
  {\begingroup
   \aftergroup\edef \aftergroup\!ttemp \aftergroup{%
     \aftergroup[%
     \!taCountA #1
     \!thLoop
       \ifnum \!taCountA>0
       \advance\!taCountA -1
       \aftergroup0
     \repeat
     \def\!ttemp{#3}%
     \ifx\!ttemp \empty
     \else
       \aftergroup.
       \!taCountA #2
       \!thLoop
         \ifnum \!taCountA>0
         \advance\!taCountA -1
         \aftergroup0
       \repeat
     \fi
     \aftergroup]\aftergroup}%
   \endgroup\relax
   \expandafter\!tnGetArgument\!ttemp}

% GET ARGUMENT: [<sample left field> <optional .<sample right field>>

\def\!tnGetArgument[#1]%
  {\!tnMakeNumericTemplate\!tnStyle#1..!}

% MAKE NUMERIC TEMPLATE

\def\!tnMakeNumericTemplate#1#2.#3.#4!% #1=<empty> or $
  {\def\!ttemp{#4}%
   \ifx\!ttemp\empty
     \!taDimenC=0pt
   \else
     \setbox0=\hbox{\mathsurround\zeropoint #1.#3#1}%
     \!taDimenC=\wd0
   \fi
   \setbox0 =\hbox{\mathsurround\zeropoint #1#2#1}%
   \!thToksEdef\!taDataColumnTemplate={%
     \noexpand\!tnSetNumericItem
     {\the\wd0 }%
     {\the\!taDimenC}%
     {#1}%
     \the\!taDataColumnTemplate}  % Might have tabskip glue in here
   \ReadFormatKeys}

% SET NUMERIC ITEM

\def\!tnSetNumericItem #1#2#3#4 %
  {\!tnSetNumericItemA {#1}{#2}{#3}#4..!}

\def\!tnSetNumericItemA #1#2#3#4.#5.#6!%
  {\def\!ttemp{#6}%
   \hbox to #1{\hss \mathsurround\zeropoint #3#4#3}%
   \hbox to #2{\ifx\!ttemp\empty\else\mathsurround\zeropoint #3.#5#3\fi\hss}}

% extensions

\NewFormatKey q%
  {\letempty\!tqStyle
   \futurelet\!tnext\!tqTestForBracket}

\NewFormatKey Q%
  {\def\!tqStyle{$}%
   \futurelet\!tnext\!tqTestForBracket}

\def\!tqTestForBracket
  {\ifx[\!tnext
     \!thx\!tqGetArgument
   \else
     \!thx\!tqGetCode
   \fi}

\def\!tqGetCode#1 % note the blank
  {\!tqConvertCode #1,,!}

\def\!tqConvertCode #1,#2,#3!%
  {\begingroup
   \aftergroup\edef
   \aftergroup\!ttemp
   \aftergroup{%
   \aftergroup[%
   \!taCountA #1
   \!thLoop
     \ifnum \!taCountA>0 % \zerocount
       \advance\!taCountA \minusone
       \aftergroup0
   \repeat
   \def\!ttemp{#3}%
   \ifx\!ttemp\empty
   \else
     \aftergroup,
     \!taCountA #2
     \!thLoop
       \ifnum\!taCountA>0 % \zerocount
         \advance\!taCountA \minusone
         \aftergroup0
     \repeat
   \fi
   \aftergroup]\aftergroup}%
   \endgroup\relax
   \!thx\!tqGetArgument\!ttemp}

\def\!tqGetArgument[#1]%
  {\!tqMakeQuantityTemplate\!tqStyle#1,,!}

\def\!tqMakeQuantityTemplate#1#2,#3,#4!%  #1=<empty> or $
  {\def\!ttemp{#4}%
   \ifx\!ttemp\empty
     \!taDimenC\zeropoint
   \else
     \setbox0\hbox{\mathsurround\zeropoint #1,#3#1}%
     \!taDimenC\wd0
   \fi
   \setbox0\hbox{\mathsurround\zeropoint #1#2#1}%
   \!thToksEdef\!taDataColumnTemplate
     ={\noexpand\!tqSetQuantityItem{\the\wd0 }{\the\!taDimenC}{#1}%
       \the\!taDataColumnTemplate}%
  \ReadFormatKeys}

\def\!tqSetQuantityItem #1#2#3#4 %
  {\!tqSetQuantityItemA{#1}{#2}{#3}#4,,!}

\def\!tqSetQuantityItemA #1#2#3#4,#5,#6!%
  {\def\!ttemp{#6}%
   \hbox to #1{\hss\mathsurround\zeropoint#3#4#3}%
   \hbox to #2{\ifx\!ttemp\empty\else\mathsurround\zeropoint#3,#5#3\fi\hss}}

% struts

\def\tableMakeStrut#1#2%
  {\vrule\!!width\zeropoint\!!height#1\!!depth#2\relax}

\def\tableStandardTableStrut
  {\tableMakeStrut
     {\tablestrutheightfactor\tablestrutunit}
     {\tablestrutdepthfactor\tablestrutunit }}

\def\tableAugmentedTableStrut#1#2%
  {\tableMakeStrut
     {\dimexpr\tablestrutheightfactor\tablestrutunit+#1\tablestrutunit\relax}
     {\dimexpr\tablestrutdepthfactor \tablestrutunit+#2\tablestrutunit\relax}}

\appendtoks
    \let\MakeStrut          \tableMakeStrut
    \let\StandardTableStrut \tableStandardTableStrut
    \let\AugmentedTableStrut\tableAugmentedTableStrut
\to \everytable

% \Enlarge<extra height><extra depth><original>
% \enlarge<multiple for extra height><multiple for extra depth><original>

\def\tableEnlarge#1#2%
  {%  3rd argument is picked up later
   % #1=extra height
   % #2=extra depth
   \!taDimenA=#1\relax
   \!taDimenB=#2\relax
   \let\!TsSpaceFactor\empty
   \ifmmode
     \expandafter \mathpalette
     \expandafter \!TsEnlargeMath
   \else
     \expandafter \!TsEnlargeOther
   \fi}

\def\!TsEnlargeOther#1%
  {\ifhmode
     \setbox\zerocount\hbox{#1\xdef\!TsSpaceFactor{\spacefactor=\the\spacefactor}}%
   \else
     \setbox\zerocount\hbox{#1}%
   \fi
   \!TsFinishEnlarge}

\def\!TsEnlargeMath#1#2%
  {\setbox\zerocount\hbox{$\mathsurround\zeropoint#1{#2}$}%
   \!TsFinishEnlarge}

\def\!TsFinishEnlarge
  {\dimen@\ht\zerocount
   \advance \dimen@ \!taDimenA
   \ht\zerocount\dimen@
   \dimen@\dp\zerocount
   \advance \dimen@ \!taDimenB
   \dp\zerocount\dimen@
   \box\zerocount \!TsSpaceFactor{}}

\def\tableenlarge#1#2%  3rd argument is picked up later
  {\tableEnlarge{#1\tablestrutunit}{#2\tablestrutunit}}

\appendtoks
    \let\enlarge\tableenlarge
    \let\Enlarge\tableEnlarge
\to \everytable

% BEGIN TABLE

\def\tablestandardbegin
  {\futurelet\!tnext\!ttBeginTable}

\def\!ttBeginTable
  {\ifx[\!tnext
     \def\!tnext{\!ttBeginTableA}%
   \else
     \def\!tnext{\!ttBeginTableA[c]}%
   \fi
   \!tnext}

\def\!ttBeginTableA[#1]%
  {\if#1u%                  % "unboxed" table
     \ifmmode
       \def\!ttEndTable{\relax}% user had better be in display math mode and have only one table at the outer level
     \else                      % user had better be in vertical mode
       \bgroup
       \def\!ttEndTable{\egroup}%
     \fi
   \else
     \hbox\bgroup
     \def\!ttEndTable{\egroup\egroup}%
     \if#1t%
       \vtop
     \else\if#1b%
       \vbox
     \else
       \def\!ttEndTable{\egroup$\egroup}%
       %$\vcenter
       \scratchtoks\everymath\everymath\emptytoks$\everymath\scratchtoks\vcenter
     \fi\fi
     \bgroup % for the \vtop, \vbox, or \vcenter
   \fi
   \advance\!taRecursionLevel\plusone
   \let\!ttRightGlue\relax
   \everycr\emptytoks
   \ifnum\!taRecursionLevel=\plusone
     \the\everytable
   \fi}

\bgroup \catcode`\~=13

    \appendtoks
        \let\!ttTie=~%
        \let\!ttDH =\-%
        \catcode`\~=\active
        \def~{\kern.5em}%
        \def\\{\par}%
    \to \everytable

\egroup

\let\!ttRightGlue\relax  % This may be changed, in a group, by \JustCenter, etc

% DO HALIGN: Invoked by END FORMAT (or the key ".")

\def\!ttDoHalign
  {\edef\restoretablelineskips
     {\baselineskip \the\baselineskip
      \lineskiplimit\the\lineskiplimit
      \lineskip     \the\lineskip
      \tabskip      \the\tabskip
      \relax}%
   \baselineskip \zeropoint
   \lineskiplimit\zeropoint
   \lineskip     \zeropoint
   \tabskip      \zeropoint
   \halign
     \the\!taTableSpread
     \bgroup
     \span
     \the\!taPreamble
     \ifx\!tfRowOfWidths\empty\else
       \!tfRowOfWidths\cr
     \fi}

% END TABLE

\def\tablenormalend
  {\egroup % finishes the \halign
   \!ttEndTable}%    closes off the table envirnoment set up by \tablestandardbegin

\def\!ttEndOfRow
  {\futurelet\!tnext\!ttTestForBlank}

\def\!ttTestForBlank
  {\ifx\!tnext\!thSpaceToken  % the "usual" case
     \expandafter\!ttDoStandard
   \else
     \expandafter\!ttTestForZero
   \fi}

\def\!ttTestForZero
  {\ifx0\!tnext
     \expandafter\!ttDoZero
   \else
     \expandafter\!ttTestForPlus
   \fi}

\def\!ttTestForPlus
  {\ifx+\!tnext
     \expandafter\!ttDoPlus
   \else
     \expandafter\!ttDoStandard
   \fi}

% DO ZERO: No strut

\def\!ttDoZero#1%% #1 eats the 0
  {\cr}

\def\!ttDoPlus#1#2#3% #1 eats the +
  {\tableAugmentedTableStrut{#2}{#3}%
   \cr}

\def\!ttDoStandard
  {\tableStandardTableStrut
   \cr}

% ALTERNATE VRULE

\def\!ttAlternateVrule
  {\!tgGetValue{\!ttAVTestForCode}}  % AV == Alternate Vrule

% TEST FOR CODE (2)

\def\!ttAVTestForCode
  {\ifnum\!tgCode=\plustwo               % (...) follows "\|"
     \expandafter\!ttInsertVrule         % \InsertVrule ends with "&"
   \else
     \expandafter\!ttAVTestForEmpty
   \fi}

% TEST FOR EMPTY (VALUE)

\def\!ttAVTestForEmpty
  {\ifx\!tgValue\empty           % non-digit after "\|"
     \expandafter\!ttAVTestForBlank
   \else
     \expandafter\!ttInsertVrule         % integer after "\|"
   \fi}

% TEST FOR BLANK

\def\!ttAVTestForBlank
  {\ifx\!ttemp\!thSpaceToken     % blank after "\|"
     \expandafter\!ttInsertVrule
   \else
     \expandafter\!ttAVTestForStar
   \fi}

% TEST FOR STAR

\def\!ttAVTestForStar
  {\ifx*\!ttemp                  % "*" after "\|"
     \expandafter\!ttInsertDefaultPR     % PR == pseudo-rule
   \else
     \expandafter\!ttGetPseudoVrule      % "Anything else" after "\|"
   \fi}

% INSERT VRULE

\def\@VLn{1}
\def\@VLd{.125em}

\def\do!ttInsertVrule % will be merged in 2005
  {\vrule\!!width
     \ifnum\!tgCode=\plusone
       \ifx\!tgValue\empty
         \tablelinethicknessfactor
       \else
       \!tgValue
       \fi
       \tablelinethicknessunit
     \else
       \!tgValue
     \fi
   \hskip\@VLd}

\def\!ttInsertVrule
  {\hfil
   \ifcase\@VLn\or
     \do!ttInsertVrule
     \unskip
   \else
     \dorecurse\@VLn\do!ttInsertVrule
     \gdef\@VLn{1}%
     \unskip
   \fi
   \hfil
   &}

% INSERT DEFAULT PSEUDO-RULE

\def\!ttInsertDefaultPR*%
  {\PseudoVrule&}    % User-specified default pseudo-rule

% GET PSEUDO-RULE

\def\!ttGetPseudoVrule#1%
  {\toks0={#1}#1&}

% DEFAULT PSEUDO-RULE

\let\PseudoVrule\empty

% USE

\def\!ttuse#1%
  {\ifnum#1>\plusone
     \omit
     \global\TABLEdivisionfalse
     \scratchcounter\numexpr\currentTABLEcolumn+#1-\plusone\relax % added
     \ifnum\scratchcounter>\maxTABLEcolumn                        % added
       \def\next                                                  % added
         {\setTABLEerror\TABLEspanoverflow                        % added
          \handleTABLEerror}%                                     % added
     \else                                                        % added
       \def\next                                                  % added
         {\global\advance\currentTABLEcolumn#1-\plusone\relax     % added
          \scratchcounter2\numexpr#1-\plusone\relax               % changed
          \!thLoop
            \ifnum\scratchcounter>\plusone
              \span
              \omit
              \advance\scratchcounter\minusone
          \repeat
          \span}%
     \fi                                                 % added
   \else                                                 % added
     \def\next % conflicts with possible next \omit      % added
       {\global\advance\currentTABLEcolumn\plusone}%    % added
   \fi
   \next}                                                % added

\def\!ttUse#1[%
  {\!ttuse{#1}%
   \ReFormat[}

\appendtoks
    \let\use            \!ttuse
    \let\Use            \!ttUse
\to \everytable

% rules

\def\!ttFullHrule
  {\noalign
   \bgroup
   \!tgGetValue{\!ttFullHruleA}}

\def\!ttFullHruleA
  {\!ttGetHalfRuleThickness
   \hrule\!!height\dimen0\!!depth\dimen0
   %\penalty0 % removed
   \egroup}

\def\!ttShortHrule
  {\omit
   \!tgGetValue{\!ttShortHruleA}}

\def\!ttShortHruleA
  {\!ttGetHalfRuleThickness
   \leaders\hrule\!!height\dimen0\!!depth\dimen0\hfill
   \null
   \ignorespaces}

\def\!ttLongHrule
  {\omit\span\omit\span\!ttShortHrule}

\def\!ttGetHalfRuleThickness
  {\dimen0=
     \ifnum\!tgCode=\plusone
       \ifx\!tgValue\empty
         \tablelinethicknessfactor
       \else
         \!tgValue    % user-specified integer
       \fi
       \tablelinethicknessunit
     \else
       \!tgValue      % user-specified dimension
     \fi
  \divide\dimen0 \plustwo}

% \null prevents \unskip

\def\tableLeft  #1{#1\hfill\null}
\def\tableCenter#1{\hfill#1\hfill\null}
\def\tableRight #1{\hfill#1}

\def\tableOpenUp#1#2%
  {\scratchdimen\tablestrutheightfactor \points \advance\scratchdimen #1\points
   \edef\tablestrutheightfactor{\withoutpt\the\scratchdimen}%
   \scratchdimen\tablestrutdepthfactor  \points \advance\scratchdimen #2\points
   \edef\tablestrutdepthfactor{\withoutpt\the\scratchdimen}}

\def\tableSetTableToWidth#1%
  {\doifelsenothing{#1}{\!taTableSpread\emptytoks}{\!taTableSpread{to #1}}}

\def\tableWidenTableBy#1%
  {\ifdim#1=\zeropoint
     \!taTableSpread\emptytoks
   \else
     \!taTableSpread{spread #1}%
   \fi}

\def\tableExpand
  {\tableSetTableToWidth{\hsize}}

\def\tableLongLines
  {\tablelefttabskip \zeropoint \!!plus 1fill
   \tablerighttabskip\tablelefttabskip
   \tableExpand}

\def\tableJustLeft  {\omit\let\!ttRightGlue\hfill}
\def\tableJustCenter{\omit\hfill\null\let\!ttRightGlue\hfill}
\def\tableJustRight {\omit\hfill\null}

\def\tableSmash
  {\relax
   \ifmmode
     \expandafter\mathpalette
     \expandafter\!thDoMathVCS
   \else
     \expandafter\!thDoVCS
   \fi}

\def\!thDoVCS#1%
  {\setbox\zerocount\hbox{#1}%
   \!thFinishVCS}

\def\!thDoMathVCS#1#2%
  {\setbox\zerocount\hbox{$\mathsurround\zeropoint#1{#2}$}%
   \!thFinishVCS}

\def\!thFinishVCS
  {\vbox to\zeropoint{\vss\box\zerocount\vss}}

\def\tableRaise
  {\def\!thSign{+}%
   \!tgGetValue\!thSetDimen}

\def\tableLower
  {\def\!thSign{-}%
   \!tgGetValue\!thSetDimen}

\def\!thSetDimen
  {\ifnum\!tgCode=\plusone
     \ifx\!tgValue\empty
       \!taDimenA\tablestrutheightfactor\tablestrutunit
       \advance\!taDimenA\tablestrutdepthfactor\tablestrutunit
       \divide\!taDimenA\plustwo
     \else
       \!taDimenA\!tgValue\tablestrutunit
     \fi
   \else
     \!taDimenA\!tgValue
   \fi
   \!taDimenA\!thSign\!taDimenA\relax
   \ifmmode
     \expandafter\mathpalette
     \expandafter\!thDoMathRaise
   \else
     \expandafter\!thDoSimpleRaise
   \fi}

\def\!thDoSimpleRaise#1%
  {\setbox\zerocount\hbox{\raise \!taDimenA\hbox{#1}}%
   \!thFinishRaise} % From Plain TeX: \ht0=0pt \dp0=0pt \box0

\def\!thDoMathRaise#1#2%
  {\setbox\zerocount\hbox{\raise \!taDimenA\hbox{$\mathsurround\zeropoint#1{#2}$}}%
   \!thFinishRaise}

\def\!thFinishRaise
  {\ht\zerocount\zeropoint
   \dp\zerocount\zeropoint
   \box\zerocount}

\def\tableBackSpace
  {\!tgGetValue\!thKernBack}

\def\!thKernBack
  {\kern -
   \ifnum\!tgCode=\plusone
     \ifx\!tgValue\empty
       \tablekernfactor
     \else
       \!tgValue    % user-specified integer
     \fi
     \tablekernunit
   \else
     \!tgValue      % user-specified dimension
   \fi
   \ignorespaces}

\def\tableVspace
  {\noalign
   \bgroup
   \!tgGetValue\!thVspace}

\def\!thVspace
  {\vskip
     \ifnum\!tgCode=\plusone
       \ifx\!tgValue\empty
         \tablevspacefactor
       \else
         \!tgValue    % user-specified integer
       \fi
       \tablestrutunit
     \else
       \!tgValue      % user-specified skip
     \fi
   \egroup} % Ends the \noalign

\appendtoks
    \let\SetTableToWidth\tableSetTableToWidth
    \let\WidenTableBy   \tableWidenTableBy
    \let\Expand         \tableExpand
    \let\LongLines      \tableLongLines
    \let\JustLeft       \tableJustLeft
    \let\JustCenter     \tableJustCenter
    \let\JustRight      \tableJustRight
    \let\Smash          \tableSmash
    \let\Raise          \tableRaise
    \let\Lower          \tableLower
    \let\BackSpace      \tableBackSpace
    \let\Vspace         \tableVspace
    \let\OpenUp         \tableOpenUp
    \let\tableLeft      \tableLeft
    \let\tableCenter    \tableCenter
    \let\tableRight     \tableRight
\to \everytable

\protect

%D We felt no need to write our own table building macros,
%D simply because Michael Wichura made a terrific one. This
%D package is quite complete and well documented. In \CONTEXT\
%D we provide a shell for consistent spacing as well as color
%D support. Implementing these features without adapting the
%D original macros is not trivial. One easilly gets conflicts
%D with \type{\omit}, \type{\span} and \type{\noalign}, which
%D means that we end up postponing and overloading macros,
%D mostly global. Now, let's start with loading the main
%D macros.

\unprotect

%D \macros
%D   {inintable, ifsplittables}
%D
%D First we declare some variables. These show a bit what we
%D are dealing with. First we introdoce some booleans that
%D enable us, inside as well as outside this module, to
%D determine in what mode we are.

\newif\ifintable
\newif\ifsplittables

%D We show this feature in an eample that also shows some of
%D the basic table typesetting commands.
%D
%D \startbuffer
%D \starttable[|||]
%D \HL
%D \VL first \VL second \VL\AR
%D \HL
%D \VL alfa  \VL 1      \VL\AR
%D \VL beta  \VL 2      \VL\AR
%D \VL gamma \VL 3      \VL\AR
%D \HL
%D \stoptable
%D \stopbuffer
%D
%D \startcombination
%D   {\tracetablesfalse\getbuffer} {\type{\tracetablesfalse}}
%D   {\tracetablestrue\getbuffer}  {\type{\tracetablestrue}}
%D \stopcombination
%D
%D This table is specified as:
%D
%D \typebuffer
%D
%D This examples shows about the minimum of commands needed to
%D typeset such a table. In this table, the \type {\AR} is
%D automatically translated into the more primitive (but more
%D verbose) commands \type {\SR}, \type {\FR}, \type {\MR} and
%D \type {\LR} commands.
%D
%D \startbuffer
%D \starttables[|||]
%D \HL
%D \VL first \VL second \VL\AR
%D \HL
%D \VL alfa  \VL 1      \VL\AR
%D \VL beta  \VL 2      \VL\AR
%D \VL gamma \VL 3      \VL\AR
%D \HL
%D \stoptable
%D \stopbuffer
%D
%D When we use the split table feature, we get a bit more
%D information.
%D
%D {\tracetablesfalse\getbuffer}
%D
%D Sometimes in tables information shows up that is not typed
%D in by the user. These messages give a cue in what aspect a
%D table definition is wrong.
%D
%D \startbuffer
%D \starttable[||||]
%D \HL
%D \VL first     second    \VL third \VL\AR
%D \HL
%D \VL alfa  \VL 1         \VL a     \VL\AR
%D \VL beta  \VL 2         \VL b     \VL
%D \VL gamma \VL \THREE{3}     c     \VL\AR
%D \HL
%D \stoptable
%D \stopbuffer
%D
%D \typebuffer
%D
%D Those terrible table has three errors, which all show up in
%D typeset messages. Errors cannot always recovered 100\% and
%D therefore can result in two or more succesive messages, like
%D in the last row.
%D
%D \getbuffer

%D Bringing color into tables is complicated by the mere fact
%D that color is not part of \TEX. The main complication is
%D that we don't know in advance how wide a column will be. I
%D implemented color support in tables in the early 90's
%D because I needed it for some articles on color. I have to
%D admit that I seldom use the mechanism.
%D
%D Most color support in \CONTEXT\ makes use of colored rules.
%D At first sight, one is tempted to implement colors in tables
%D in a similar way, but as said, we don't know the dimensions
%D in advance. It turns out however that we don't have to,
%D simply because alignments take care of stretching rules to
%D the appropritate dimensions. This means that we can provide
%D backgrounds by coloring rules with the height of a row,
%D skipping upwards and finally drawing the content, like in:
%D
%D \gdef\ShowExample
%D   {\startfiguretext
%D      {none}
%D      {\getbuffer}
%D    \typebuffer
%D    \stopfiguretext}
%D
%D \startbuffer
%D \starttable[|c|c|]
%D \HL
%D \BL[2]               \SR
%D \VL test \VL test \VL\SR
%D \HL
%D \VL test \VL test \VL\FR
%D \VL test \VL test \VL\MR
%D \VL test \VL test \VL\LR
%D \HL
%D \stoptable
%D \stopbuffer
%D
%D \ShowExample
%D
%D Just to be complete we show how the other columns can be
%D given a background. Later we will provide more details over
%D the commands used.
%D
%D \startbuffer
%D \starttable[|c|c|c|]
%D \HL
%D \BL[3]                        \SR
%D \VL test \VL test \VL test \VL\SR
%D \HL
%D \stoptable
%D \stopbuffer
%D
%D \ShowExample
%D
%D \startbuffer
%D \starttable[|c|c|c|]
%D \HL
%D \BC      \BL[2]               \SR
%D \VL test \VL test \VL test \VL\SR
%D \HL
%D \stoptable
%D \stopbuffer
%D
%D \ShowExample
%D
%D \startbuffer
%D \starttable[|c|c|c|]
%D \HL
%D \BC      \BC      \BL         \SR
%D \VL test \VL test \VL test \VL\SR
%D \HL
%D \stoptable
%D \stopbuffer
%D
%D \ShowExample
%D
%D \startbuffer
%D \starttable[|c|c|c|]
%D \HL
%D \BC      \BL                  \SR
%D \VL test \VL test \VL test \VL\SR
%D \HL
%D \stoptable
%D \stopbuffer
%D
%D \ShowExample
%D
%D \startbuffer
%D \starttable[|c|c|c|]
%D \BL               \BL         \SR
%D \HL
%D \VL test \VL test \VL test \VL\SR
%D \HL
%D \stoptable
%D \stopbuffer
%D
%D \ShowExample

%D In these examples we can clearly see that for being a real
%D background, the color or gray specification has to precede
%D the content. Just to keep things simple, we can recall this
%D specification later on:
%D
%D \startbuffer
%D \starttable[|c|c|c|]
%D \BC      \BL                  \SR
%D \HL
%D \VL test \VL test \VL test \VL\SR
%D \HL
%D                            \BR\FR
%D \VL test \VL test \VL test \VL\FR
%D                            \BR\MR
%D \VL test \VL test \VL test \VL\MR
%D                            \BR\LR
%D \VL test \VL test \VL test \VL\LR
%D \HL
%D \stoptable
%D \stopbuffer
%D
%D \ShowExample
%D
%D Close study learns that we can put the specification
%D before or after the \type{\HL}, whatever suits best. Keeping
%D track of these specifications is taken care of by the next
%D variables:

\newif\ifTABLEinbreak

%D Nog vervangen:

\def\c!Table{Table}
\def\m!TABLE{TABLE}

%D We already saw that the table macros report errors and
%D provide automatic spacing. These features can only be
%D implemented by keeping track of the state, often the last
%D command on a row.

\setnewconstant\TABLEunknown          0

\setnewconstant\TABLEseparaterow      1
\setnewconstant\TABLEfirstrow         2
\setnewconstant\TABLEmidrow           3
\setnewconstant\TABLElastrow          4
\setnewconstant\TABLErule             5
\setnewconstant\TABLEskip             6
\setnewconstant\TABLEautorow          7

\setnewconstant\TABLEforcefirstrow    1
\setnewconstant\TABLEforcelastrow     2

\newconstant\TABLErowfactor
\newconstant\TABLEendofrowdepth
\newconstant\TABLEendofrowheight
\newconstant\TABLEcr
\newconstant\TABLErowzero
\newconstant\TABLEn
\newconstant\TABLEforce
\newconstant\TABLEaction

%D We store these states using \type {constants}'s and
%D like most variables, these are global ones. When needed,
%D especially when we flush the backgrounds, we can temporary
%D disable the assignment.

\newif\ifsetTABLEaction

\def\setTABLEaction#1{\ifsetTABLEaction\global\TABLEaction#1\fi}
\def\setTABLEforce #1{\ifsetTABLEaction\global\TABLEforce #1\fi}

%D To keep things verbose, as well as to show what \TABLE\
%D commands we affect, we show some meanings.

\def\normalTABLEshortrule  {\!ttShortHrule} % \-
\def\normalTABLElongrule   {\!ttLongHrule} % \=
\def\normalTABLEfullrule   {\!ttFullHrule} % \_
\def\normalTABLEendofrow   {\!ttEndOfRow} % \\
\def\normalTABLEsimplebar  {\unskip\!ttRightGlue&&} % |
\def\normalTABLEcomplexbar {\unskip\!ttRightGlue&\omit\!ttAlternateVrule} % \|
\def\normalTABLEquote      {\unskip\!ttRightGlue&\omit&} % "
\def\normalTABLElineformat {\normalTABLEendofrow+}
\def\normalTABLElineending {\normalTABLEendofrow0 }
\def\normalTABLEsinglerule {&\normalTABLElongrule&}
\def\normalTABLEmultirule#1{&\use{#1}\normalTABLElongrule&}

%D To give an impression of what the (well documented) source
%D of \TABLE\ looks like, we first implement an alternative for
%D the numeric keys. The quantity keys (\type{q} and \type{Q})
%D support the more european way of writing numbers:
%D
%D \startnarrower
%D 100.000.000,00 instead of 100,000,000.00
%D \stopnarrower
%D
%D The next table shows how to use these keys. We use braces
%D instead of brackets because we need brackets to specify the
%D format.
%D
%D \startbuffer
%D \starttable{|q[00,000]|Q[00,00]|}
%D \HL
%D \VL -1,2   \VL 12,35 \VL\FR
%D \VL 11,203 \VL  2,4  \VL\LR
%D \HL
%D \stoptable
%D \stopbuffer
%D
%D \ShowExample
%D
%D Although a more efficient implementation is possible |<|we
%D can for instance share common macros|>| we just adapt a copy
%D of the numeric ones. To permit double loading of this
%D module, we check for the existence of one of the macros.

%D To be compatible with the tabulate environment, we also
%D support the \type {l}, \type {c} and \type {r} keys for
%D paragraph entries.

%D We already showed the next one, but here we slightly adapt
%D the macro by adding an \type{\expandafter}. The space after
%D \type{#1} is crucial!

\def\normalTABLEcomplexbar#1%
  {\unskip\!ttRightGlue&\omit\expandafter\!ttAlternateVrule#1 }

%D All commands that are executed between rows are to be put in
%D \type {\noalign}. We can however not verify if we (that is
%D \TABLE) does or did not enter this mode. A moderate dirty
%D but useful trick is using our own alternative:\footnote{Once
%D one has entered the stage of redefining \TEX\ primitives,
%D such hacks become a second nature. However, redefining \type
%D {\omit} and \type{\span} is not that easy.}

\def\TABLEnoalign
  {\noalign\bgroup\let\noalign\relax\let\next=}

%D \macros
%D   {starttable}
%D
%D The rest of this module is not easy to comprehend, mainly
%D because we have to take care of:
%D
%D \startitemize[packed]
%D \item  \type{\startitemize[template]}
%D \item  \type{\startitemize{template}}
%D \item  \type{\startitemize[predefined]}
%D \stopitemize
%D
%D as well as:
%D
%D \startitemize[continue]
%D \item  restart after table break
%D \stopitemize
%D
%D The official specification of the start command is:
%D
%D \showsetup{starttable}

\newconditional\tablerepeathead
\newconditional\tablerepeattail

\unexpanded\def\starttable
  {\bgroup
   \let\stoptable\dostoptable
   \doif\@@tisplit\v!auto
     {\ifinsidesplitfloat\let\@@tisplit\v!yes\fi}%
   \doifinsetelse\@@tisplit{\v!yes,\v!repeat}
     {\unexpanded\def\stoptable{\stoptables\egroup}%
      \starttables}
     {\doifelsenothing\@@tiframe
        {\ifinsidefloat\else\startbaselinecorrection\fi}
        {\startframedcontent[\@@tiframe]}%
      \postponenotes
      \firststagestartTABLE}}

% We cannot define \unexpanded\def\dostoptable a ssomehow lookahead
% in alignments fail then, so we relax it and define it locally.

\let\stoptabel\relax

\def\dostoptable
  {\chuckTABLEautorow % before the tail, else noalign problem
   \insertTABLEtail
   \TABLEnoalign{\globalletempty\@@TABLEhead}%
   \TABLEnoalign{\globalletempty\@@TABLEtail}%
   \finishTABLE
   \doifelsenothing\@@tiframe
     {\ifinsidefloat\else
        \stopbaselinecorrection
        \goodbreak % compensates all the nobreaks
      \fi}
     \stopframedcontent
   \egroup}

%D Before we can grab the argument, we have to make sure that
%D the \CATCODES\ are set. The first stage takes care of that.

\def\firststagestartTABLE
  {\bgroup                   % kan-ie weg?
   \global\intabletrue
   %catcode`\|=\othercatcode
   \complexorsimple\secondstagestartTABLE}

\def\simplesecondstagestartTABLE#1%
  {\complexsecondstagestartTABLE[{#1}]}

%D \macros
%D   {definetabletemplate}
%D
%D The complex (and main) start macro first takes care of the
%D predefined case. Such a predefined setup looks like:
%D
%D \starttyping
%D \definetabletemplate[test][|||]
%D
%D \starttable[test]
%D \VL test \VL test \VL\AR
%D \VL test \VL test \VL\AR
%D \VL test \VL test \VL\AR
%D \stoptable
%D \stoptyping
%D
%D The implementation of the definition macro is not that
%D complicated:

\unexpanded\def\definetabletemplate % to be redone
  {\bgroup
   \catcode`\|=\othercatcode
   \doquadrupleempty\dodefinetabletemplate}

\def\dodefinetabletemplate[#1][#2][#3][#4]%
  {\ifsecondargument
     \setgvalue{\c!Table#1}{\douseTABLEtemplate{#2}{#3}{#4}}%
   \fi
   \egroup}

\def\douseTABLEtemplate#1#2#3%
  {\gdef\TABLEhead{\getvalue{@@TABLEhead#2}}%
   \gdef\TABLEtail{\getvalue{@@TABLEtail#3}}%
   \complexsecondstagestartTABLE[#1]}

%D The optional third and fourth arguments define which table
%D head and tail to use.
%D
%D \starttyping
%D \definetabletemplate[test][|||][before][after]
%D \stoptyping
%D
%D This also means that one can define table heads and tails
%D by name!
%D
%D \starttyping
%D \starttablehead[before]
%D \HL \VL first \VL second \VL \SR \HL
%D \stoptablehead
%D \stoptyping
%D
%D Templates defined this way get protected names, that cannot
%D conflict with existing commands.
%D
%D \showsetup{definetabletemplate}
%D
%D The second half of the next macro prepares table
%D splitting.

\def\insertTABLEhead
  {\TABLEnoalign{\global\settrue \preventTABLEbreak \global\setfalse\someTABLEhead}%
   \TABLEhead
   \TABLEnoalign{\global\setfalse\preventTABLEbreak}}

\def\insertTABLEtail
  {\TABLEnoalign{\global\settrue \preventTABLEbreak \global\setfalse\someTABLEtail}%
   \TABLEtail
   \TABLEnoalign{\global\setfalse\preventTABLEbreak}}

\def\verysimpleTableHL
  {\TABLEnoalign{\expandafter\normalTABLEfullrule\@@tiHLheight}}

\def\dorestartTABLE#1%
  {\gdef\restartTABLE{#1}%
   \restartTABLE
   \TABLEnoalign{\globalpushmacro\simpleTableHL\global\let\simpleTableHL\verysimpleTableHL}%
   \insertTABLEhead
   \ifsplittables \ifconditional \tablerepeattail
     \TABLEnoalign{\goodbreak}%
     \insertTABLEtail
     \TABLEnoalign{\goodbreak}%
   \fi \fi
   \TABLEnoalign{\globalpopmacro\simpleTableHL}}

\bgroup \catcode`|=\othercatcode \catcode`"=\othercatcode

\gdef\complexsecondstagestartTABLE#1[#2]% brr nested mess
  {\bgroup
   \@@useotherbar
   \@@useotherquote
   \global\setfalse\someTABLEhead
   \global\setfalse\someTABLEtail
   \expanded{\doifinstringelse{|}{#2}}
     {\xdef\restartTABLE{\noexpand\dorestartTABLE{\noexpand\thirdstagestartTABLE{#2}}}}
     {\doifdefinedelse{\c!Table#2}
        {\gdef\restartTABLE{\getvalue{\c!Table#2}}}
        {\gdef\restartTABLE{\dorestartTABLE{\getvalue{#2}}}}}%
   \egroup
   \restartTABLE}

\egroup

%D The third stage involves a lot of (re)sets, which we will
%D explain later.

\appendtoks
    \fixedspaces
    \let\_\normalunderscore
\to \everytable

%D Now we can start the table.

\def\thirdstagestartTABLE#1%
  {\global\setTABLEactiontrue
   \setTABLEaction\TABLEunknown
   \setTABLEforce\TABLEunknown
   \resetVLvalues
   \appendtoks\localTABLEsetup\to\everytable
   \tablestandardbegin[\ifsplittables u\else b\fi]%
   \defineTABLEunits
   \defineTABLEsteps
   \defineTABLErules
   \defineTABLEdivisions
   \defineTABLEshorthands
   \defineTABLEendings
   \forgetall % added
   \doifsomething{#1}
     {\def\TABLEformat{#1}%
      \getTABLEnofcolumns\TABLEformat
      % more modern is to use catcode tables
      \expandafter\BeginFormat\TABLEformat\EndFormat}}

\def\finishTABLE
  {\chuckTABLEautorow
   \unskip\crcr
   \tablenormalend
   \global\intablefalse
   \egroup}

%D \macros
%D   {starttables}
%D
%D Split tables are specified using the plural form of the
%D start and stop commands.
%D
%D \showsetup{starttables}
%D
%D For example:
%D
%D \starttyping
%D \starttables[|||]
%D \HL
%D \VL element \VL atom weight \VL\AR
%D \HL
%D \VL ....... \VL ........... \VL\AR
%D \VL ....... \VL ........... \VL\AR
%D \HL
%D \stoptables
%D \stoptyping

\newbox\tablecontentbox

\unexpanded\def\starttables
  {\bgroup
   \let\stoptables\dostoptables
   \splittablestrue
   \doifelse\@@tisplit\v!repeat
     {\settrue \tablerepeathead\settrue \tablerepeattail}
     {\setfalse\tablerepeathead\setfalse\tablerepeattail}%
   \flushnotes
   \setbox\tablecontentbox\vbox\bgroup
   \forgetall
   \global\TABLEinbreakfalse
   \firststagestartTABLE}

\let\stoptables\relax % needed for \noalign

\def\dostoptables
  {\chuckTABLEautorow % AM: before the tail, else noalign problem
   \ifconditional\tablerepeattail\else\insertTABLEtail\fi
   \finishTABLE
   \egroup
   \dontcomplain
   \dosplittablebox\tablecontentbox
   \flushnotes
   \egroup}

\newdimen\TABLEcaptionheight % obsolete

\def\dosplittablebox#1%
  {\resettsplit
   \def\tsplitminimumfreelines{2}%
   \def\tsplitminimumfreespace{\TABLEcaptionheight}%
   \setbox\tsplitcontent\box#1%
   \ifconditional\tablerepeathead \ifconditional\someTABLEhead
     \setbox\tsplithead\vsplit\tsplitcontent to \lineheight
     \setbox\tsplithead\vbox{\unvbox\tsplithead}%
   \fi \fi
   \ifconditional\tablerepeattail \ifconditional\someTABLEtail
     \setbox\tsplittail\vsplit\tsplitcontent to \lineheight
     \setbox\tsplittail\vbox{\unvbox\tsplittail}%
   \fi \fi
   \ifinsidefloat\else
     \def\tsplitbeforeresult{\startbaselinecorrection}%
     \def\tsplitafterresult {\stopbaselinecorrection}%
   \fi
   \handletsplit}

%D When the table in the previous example is split across
%D pages, only the first gets a head. We could have said
%D something like:
%D
%D \starttyping
%D \starttablekop
%D \HL
%D \VL element \VL atom weight \VL\AR
%D \HL
%D \stoptablekop
%D
%D \starttablestaart
%D \HL
%D \stoptablestaart
%D
%D \starttables[|||]
%D \VL ....... \VL ........... \VL\AR
%D \VL ....... \VL ........... \VL\AR
%D \stoptables
%D \stoptyping
%D
%D This time each split table gets a head line and ends with
%D a rule. Keep in mind that such heads also apply to the
%D unbroken ones and should be defined local (grouped) if
%D needed. The rather complicated definition below is due to
%D the fact that the stopcondition is interface language
%D dependant.

\let\@@TABLEhead\empty  \def\TABLEhead{\@@TABLEhead}
\let\@@TABLEtail\empty  \def\TABLEtail{\@@TABLEtail}

\letvalue{\e!start\v!tablehead}=\undefined
\letvalue{\e!stop \v!tablehead}=\undefined
\letvalue{\e!start\v!tabletail}=\undefined
\letvalue{\e!stop \v!tabletail}=\undefined

\expanded
  {\long\def\csname\e!start\v!tablehead\endcsname##1\csname\e!stop\v!tablehead\endcsname%
     {\noexpand\setTABLEhead##1\noexpand\end}}

\expanded
  {\long\def\csname\e!start\v!tabletail\endcsname##1\csname\e!stop\v!tabletail\endcsname%
     {\noexpand\setTABLEtail##1\noexpand\end}}

%D The second argument is a dummy one, by scanning for it, we
%D get rid of interfering spaces.

\def\setTABLEhead{\dodoubleempty\dosetTABLEhead}
\def\setTABLEtail{\dodoubleempty\dosetTABLEtail}

\newconditional\preventTABLEbreak
\newconditional\someTABLEhead

\long\def\dosetTABLEhead[#1][#2]#3\end{\setvalue{@@TABLEhead#1}{\TABLEnoalign{\global\settrue\someTABLEhead}#3}}
\long\def\dosetTABLEtail[#1][#2]#3\end{\setvalue{@@TABLEtail#1}{\TABLEnoalign{\global\settrue\someTABLEtail}#3}}

%D Redudant \type{\HL}'s are removed automatically, so
%D mid||lines can be used without problems.

%D We need an alternative for the normal complex or simple
%D commands, because assignments in these system commands
%D conflict with \type{\noalign}. This alternative is about
%D as efficient as possible.

\def\complexorsimpleTable#1#2%
  {\csname\if[\noexpand#2\s!complex\else\s!simple\fi\c!Table#1\endcsname#2}

%D The next one is used in \type{\VL} cum suis and honours
%D the next grouping.

\def\docomplexorsimpleTable#1#2%
  {\ifx\next\bgroup\@EA#2\else\@EA\dodocomplexorsimpleTable\@EA#1\@EA#2\fi}

\def\dodocomplexorsimpleTable#1#2#3%
  {\if[\noexpand#3\@EA#1\else\@EA#2\fi#3}

%D The order of the next macros is more or less random. First
%D we implement error recovery. Errors are reported to the
%D screen and log file as well as visualized in the table in
%D teletype.

\def\finishTABLErow
  {\crcr
   \TABLEnoalign
     {\nobreak
      \setTABLEaction\TABLEunknown
      \globalletempty\checkTABLEautorow
      \globalletempty\chuckTABLEautorow
      \global\currentTABLEcolumn\zerocount}}

%D Next we enter the more complicated area of column and row
%D switching. I won't go into much detail from now on, but just
%D mention the general principles.
%D
%D \startitemize[3*ruim]
%D \sym{\type{\SR}} end a separate row (between rules)
%D \sym{\type{\FR}} end a first row (after a rule)
%D \sym{\type{\MR}} end a mid row (between text lines)
%D \sym{\type{\LR}} end a last row (before a rule)
%D \stopitemize
%D
%D and best of all:
%D
%D \startitemize[continue]
%D \sym{\type{\AR}} end a row with automatic spacing
%D \stopitemize
%D
%D As far as possible, we report confusing situations. In
%D most cases one can use \type{\AR}, which transfigurates
%D itself into one of the other types.
%D
%D \starttyping
%D \starttable[||]
%D \HL
%D \VL a separate row \VL\SR
%D \HL
%D \VL a first row    \VL\FR
%D \VL a mid row      \VL\MR
%D \VL a last row     \VL\LR
%D \HL
%D \stoptable
%D \stoptyping
%D
%D In this example we could have used \type{\AR} without
%D problems.
%D
%D Color or gray scale backgrounds precede the content. They
%D are passed over horizontal (division) lines when needed.
%D Errors in the color template are traced elsewhere. Here we
%D only check for inconsistent spacing. Due to the way \TEX\
%D handles alignments, we cannot automate spacing for colored
%D rows and columns.

\setnewconstant\TABLErowzero\zerocount

\unexpanded\def\defineTABLEendings
  {\let\SR\TableSR
   \let\FR\TableFR
   \let\MR\TableMR
   \let\LR\TableLR
   \let\AR\TableAR}

\unexpanded\def\TableSR
  {\ifnum\TABLEaction=\TABLEfirstrow
     \writestatus\m!TABLE{change \string\SR\space into \string\MR/\string\LR}%
   \else\ifnum\TABLEaction=\TABLEmidrow
     \writestatus\m!TABLE{change \string\SR\space into \string\MR/\string\LR}%
   \else\ifnum\TABLEaction=\TABLEmidrow
     \writestatus\m!TABLE{change \string\SR\space into \string\MR/\string\LR}%
   \fi\fi\fi
   \endTABLErow\TABLEseparaterow\TABLErowfactor\TABLErowfactor}

\unexpanded\def\TableFR
  {\ifnum\TABLEaction=\TABLEmidrow
     \writestatus\m!TABLE{change \string\FR\space into \string\MR/\string\LR}%
   \else\ifnum\TABLEaction=\TABLElastrow
     \writestatus\m!TABLE{change \string\FR\space into \string\MR/\string\LR}%
   \fi\fi
   \endTABLErow\TABLEfirstrow\TABLErowfactor\TABLErowzero}

\unexpanded\def\TableMR
  {\ifnum\TABLEaction=\TABLErule
     \writestatus\m!TABLE{change \string\MR\space into \string\FR/\string\SR}%
   \else\ifnum\TABLEaction=\TABLElastrow
     \writestatus\m!TABLE{change \string\MR\space into \string\FR}%
   \fi\fi
   \endTABLErow\TABLEmidrow00}

\unexpanded\def\TableLR
  {\ifnum\TABLEaction=\TABLErule
     \writestatus\m!TABLE{change \string\LR\space into \string\FR/\string\SR}%
   \fi
   \endTABLErow\TABLElastrow\TABLErowzero\TABLErowfactor}

%D \macros
%D   {ifcheckTABLEcolums}
%D
%D
%D The next macros handle the actual row ending. This macro
%D also take care of space corrections due to table splitting
%D when \type{\MR} and collegues are used. When tracing is
%D enabled, the corrections as well as the values used to
%D determine the available space are shown (in color). By default
%D checking is off.

\let\beforeTABLEline\empty
\let\afterTABLEline \empty

\def\doendTABLErow#1#2#3%
  {\handleTABLEbreak#2#3%
   \beforeTABLEline
   \ifcase#1\relax
     % unknown
   \or
     \endofTABLEline[blue][\SR->\SR]\TABLErowfactor\TABLErowfactor
   \or
     \endofTABLEline[red][\FR->\FR]\TABLErowfactor\TABLErowzero
   \or
     \ifnum\TABLEforce=\TABLEforcelastrow
       \endofTABLEline[red][\MR->\LR]\TABLErowzero\TABLErowfactor
     \else\ifnum\TABLEforce=\TABLEforcefirstrow
       \endofTABLEline[red][\MR->\FR]\TABLErowfactor\TABLErowzero
     \else
       \endofTABLEline[green][\MR->\MR]\TABLErowzero\TABLErowzero
     \fi\fi
   \or
     \endofTABLEline[red][\LR->\LR]\TABLErowzero\TABLErowfactor
   \fi
   \TABLEnoalign
     {\setTABLEforce\TABLEunknown
      \global\currentTABLEcolumn\zerocount}%
   \afterTABLEline}

\def\endTABLErow#1#2#3%
  {\setTABLEaction#1%
   \doendTABLErow{#1}{#2}{#3}}

%D Handling \type{\AR} is postponed till the next row. The
%D check takes care of the first and mid rows, the chuck macro
%D |<|how about that name|>| handles the last row.

\unexpanded\def\TableAR
  {\globallet\checkTABLEautorow\docheckTABLEautorow
   \globallet\chuckTABLEautorow\dochuckTABLEautorow}

\let\checkTABLEautorow\empty
\let\chuckTABLEautorow\empty

\def\docheckTABLEautorow
  {\globallet\checkTABLEautorow\empty
   \ifnum\TABLEaction=\TABLErule          \FR
   \else\ifnum\TABLEaction=\TABLEunknown  \FR
   \else                                  \MR
   \fi\fi}

\def\dochuckTABLEautorow
  {\globalletempty\checkTABLEautorow
   \globalletempty\chuckTABLEautorow
   \ifnum\TABLEaction=\TABLErule          \SR
   \else\ifnum\TABLEaction=\TABLEunknown  \SR
   \else                                  \LR
   \fi\fi}

%D When a table is split, we also add a tail and when present
%D we repeat the table head.

\def\handleTABLEbreak#1#2%
  {\globalletempty\beforeTABLEline
   \gdef\afterTABLEline{\TABLEnoalign{\ifconditional\preventTABLEbreak\nobreak\else\goodbreak\fi}}}

%D When tables are split, the spacing before and after a
%D horizontal rule is corrected according to what we expect.

\def\endofTABLEline[#1][#2->#3]#4#5%
  {\ifx#2#3\else
     \writestatus\m!TABLE{\string#2\space changed into \string#3}%
   \fi
   \expandafter\normalTABLElineformat#4#5\crcr % \crcr nodig ?
   \TABLEnoalign{\nobreak\global\setTABLEactiontrue}}

%D In order to prevent (as good as possible) alignment overflow
%D and therefore \TEX\ error messages, we check the maximum
%D number of columns. We keep track of the current column and
%D maximum column by means of two \COUNTERS. Keep in mind that
%D the number of \type{|}'s and \type{\VL}'s or alike is always
%D one more than the number of columns.

\newcount\currentTABLEcolumn
\newcount\maxTABLEcolumn % needed for reset vl properties

%D While defining this macro we change the \CATCODE\ of
%D \type{|}. When counting the bars, we use a non active
%D representation of the bar, simply because we cannot be sure
%D if the bar is active or not.\footnote{Normally it is, but
%D \TABLE\ changes the catcode when needed.}

\bgroup
    \catcode`\|=\othercatcode  \gdef\@@otherbar     {|}
    \catcode`\"=\othercatcode  \gdef\@@otherquote   {"}
    \catcode`\|=\activecatcode \gdef\@@useotherbar  {\let|\@@otherbar}
    \catcode`\"=\activecatcode \gdef\@@useotherquote{\let"\@@otherquote}
\egroup

\bgroup \catcode`\|=\othercatcode

\gdef\getTABLEnofcolumns#1%
  {\bgroup
   \cleanupfeatures % needed !
   \@@useotherbar
   \@@useotherquote
   \egroup}

\egroup

%D \startitemize[3*ruim]
%D \sym{\type{\VL}} a vertical line
%D \sym{\type{\VC}} a vertical colored line
%D \sym{\type{\HL}} a horizontal line
%D \sym{\type{\HC}} a horizontal colored line
%D \stopitemize

\unexpanded\def\defineTABLErules
  {\let\VL\TableVL
   \let\VC\TableVC
   \let\HL\TableHL
   \let\HC\TableHC
   \let\VS\TableVS
   \let\VD\TableVD
   \let\VT\TableVT
   \let\VN\TableVN}

\unexpanded\def\TableVL
  {\checkTABLEautorow
   \global\advance\currentTABLEcolumn \plusone
   \doTableVL}

\def\doTableVL
  {\futurelet\next\dodoTableVL}

\def\dodoTableVL
  {\docomplexorsimpleTable\complexTableVL\simpleTableVL}

\def\complexTableVL[#1]%
  {\scratchcounter=0#1%
   \multiply\scratchcounter \@@tiVLwidth
   \simpleTableVL}

\def\simpleTableVL
  {\expanded{\normalTABLEcomplexbar\@@tiVLwidth\space}}% \relax breaks \use

% \starttable[|||]
% \HL
% \VL test \VS test \VL \FR
% \VL test \VD test \VL \MR
% \VL test \VT test \VL \LR
% \HL
% \stoptable

\unexpanded\def\TableVS  {\VN1}
\unexpanded\def\TableVD  {\VN2}
\unexpanded\def\TableVT  {\VN3}
\unexpanded\def\TableVN#1{\gdef\@VLn{#1}\VL}

\def\resetVLvalues
  {\global\currentTABLEcolumn\zerocount}

\unexpanded\def\TableVC
  {\checkTABLEautorow
   \doTableVC}

\def\doTableVC
  {\futurelet\next\dodoTableVC}

\def\dodoTableVC
  {\docomplexorsimpleTable\complexTableVC\simpleTableVC}

\def\complexTableVC[#1]%
  {\setgvalue{bVC\the\currentTABLEcolumn}{\startcolor[#1]}%
   \setgvalue{eVC\the\currentTABLEcolumn}{\stopcolor}%
   \simpleTableVC}

\def\simpleTableVC
  {\setgvalue{bVL\the\currentTABLEcolumn}{\getvalue{bVC\the\currentTABLEcolumn}}%
   \setgvalue{eVL\the\currentTABLEcolumn}{\getvalue{eVC\the\currentTABLEcolumn}}%
   \doTableVL}

\unexpanded\def\TableHL
  {\finishTABLErow
   \complexorsimpleTable{HL}}

\def\complexTableHL[#1]%
  {\TABLEnoalign
     {\scratchcounter0#1%
      \multiply\scratchcounter \@@tiHLheight
      \edef\@@tiHLheight{\the\scratchcounter}}%
  \simpleTableHL}

\def\simpleTableHL
  {\TABLEnoalign
     {\nobreak
      \ifnum\TABLEaction=\TABLErule
        \writestatus\m!TABLE{skipping \string\HL}% \statusmessage
      \else
        \ifnum\TABLEaction=\TABLEmidrow
          \writestatus\m!TABLE{change \string\MR\space into \string\LR/\string\SR}%
        \else\ifnum\TABLEaction=\TABLEfirstrow
          \writestatus\m!TABLE{change \string\MR\space into \string\SR}%
        \fi\fi
        \startHLcommand
        \expandafter\normalTABLEfullrule\@@tiHLheight
        \stopHLcommand
        \globalletempty\startHLcommand
        \globalletempty\stopHLcommand
        \accountTABLElinewidth
      \fi
      \setTABLEaction\TABLErule
      \nobreak}}

\let\startHLcommand\empty
\let\stopHLcommand \empty

\unexpanded\def\TableHC
  {\complexorsimpleTable{HC}}

\def\complexTableHC[#1]%
  {\TABLEnoalign
     {\gdef\startHCcommand{\startcolor[#1]}%
      \gdef\stopHCcommand {\stopcolor}}%
   \simpleTableHC}

\def\simpleTableHC
  {\TABLEnoalign
     {\globallet\startHLcommand\startHCcommand
      \globallet\stopHLcommand \stopHCcommand}%
   \HL}

%D \startitemize[3*ruim]
%D \sym{\type{\NL}} a vertical skip
%D \sym{\type{\NR}} goto the next row
%D \sym{\type{\NC}} goto the next column
%D \sym{\type{\FC}} a first column
%D \sym{\type{\MC}} a mid column
%D \sym{\type{\LC}} a last column
%D \stopitemize

% n+1 uitleggen

\unexpanded\def\defineTABLEsteps
  {\let\NL\TableNL
   \let\NR\TableNR
   \let\NC\TableNC
   \let\FC\TableNC
   \let\MC\TableNC
   \let\LC\TableNC}

\unexpanded\def\TableNL
  {\complexorsimpleTable{NL}}

\def\complexTableNL[#1]%
  {\TABLEnoalign
     {\edef\@@tiNL{#1}%
      \simpleTableNL}}%

\def\simpleTableNL
  {\TABLEnoalign
     {\nobreak
      \setbox0\vbox{\blank[\@@tiNL]}%
      \vskip\ht0
      \nobreak}}

\unexpanded\def\TableNR
  {\global\currentTABLEcolumn\zerocount
   \normalTABLElineending
   \TABLEnoalign
     {\nobreak
      \setTABLEaction\TABLEunknown}}

\unexpanded\def\TableNC
  {\checkTABLEautorow
   \global\advance\currentTABLEcolumn \plusone
   \normalTABLEquote}

%D \startitemize[3*broad]
%D \sym{\type{\DL}}
%D \sym{\type{\DV}} (\type{\VD})
%D \sym{\type{\DC}}
%D \sym{\type{\DR}}
%D \stopitemize

\newif\ifTABLEdivision

\unexpanded\def\defineTABLEdivisions
  {\global\TABLEdivisionfalse % in start
   \let\DL\TableDL
   \let\DC\TableDC
   \let\DV\TableDV
   \let\DR\TableDR}

\def\checkTABLEdivision
  {\ifTABLEdivision \else
     \chuckTABLEautorow
     \global\currentTABLEcolumn\zerocount
     \global\TABLEdivisiontrue
   \fi}

\unexpanded\def\TableDL
  {\checkTABLEdivision
   \complexorsimpleTable{DL}}

\def\simpleTableDL
  {\complexTableDL[1]}

\def\complexTableDL[#1]%
  {\ifnum\TABLEaction=\TABLErule
     \writestatus\m!TABLE{skipping \string\DL}%
   \else
     \ifnum\TABLEaction=\TABLEmidrow
       \writestatus\m!TABLE{change \string\MR\space into \string\LR/\string\SR}%
     \else\ifnum\TABLEaction=\TABLEfirstrow
       \writestatus\m!TABLE{change \string\MR\space into \string\SR}%
     \fi\fi
     \setTABLEaction\TABLEunknown
     \ifnum#1=\plusone
       \global\advance\currentTABLEcolumn \plustwo
       \let\next\normalTABLEsinglerule
     \else
       \global\advance\currentTABLEcolumn \plusone
       \def\next{\normalTABLEmultirule{#1}}%
     \fi
     \next
   \fi}

\unexpanded\def\TableDV
  {\TableDCV\normalTABLEsimplebar}

\unexpanded\def\TableDC
  {\TableDCV\normalTABLEquote}

\unexpanded\def\TableDCV#1%
  {\checkTABLEdivision
   \checkTABLEautorow
   \global\advance\currentTABLEcolumn \plusone
   #1}

\unexpanded\def\TableDR
  {\global\currentTABLEcolumn\zerocount    % nog check
   \normalTABLElineending
   \TABLEnoalign
     {\nobreak
      \global\TABLEdivisionfalse
      \accountTABLElinewidth % temporary solution
      \setTABLEaction\TABLErule}}

\def\accountTABLElinewidth
  {\scratchdimen\tablelinethicknessunit}

\unexpanded\def\defineTABLEshorthands
  {\def\SPAN##1{\use{##1}}%
   \def\TWO    {\use2}%
   \def\THREE  {\use3}%
   \def\FOUR   {\use4}%
   \def\FIVE   {\use5}%
   \def\SIX    {\use6}%
   \def\REF    {\ReFormat}}

\unexpanded\def\defineTABLEunits
  {\processaction
     [\@@tidistance]
     [  \v!none=>\OpenUp00\def\LOW{\Lower6 },
       \v!small=>\OpenUp00\def\LOW{\Lower6 }, % == baseline
      \v!medium=>\OpenUp11\def\LOW{\Lower7 },
         \v!big=>\OpenUp22\def\LOW{\Lower8 }]%
   \doifelse\@@tidistance\v!none
     {\TABLErowfactor\zerocount}
     {\TABLErowfactor\plustwo  }}

\def\dohandlebar % here ?
  {\ifmmode
     \@EA\domathmodebar
   \else\ifintable
     \@EAEAEA\domathmodebar
   \else
     \@EAEAEA\dotextmodebar
   \fi\fi}

\unexpanded\def\setuptables
  {\dosingleargument\dosetuptables}

\def\dosetuptables[#1]%
  {\getparameters[\??ti][#1]%
   \processaction
     [\@@tialign]
     [  \v!right=>\def\TABLEparalignment{\raggedright},
         \v!left=>\def\TABLEparalignment{\raggedleft},
       \v!middle=>\def\TABLEparalignment{\raggedcenter},
      \s!default=>\def\TABLEparalignment{\notragged},
      \s!unknown=>\def\TABLEparalignment{\notragged}]%
   \assignalfadimension\@@tiVL\@@tiVLwidth 246%
   \assignalfadimension\@@tiHL\@@tiHLheight246}

\def\localTABLEsetup
  {\@@ticommands\relax
   \expanded{\switchtobodyfont[\@@tibodyfont]}%
   \def\tablestrutheightfactor  {8}%
   \def\tablestrutdepthfactor   {4}%
   \def\tablelinethicknessfactor{4}%
   \NormalTLTU         {.1pt}%
   \NormalTSU          {\normalbaselineskip\divide\tablestrutunit 12 }%
   \NormalTableUnits}

%D And then I wrote the tabulate environment. That
%D alternative supports setting the rule thickness and color,
%D so here is the table alternative.

% \let\startglobalTABLEcolor\empty
% \let\stopglobalTABLEcolor \empty

\def\localTABLEsetup
  {\@@ticommands\relax
   \expanded{\switchtobodyfont[\@@tibodyfont]}%
   \def\tablelinethicknessfactor{4}%
   \scratchdimen\@@tirulethickness
   \divide\scratchdimen \tablelinethicknessfactor
   \expanded{\NormalTLTU{\the\scratchdimen}}%
   \doifelse\@@tiheight\v!strut
     {\edef\tablestrutheightfactor{\tablestrutheightfactor}}
     {\edef\tablestrutheightfactor{\@@tiheight}}%
   \doifelse\@@tidepth\v!strut
     {\edef\tablestrutdepthfactor{\tablestrutdepthfactor}}
     {\edef\tablestrutdepthfactor{\@@tidepth}}%
   \scratchdimen\tablestrutheightfactor\points \multiply\scratchdimen 10%
   \edef\tablestrutheightfactor{\withoutpt\the\scratchdimen}%
   \scratchdimen\tablestrutdepthfactor \points \multiply\scratchdimen 10%
   \edef\tablestrutdepthfactor{\withoutpt\the\scratchdimen}%
   % units
   \NormalTSU{\normalbaselineskip\divide\tablestrutunit 12 }%
   \NormalTableUnits}

%D As one can see, we didn't only add color, but also more
%D control over spacing.
%D
%D \startbuffer[a]
%D \starttable[|c|]
%D \HL
%D \VL \strut test \VL \FR
%D \VL \strut test \VL \MR
%D \VL \strut test \VL \MR
%D \VL \strut test \VL \LR
%D \HL
%D \stoptable
%D \stopbuffer
%D
%D \startbuffer[b]
%D \starttabulate[|c|]
%D \HL
%D \NC test \NC \NR
%D \NC test \NC \NR
%D \NC test \NC \NR
%D \NC test \NC \NR
%D \HL
%D \stoptabulate
%D \stopbuffer
%D
%D In the next example, the first table is defined as:
%D
%D \typebuffer[a]
%D
%D and the second one as:
%D
%D \typebuffer[b]
%D
%D The first table is typeset using the default height and
%D depth factors .8 and .4. The second table has both factors
%D set to \type {strut}, and the third table shows what
%D happens when we set the values to zero. The rightmost table
%D is typeset using the tabulate environment.
%D
%D \startcombination[4*1]
%D   {$\vcenter{\getbuffer[a]}$}
%D     {\hbox{h=.8 d=.4}}
%D   {\setuptables[height=strut,depth=strut]$\vcenter{\getbuffer[a]}$}
%D     {\hbox{h=d=\type{strut}}}
%D   {\setuptables[height=0,depth=0]$\vcenter{\getbuffer[a]}$}
%D     {\hbox{h=d=0}}
%D   {$\vcenter{\getbuffer[b]}$}
%D     {\hbox{tabulate}}
%D \stopcombination

\setuptables
  [HL=\v!medium,
   VL=\v!medium,
   NL=\v!small,
   \c!frame=,
   \c!align=\v!right,
   \c!depth=.40, % \v!strut
   \c!height=.80, % \v!strut
   \c!rulethickness=\linewidth,
   \c!rulecolor=,
   \c!distance=\v!medium,
   \c!bodyfont=\the\bodyfontsize,
   \c!commands=,
   \c!background=\v!screen,
   \c!backgroundscreen=\@@rsscreen,
   \c!backgroundcolor=,
   \c!split=\v!auto]

\def\ifintabel{\ifintable} % upward compatible

\protect \endinput
